ruff check...............................................................Failed
- hook id: ruff-check
- exit code: 1
- files were modified by this hook

warning: The top-level linter settings are deprecated in favour of their counterparts in the `lint` section. Please update the following options in `pyproject.toml`:
  - 'per-file-ignores' -> 'lint.per-file-ignores'
warning: `incorrect-blank-line-before-class` (D203) and `no-blank-line-before-class` (D211) are incompatible. Ignoring `incorrect-blank-line-before-class`.
warning: `multi-line-summary-first-line` (D212) and `multi-line-summary-second-line` (D213) are incompatible. Ignoring `multi-line-summary-second-line`.
INP001 File `doc/bokeh_digits_plot.py` is part of an implicit namespace package. Add an `__init__.py`.
--> doc/bokeh_digits_plot.py:1:1

E402 Module level import not at top of file
 --> doc/bokeh_digits_plot.py:7:1
  |
5 | digits = load_digits()
6 |
7 | import umap
  | ^^^^^^^^^^^
8 |
9 | reducer = umap.UMAP(random_state=42)
  |

E402 Module level import not at top of file
  --> doc/bokeh_digits_plot.py:12:1
   |
10 | embedding = reducer.fit_transform(digits.data)
11 |
12 | import base64
   | ^^^^^^^^^^^^^
13 | from io import BytesIO
   |

E402 Module level import not at top of file
  --> doc/bokeh_digits_plot.py:13:1
   |
12 | import base64
13 | from io import BytesIO
   | ^^^^^^^^^^^^^^^^^^^^^^
14 |
15 | from PIL import Image
   |

E402 Module level import not at top of file
  --> doc/bokeh_digits_plot.py:15:1
   |
13 | from io import BytesIO
14 |
15 | from PIL import Image
   | ^^^^^^^^^^^^^^^^^^^^^
   |

D103 Missing docstring in public function
  --> doc/bokeh_digits_plot.py:18:5
   |
18 | def embeddable_image(data):
   |     ^^^^^^^^^^^^^^^^
19 |     img_data = 255 - 15 * data.astype(np.uint8)
20 |     image = Image.fromarray(img_data, mode="L").resize((64, 64), Image.BICUBIC)
   |

E402 Module level import not at top of file
  --> doc/bokeh_digits_plot.py:27:1
   |
27 | from bokeh.models import CategoricalColorMapper, ColumnDataSource, HoverTool
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
28 | from bokeh.palettes import Spectral10
29 | from bokeh.plotting import figure, output_file, show
   |

E402 Module level import not at top of file
  --> doc/bokeh_digits_plot.py:28:1
   |
27 | from bokeh.models import CategoricalColorMapper, ColumnDataSource, HoverTool
28 | from bokeh.palettes import Spectral10
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
29 | from bokeh.plotting import figure, output_file, show
   |

E402 Module level import not at top of file
  --> doc/bokeh_digits_plot.py:29:1
   |
27 | from bokeh.models import CategoricalColorMapper, ColumnDataSource, HoverTool
28 | from bokeh.palettes import Spectral10
29 | from bokeh.plotting import figure, output_file, show
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
30 |
31 | output_file("basic_usage_bokeh_example.html")
   |

EXE001 Shebang is present but file is not executable
 --> doc/conf.py:1:1
  |
1 | #!/usr/bin/env python3
  | ^^^^^^^^^^^^^^^^^^^^^^
2 | #
3 | # umap documentation build configuration file, created by
  |

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> doc/conf.py:22:20
   |
20 | import sys
21 |
22 | sys.path.insert(0, os.path.abspath("."))
   |                    ^^^^^^^^^^^^^^^
23 | sys.path.insert(0, os.path.abspath(".."))
   |
help: Replace with `Path(...).resolve()`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> doc/conf.py:23:20
   |
22 | sys.path.insert(0, os.path.abspath("."))
23 | sys.path.insert(0, os.path.abspath(".."))
   |                    ^^^^^^^^^^^^^^^
   |
help: Replace with `Path(...).resolve()`

ERA001 Found commented-out code
  --> doc/conf.py:30:1
   |
28 | # If your documentation needs a minimal Sphinx version, state it here.
29 | #
30 | # needs_sphinx = '1.0'
   | ^^^^^^^^^^^^^^^^^^^^^^
31 |
32 | # Add any Sphinx extension module names here, as strings. They can be
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> doc/conf.py:51:1
   |
49 | # You can specify multiple suffix as a list of string:
50 | #
51 | # source_suffix = ['.rst', '.md']
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
52 | source_suffix = ".rst"
   |
help: Remove commented-out code

A001 Variable `copyright` is shadowing a Python builtin
  --> doc/conf.py:59:1
   |
57 | # General information about the project.
58 | project = "umap"
59 | copyright = "2018, Leland McInnes"
   | ^^^^^^^^^
60 | author = "Leland McInnes"
   |

ERA001 Found commented-out code
  --> doc/conf.py:95:1
   |
93 | # a list of builtin themes.
94 | #
95 | # html_theme = 'alabaster'
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^
96 | html_theme = "sphinx_rtd_theme"
   |
help: Remove commented-out code

ERA001 Found commented-out code
   --> doc/conf.py:121:1
    |
119 | # This is required for the alabaster theme
120 | # refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars
121 | # html_sidebars = {
    | ^^^^^^^^^^^^^^^^^^^
122 | #     '**': [
123 | #         'relations.html',  # needs 'show_related': True theme option to display
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> doc/conf.py:123:1
    |
121 | # html_sidebars = {
122 | #     '**': [
123 | #         'relations.html',  # needs 'show_related': True theme option to display
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
124 | #         'searchbox.html',
125 | #     ]
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> doc/conf.py:125:1
    |
123 | #         'relations.html',  # needs 'show_related': True theme option to display
124 | #         'searchbox.html',
125 | #     ]
    | ^^^^^^^
126 | # }
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> doc/conf.py:126:1
    |
124 | #         'searchbox.html',
125 | #     ]
126 | # }
    | ^^^
127 |
128 | html_sidebars = {
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> doc/conf.py:148:5
    |
146 |     # The paper size ('letterpaper' or 'a4paper').
147 |     #
148 |     # 'papersize': 'letterpaper',
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
149 |     # The font size ('10pt', '11pt' or '12pt').
150 |     #
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> doc/conf.py:151:5
    |
149 |     # The font size ('10pt', '11pt' or '12pt').
150 |     #
151 |     # 'pointsize': '10pt',
    |     ^^^^^^^^^^^^^^^^^^^^^^
152 |     # Additional stuff for the LaTeX preamble.
153 |     #
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> doc/conf.py:154:5
    |
152 |     # Additional stuff for the LaTeX preamble.
153 |     #
154 |     # 'preamble': '',
    |     ^^^^^^^^^^^^^^^^^
155 |     # Latex figure (float) alignment
156 |     #
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> doc/conf.py:157:5
    |
155 |     # Latex figure (float) alignment
156 |     #
157 |     # 'figure_align': 'htbp',
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
158 | }
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> doc/conf.py:215:9
    |
213 |         # The commented-out URLs are supposed to have search.js files under them.
214 |         "umap": None,
215 |         # "python": "https://docs.python.org/{.major}".format(sys.version_info),
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
216 |         # Numpy actually DOES have a search.js file but does return valid JSON
217 |         # (missing double quotes on some property names)
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> doc/conf.py:218:9
    |
216 |         # Numpy actually DOES have a search.js file but does return valid JSON
217 |         # (missing double quotes on some property names)
218 |         # "numpy": "https://docs.scipy.org/doc/numpy/",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
219 |         # scipt ends up with  a 404 for a different URL
220 |         # "scipy": "https://docs.scipy.org/doc/scipy/reference",
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> doc/conf.py:220:9
    |
218 |         # "numpy": "https://docs.scipy.org/doc/numpy/",
219 |         # scipt ends up with  a 404 for a different URL
220 |         # "scipy": "https://docs.scipy.org/doc/scipy/reference",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
221 |         "matplotlib": "https://matplotlib.org/",
222 |         # "pandas": "https://pandas.pydata.org/pandas-docs/stable/",
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> doc/conf.py:222:9
    |
220 |         # "scipy": "https://docs.scipy.org/doc/scipy/reference",
221 |         "matplotlib": "https://matplotlib.org/",
222 |         # "pandas": "https://pandas.pydata.org/pandas-docs/stable/",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
223 |         # "sklearn": "http://scikit-learn.org/stable/",
224 |         "bokeh": "http://bokeh.pydata.org/en/latest/",
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> doc/conf.py:223:9
    |
221 |         "matplotlib": "https://matplotlib.org/",
222 |         # "pandas": "https://pandas.pydata.org/pandas-docs/stable/",
223 |         # "sklearn": "http://scikit-learn.org/stable/",
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
224 |         "bokeh": "http://bokeh.pydata.org/en/latest/",
225 |     },
    |
help: Remove commented-out code

D103 Missing docstring in public function
   --> doc/conf.py:229:5
    |
229 | def setup(app):
    |     ^^^^^
230 |     app.add_js_file(
231 |         "https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js",
    |

INP001 File `doc/plotting_example_interactive.py` is part of an implicit namespace package. Add an `__init__.py`.
--> doc/plotting_example_interactive.py:1:1

INP001 File `doc/plotting_example_nomic_atlas.py` is part of an implicit namespace package. Add an `__init__.py`.
--> doc/plotting_example_nomic_atlas.py:1:1

INP001 File `examples/digits/digits.py` is part of an implicit namespace package. Add an `__init__.py`.
--> examples/digits/digits.py:1:1

INP001 File `examples/galaxy10sdss.py` is part of an implicit namespace package. Add an `__init__.py`.
--> examples/galaxy10sdss.py:1:1

D205 1 blank line required between summary line and description
  --> examples/galaxy10sdss.py:1:1
   |
 1 | / """UMAP on the Galaxy10SDSS dataset.
 2 | | ---------------------------------------------------------
 3 | |
 4 | | This is an example of using UMAP on the Galaxy10SDSS
 5 | | dataset. The goal of this example is largely to
 6 | | demonstrate the use of supervised learning as an
 7 | | effective tool for visualizing and reducing complex data.
 8 | | In addition, hdbscan is used to classify the processed
 9 | | data.
10 | | """
   | |___^
11 |
12 |   # from sklearn.model_selection import train_test_split
   |
help: Insert single blank line

ERA001 Found commented-out code
  --> examples/galaxy10sdss.py:12:1
   |
10 | """
11 |
12 | # from sklearn.model_selection import train_test_split
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 | import math
14 | import os
   |
help: Remove commented-out code

PTH113 `os.path.isfile()` should be replaced by `Path.is_file()`
  --> examples/galaxy10sdss.py:26:8
   |
24 | import umap
25 |
26 | if not os.path.isfile("Galaxy10.h5"):
   |        ^^^^^^^^^^^^^^
27 |     url = "http://astro.utoronto.ca/~bovy/Galaxy10/Galaxy10.h5"
28 |     r = requests.get(url, allow_redirects=True)
   |
help: Replace with `Path(...).is_file()`

S113 Probable use of `requests` call without timeout
  --> examples/galaxy10sdss.py:28:9
   |
26 | if not os.path.isfile("Galaxy10.h5"):
27 |     url = "http://astro.utoronto.ca/~bovy/Galaxy10/Galaxy10.h5"
28 |     r = requests.get(url, allow_redirects=True)
   |         ^^^^^^^^^^^^
29 |     open("Galaxy10.h5", "wb").write(r.content)
   |

SIM115 Use a context manager for opening files
  --> examples/galaxy10sdss.py:29:5
   |
27 |     url = "http://astro.utoronto.ca/~bovy/Galaxy10/Galaxy10.h5"
28 |     r = requests.get(url, allow_redirects=True)
29 |     open("Galaxy10.h5", "wb").write(r.content)
   |     ^^^^
30 |
31 | # To get the images and labels from file
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> examples/galaxy10sdss.py:29:5
   |
27 |     url = "http://astro.utoronto.ca/~bovy/Galaxy10/Galaxy10.h5"
28 |     r = requests.get(url, allow_redirects=True)
29 |     open("Galaxy10.h5", "wb").write(r.content)
   |     ^^^^
30 |
31 | # To get the images and labels from file
   |
help: Replace with `Path.open()`

INP001 File `examples/iris/iris.py` is part of an implicit namespace package. Add an `__init__.py`.
--> examples/iris/iris.py:1:1

D401 First line of docstring should be in imperative mood: "Standard euclidean distance."
  --> examples/mnist_torus_sphere_example.py:43:9
   |
41 |       @numba.njit(fastmath=True)
42 |       def torus_euclidean_grad(x, y, torus_dimensions=(2 * np.pi, 2 * np.pi)):
43 | /         r"""Standard euclidean distance.
44 | |
45 | |         ..math::
46 | |             D(x, y) = \sqrt{\sum_i (x_i - y_i)^2}
47 | |         """
   | |___________^
48 |           distance_sqr = 0.0
49 |           g = np.zeros_like(x)
   |

D205 1 blank line required between summary line and description
  --> examples/mnist_transform_new_data.py:3:1
   |
 1 |   #!/usr/bin/env python
 2 |
 3 | / """UMAP on the MNIST Digits dataset.
 4 | | --------------------------------
 5 | |
 6 | | A simple example demonstrating how to use UMAP on a larger
 7 | | dataset such as MNIST. We first pull the MNIST dataset and
 8 | | then use UMAP to reduce it to only 2-dimensions for
 9 | | easy visualisation.
10 | |
11 | | Note that UMAP manages to both group the individual digit
12 | | classes, but also to retain the overall global structure
13 | | among the different digit classes -- keeping 1 far from
14 | | 0, and grouping triplets of 3,5,8 and 4,7,9 which can
15 | | blend into one another in some cases.
16 | | """
   | |___^
17 |   import matplotlib.pyplot as plt
18 |   import seaborn as sns
   |
help: Insert single blank line

INP001 File `examples/plot_algorithm_comparison.py` is part of an implicit namespace package. Add an `__init__.py`.
--> examples/plot_algorithm_comparison.py:1:1

D205 1 blank line required between summary line and description
  --> examples/plot_algorithm_comparison.py:1:1
   |
 1 | / """Comparison of Dimension Reduction Techniques.
 2 | | --------------------------------------------
 3 | |
 4 | | A comparison of several different dimension reduction
 5 | | techniques on a variety of toy datasets. The datasets
 6 | | are all toy datasets, but should provide a representative
 7 | | range of the strengths and weaknesses of the different
 8 | | algorithms.
 9 | |
10 | | The time to perform the dimension reduction with each
11 | | algorithm and each dataset is recorded in the lower
12 | | right of each plot.
13 | |
14 | | Things to note about the datasets:
15 | |
16 | | - Blobs: A set of five gaussian blobs in 10 dimensional
17 | |          space. This should be a prototypical example
18 | |          of something that should clearly separate
19 | |          even in a reduced dimension space.
20 | | - Iris: a classic small dataset with one distinct class
21 | |         and two classes that are not clearly separated.
22 | | - Digits: handwritten digits -- ideally different digit
23 | |           classes should form distinct groups. Due to
24 | |           the nature of handwriting digits may have several
25 | |           forms (crossed or uncrossed sevens, capped or
26 | |           straight line oes, etc.)
27 | | - Wine: wine characteristics ideally used for a toy
28 | |         regression. Ultimately the data is essentially
29 | |         one dimensional in nature.
30 | | - Swiss Roll: data is essentially a rectangle, but
31 | |               has been "rolled up" like a swiss roll
32 | |               in three dimensional space. Ideally a
33 | |               dimension reduction technique should
34 | |               be able to "unroll" it. The data
35 | |               has been coloured according to one dimension
36 | |               of the rectangle, so should form
37 | |               a rectangle of smooth color variation.
38 | | - Sphere: the two dimensional surface of a three
39 | |           dimensional sphere. This cannot be represented
40 | |           accurately in two dimensions without tearing.
41 | |           The sphere has been coloured with hue around
42 | |           the equator and black to white from the south
43 | |           to north pole.
44 | | """
   | |___^
45 |
46 |   import time
   |
help: Insert single blank line

NPY002 Replace legacy `np.random.normal` call with `np.random.Generator`
  --> examples/plot_algorithm_comparison.py:67:10
   |
65 |     n_samples=1000, noise=0.1, random_state=42,
66 | )
67 | sphere = np.random.normal(size=(600, 3))
   |          ^^^^^^^^^^^^^^^^
68 | sphere = preprocessing.normalize(sphere)
69 | sphere_hsv = np.array(
   |

ERA001 Found commented-out code
  --> examples/plot_algorithm_comparison.py:83:5
   |
81 | reducers = [
82 |     (manifold.TSNE, {"perplexity": 50}),
83 |     # (manifold.LocallyLinearEmbedding, {'n_neighbors':10, 'method':'hessian'}),
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
84 |     (manifold.Isomap, {"n_neighbors": 30}),
85 |     (manifold.MDS, {}),
   |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/plot_algorithm_comparison.py:105:1
    |
103 | ax_list = []
104 |
105 | # plt.figure(figsize=(9 * 2 + 3, 12.5))
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
106 | plt.figure(figsize=(10, 8))
107 | plt.subplots_adjust(
    |
help: Remove commented-out code

INP001 File `examples/plot_fashion-mnist_example.py` is part of an implicit namespace package. Add an `__init__.py`.
--> examples/plot_fashion-mnist_example.py:1:1

D205 1 blank line required between summary line and description
  --> examples/plot_fashion-mnist_example.py:1:1
   |
 1 | / """UMAP on the Fashion MNIST Digits dataset using Datashader.
 2 | | ---------------------------------------------------------
 3 | |
 4 | | This is a simple example of using UMAP on the Fashion-MNIST
 5 | | dataset. The goal of this example is largely to demonstrate
 6 | | the use of datashader as an effective tool for visualising
 7 | | UMAP results. In particular datashader allows visualisation
 8 | | of very large datasets where overplotting can be a serious
 9 | | problem. It supports coloring by categorical variables
10 | | (as shown in this example), or by continuous variables,
11 | | or by density (as is common in datashader examples).
12 | | """
   | |___^
13 |
14 |   import os
   |
help: Insert single blank line

PTH113 `os.path.isfile()` should be replaced by `Path.is_file()`
  --> examples/plot_fashion-mnist_example.py:29:8
   |
27 | sns.set(context="paper", style="white")
28 |
29 | if not os.path.isfile("fashion-mnist.csv"):
   |        ^^^^^^^^^^^^^^
30 |     csv_data = requests.get("https://www.openml.org/data/get_csv/18238735/phpnBqZGZ")
31 |     with open("fashion-mnist.csv", "w") as f:
   |
help: Replace with `Path(...).is_file()`

S113 Probable use of `requests` call without timeout
  --> examples/plot_fashion-mnist_example.py:30:16
   |
29 | if not os.path.isfile("fashion-mnist.csv"):
30 |     csv_data = requests.get("https://www.openml.org/data/get_csv/18238735/phpnBqZGZ")
   |                ^^^^^^^^^^^^
31 |     with open("fashion-mnist.csv", "w") as f:
32 |         f.write(csv_data.text)
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> examples/plot_fashion-mnist_example.py:31:10
   |
29 | if not os.path.isfile("fashion-mnist.csv"):
30 |     csv_data = requests.get("https://www.openml.org/data/get_csv/18238735/phpnBqZGZ")
31 |     with open("fashion-mnist.csv", "w") as f:
   |          ^^^^
32 |         f.write(csv_data.text)
33 | source_df = pd.read_csv("fashion-mnist.csv")
   |
help: Replace with `Path.open()`

PD011 Use `.to_numpy()` instead of `.values`
  --> examples/plot_fashion-mnist_example.py:35:8
   |
33 | source_df = pd.read_csv("fashion-mnist.csv")
34 |
35 | data = source_df.iloc[:, :784].values.astype(np.float32)
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
36 | target = source_df["class"].values
   |

PD011 Use `.to_numpy()` instead of `.values`
  --> examples/plot_fashion-mnist_example.py:36:10
   |
35 | data = source_df.iloc[:, :784].values.astype(np.float32)
36 | target = source_df["class"].values
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^
37 |
38 | pal = [
   |

INP001 File `examples/plot_feature_extraction_classification.py` is part of an implicit namespace package. Add an `__init__.py`.
--> examples/plot_feature_extraction_classification.py:1:1

D205 1 blank line required between summary line and description
  --> examples/plot_feature_extraction_classification.py:1:1
   |
 1 | / """UMAP as a Feature Extraction Technique for Classification.
 2 | | ---------------------------------------------------------
 3 | |
 4 | | The following script shows how UMAP can be used as a feature extraction
 5 | | technique to improve the accuracy on a classification task. It also shows
 6 | | how UMAP can be integrated in standard scikit-learn pipelines.
 7 | |
 8 | | The first step is to create a dataset for a classification task, which is
 9 | | performed with the function ``sklearn.datasets.make_classification``. The
10 | | dataset is then split into a training set and a test set using the
11 | | ``sklearn.model_selection.train_test_split`` function.
12 | |
13 | | Second, a linear SVM is fitted on the training set. To choose the best
14 | | hyperparameters automatically, a gridsearch is performed on the training set.
15 | | The performance of the model is then evaluated on the test set with the
16 | | accuracy metric.
17 | |
18 | |  Third, the previous step is repeated with a slight modification: UMAP is
19 | |  used as a feature extraction technique. This small change results in a
20 | |  substantial improvement compared to the model where raw data is used.
21 | | """
   | |___^
22 |
23 |   from sklearn.datasets import make_classification
   |
help: Insert single blank line

INP001 File `examples/plot_mnist_example.py` is part of an implicit namespace package. Add an `__init__.py`.
--> examples/plot_mnist_example.py:1:1

D205 1 blank line required between summary line and description
  --> examples/plot_mnist_example.py:1:1
   |
 1 | / """UMAP on the MNIST Digits dataset.
 2 | | --------------------------------
 3 | |
 4 | | A simple example demonstrating how to use UMAP on a larger
 5 | | dataset such as MNIST. We first pull the MNIST dataset and
 6 | | then use UMAP to reduce it to only 2-dimensions for
 7 | | easy visualisation.
 8 | |
 9 | | Note that UMAP manages to both group the individual digit
10 | | classes, but also to retain the overall global structure
11 | | among the different digit classes -- keeping 1 far from
12 | | 0, and grouping triplets of 3,5,8 and 4,7,9 which can
13 | | blend into one another in some cases.
14 | | """
   | |___^
15 |
16 |   import matplotlib.pyplot as plt
   |
help: Insert single blank line

F401 `.umap_.UMAP` imported but unused; consider removing, adding to `__all__`, or using a redundant alias
 --> umap/__init__.py:3:20
  |
1 | from warnings import catch_warnings, simplefilter, warn
2 |
3 | from .umap_ import UMAP
  |                    ^^^^
4 |
5 | try:
  |
help: Use an explicit re-export: `UMAP as UMAP`

F401 `.parametric_umap.load_ParametricUMAP` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> umap/__init__.py:8:54
   |
 6 |     with catch_warnings():
 7 |         simplefilter("ignore")
 8 |         from .parametric_umap import ParametricUMAP, load_ParametricUMAP
   |                                                      ^^^^^^^^^^^^^^^^^^^
 9 | except ImportError:
10 |     warn(
   |
help: Remove unused import: `.parametric_umap.load_ParametricUMAP`

D101 Missing docstring in public class
  --> umap/__init__.py:16:11
   |
15 |     # Add a dummy class to raise an error
16 |     class ParametricUMAP:
   |           ^^^^^^^^^^^^^^
17 |         def __init__(self, **kwds):
18 |             warn(
   |

D107 Missing docstring in `__init__`
  --> umap/__init__.py:17:13
   |
15 |     # Add a dummy class to raise an error
16 |     class ParametricUMAP:
17 |         def __init__(self, **kwds):
   |             ^^^^^^^^
18 |             warn(
19 |                 """The umap.parametric_umap package requires Tensorflow > 2.0 to be installed.
   |

ARG002 Unused method argument: `kwds`
  --> umap/__init__.py:17:30
   |
15 |     # Add a dummy class to raise an error
16 |     class ParametricUMAP:
17 |         def __init__(self, **kwds):
   |                              ^^^^
18 |             warn(
19 |                 """The umap.parametric_umap package requires Tensorflow > 2.0 to be installed.
   |

F401 `numba` imported but unused
  --> umap/__init__.py:37:8
   |
36 | # Workaround: https://github.com/numba/numba/issues/3341
37 | import numba
   |        ^^^^^
38 |
39 | from .aligned_umap import AlignedUMAP
   |
help: Remove unused import: `numba`

F401 `.aligned_umap.AlignedUMAP` imported but unused; consider removing, adding to `__all__`, or using a redundant alias
  --> umap/__init__.py:39:27
   |
37 | import numba
38 |
39 | from .aligned_umap import AlignedUMAP
   |                           ^^^^^^^^^^^
40 |
41 | try:
   |
help: Use an explicit re-export: `AlignedUMAP as AlignedUMAP`

D103 Missing docstring in public function
  --> umap/aligned_umap.py:17:5
   |
16 | @numba.njit(parallel=True)
17 | def in1d(arr, test_set):
   |     ^^^^
18 |     test_set = set(test_set)
19 |     result = np.empty(arr.shape[0], dtype=np.bool_)
   |

D103 Missing docstring in public function
  --> umap/aligned_umap.py:29:5
   |
29 | def invert_dict(d):
   |     ^^^^^^^^^^^
30 |     return {value: key for key, value in d.items()}
   |

D103 Missing docstring in public function
  --> umap/aligned_umap.py:34:5
   |
33 | @numba.njit()
34 | def procrustes_align(embedding_base, embedding_to_align, anchors):
   |     ^^^^^^^^^^^^^^^^
35 |     subset1 = embedding_base[anchors[0]]
36 |     subset2 = embedding_to_align[anchors[1]]
   |

N806 Variable `M` in function should be lowercase
  --> umap/aligned_umap.py:37:5
   |
35 |     subset1 = embedding_base[anchors[0]]
36 |     subset2 = embedding_to_align[anchors[1]]
37 |     M = subset2.T @ subset1
   |     ^
38 |     U, _S, V = np.linalg.svd(M)
39 |     R = U @ V
   |

N806 Variable `U` in function should be lowercase
  --> umap/aligned_umap.py:38:5
   |
36 |     subset2 = embedding_to_align[anchors[1]]
37 |     M = subset2.T @ subset1
38 |     U, _S, V = np.linalg.svd(M)
   |     ^
39 |     R = U @ V
40 |     return embedding_to_align @ R
   |

N806 Variable `_S` in function should be lowercase
  --> umap/aligned_umap.py:38:8
   |
36 |     subset2 = embedding_to_align[anchors[1]]
37 |     M = subset2.T @ subset1
38 |     U, _S, V = np.linalg.svd(M)
   |        ^^
39 |     R = U @ V
40 |     return embedding_to_align @ R
   |

N806 Variable `V` in function should be lowercase
  --> umap/aligned_umap.py:38:12
   |
36 |     subset2 = embedding_to_align[anchors[1]]
37 |     M = subset2.T @ subset1
38 |     U, _S, V = np.linalg.svd(M)
   |            ^
39 |     R = U @ V
40 |     return embedding_to_align @ R
   |

N806 Variable `R` in function should be lowercase
  --> umap/aligned_umap.py:39:5
   |
37 |     M = subset2.T @ subset1
38 |     U, _S, V = np.linalg.svd(M)
39 |     R = U @ V
   |     ^
40 |     return embedding_to_align @ R
   |

D103 Missing docstring in public function
  --> umap/aligned_umap.py:43:5
   |
43 | def expand_relations(relation_dicts, window_size=3):
   |     ^^^^^^^^^^^^^^^^
44 |     max_n_samples = (
45 |         max(
   |

D103 Missing docstring in public function
  --> umap/aligned_umap.py:86:5
   |
85 | @numba.njit()
86 | def build_neighborhood_similarities(graphs_indptr, graphs_indices, relations):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
87 |     result = np.zeros(relations.shape, dtype=np.float32)
88 |     center_index = (relations.shape[1] - 1) // 2
   |

D103 Missing docstring in public function
   --> umap/aligned_umap.py:132:5
    |
132 | def get_nth_item_or_val(iterable_or_val, n):
    |     ^^^^^^^^^^^^^^^^^^^
133 |     if iterable_or_val is None:
134 |         return None
    |

D103 Missing docstring in public function
   --> umap/aligned_umap.py:167:5
    |
167 | def set_aligned_params(new_params, existing_params, n_models, param_names=PARAM_NAMES):
    |     ^^^^^^^^^^^^^^^^^^
168 |     for param in param_names:
169 |         if param in new_params:
    |

D103 Missing docstring in public function
   --> umap/aligned_umap.py:187:5
    |
186 | @numba.njit()
187 | def init_from_existing_internal(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
188 |     previous_embedding, weights_indptr, weights_indices, weights_data, relation_dict,
189 | ):
    |

NPY002 Replace legacy `np.random.uniform` call with `np.random.Generator`
   --> umap/aligned_umap.py:207:29
    |
205 |                     )
206 |             if normalisation == 0:
207 |                 result[i] = np.random.uniform(-10.0, 10.0, n_features)
    |                             ^^^^^^^^^^^^^^^^^
208 |             else:
209 |                 result[i] /= normalisation
    |

D103 Missing docstring in public function
   --> umap/aligned_umap.py:214:5
    |
214 | def init_from_existing(previous_embedding, graph, relations):
    |     ^^^^^^^^^^^^^^^^^^
215 |     typed_relations = numba.typed.Dict.empty(numba.types.int32, numba.types.int32)
216 |     for key, val in relations.items():
    |

D101 Missing docstring in public class
   --> umap/aligned_umap.py:227:7
    |
227 | class AlignedUMAP(BaseEstimator):
    |       ^^^^^^^^^^^
228 |     def __init__(
229 |         self,
    |

PLR0913 Too many arguments in function definition (29 > 5)
   --> umap/aligned_umap.py:228:9
    |
227 | class AlignedUMAP(BaseEstimator):
228 |     def __init__(
    |         ^^^^^^^^
229 |         self,
230 |         n_neighbors=15,
    |

D107 Missing docstring in `__init__`
   --> umap/aligned_umap.py:228:9
    |
227 | class AlignedUMAP(BaseEstimator):
228 |     def __init__(
    |         ^^^^^^^^
229 |         self,
230 |         n_neighbors=15,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/aligned_umap.py:241:9
    |
239 |         min_dist=0.1,
240 |         spread=1.0,
241 |         low_memory=False,
    |         ^^^^^^^^^^
242 |         set_op_mix_ratio=1.0,
243 |         local_connectivity=1.0,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/aligned_umap.py:250:9
    |
248 |         b=None,
249 |         random_state=None,
250 |         angular_rp_forest=False,
    |         ^^^^^^^^^^^^^^^^^
251 |         target_n_neighbors=-1,
252 |         target_metric="categorical",
    |

FBT002 Boolean default positional argument in function definition
   --> umap/aligned_umap.py:256:9
    |
254 |         target_weight=0.5,
255 |         transform_seed=42,
256 |         force_approximation_algorithm=False,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
257 |         verbose=False,
258 |         unique=False,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/aligned_umap.py:257:9
    |
255 |         transform_seed=42,
256 |         force_approximation_algorithm=False,
257 |         verbose=False,
    |         ^^^^^^^
258 |         unique=False,
259 |     ):
    |

FBT002 Boolean default positional argument in function definition
   --> umap/aligned_umap.py:258:9
    |
256 |         force_approximation_algorithm=False,
257 |         verbose=False,
258 |         unique=False,
    |         ^^^^^^
259 |     ):
    |

D102 Missing docstring in public method
   --> umap/aligned_umap.py:294:9
    |
292 |         self.b = b
293 |
294 |     def fit(self, X, y=None, **fit_params):
    |         ^^^
295 |         if "relations" not in fit_params:
296 |             msg = "Aligned UMAP requires relations between data to be specified"
    |

N803 Argument name `X` should be lowercase
   --> umap/aligned_umap.py:294:19
    |
292 |         self.b = b
293 |
294 |     def fit(self, X, y=None, **fit_params):
    |                   ^
295 |         if "relations" not in fit_params:
296 |             msg = "Aligned UMAP requires relations between data to be specified"
    |

S101 Use of `assert` detected
   --> umap/aligned_umap.py:302:9
    |
301 |         self.dict_relations_ = fit_params["relations"]
302 |         assert type(self.dict_relations_) in (list, tuple)
    |         ^^^^^^
303 |         assert type(X) in (list, tuple, np.ndarray)
304 |         assert (len(X) - 1) == (len(self.dict_relations_))
    |

S101 Use of `assert` detected
   --> umap/aligned_umap.py:303:9
    |
301 |         self.dict_relations_ = fit_params["relations"]
302 |         assert type(self.dict_relations_) in (list, tuple)
303 |         assert type(X) in (list, tuple, np.ndarray)
    |         ^^^^^^
304 |         assert (len(X) - 1) == (len(self.dict_relations_))
    |

S101 Use of `assert` detected
   --> umap/aligned_umap.py:304:9
    |
302 |         assert type(self.dict_relations_) in (list, tuple)
303 |         assert type(X) in (list, tuple, np.ndarray)
304 |         assert (len(X) - 1) == (len(self.dict_relations_))
    |         ^^^^^^
305 |
306 |         if y is not None:
    |

S101 Use of `assert` detected
   --> umap/aligned_umap.py:307:13
    |
306 |         if y is not None:
307 |             assert type(y) in (list, tuple, np.ndarray)
    |             ^^^^^^
308 |             assert (len(y) - 1) == (len(self.dict_relations_))
309 |         else:
    |

S101 Use of `assert` detected
   --> umap/aligned_umap.py:308:13
    |
306 |         if y is not None:
307 |             assert type(y) in (list, tuple, np.ndarray)
308 |             assert (len(y) - 1) == (len(self.dict_relations_))
    |             ^^^^^^
309 |         else:
310 |             y = [None] * len(X)
    |

SLF001 Private member accessed: `_raw_data`
   --> umap/aligned_umap.py:382:13
    |
380 |         )
381 |         first_init = spectral_layout(
382 |             self.mappers_[0]._raw_data,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^
383 |             self.mappers_[0].graph_,
384 |             self.n_components,
    |

SLF001 Private member accessed: `_raw_data`
   --> umap/aligned_umap.py:397:17
    |
395 |         for i in range(1, self.n_models_):
396 |             next_init = spectral_layout(
397 |                 self.mappers_[i]._raw_data,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
398 |                 self.mappers_[i].graph_,
399 |                 self.n_components,
    |

D102 Missing docstring in public method
   --> umap/aligned_umap.py:443:9
    |
441 |         return self
442 |
443 |     def fit_transform(self, X, y=None, **fit_params):
    |         ^^^^^^^^^^^^^
444 |         self.fit(X, y, **fit_params)
445 |         return self.embeddings_
    |

N803 Argument name `X` should be lowercase
   --> umap/aligned_umap.py:443:29
    |
441 |         return self
442 |
443 |     def fit_transform(self, X, y=None, **fit_params):
    |                             ^
444 |         self.fit(X, y, **fit_params)
445 |         return self.embeddings_
    |

D102 Missing docstring in public method
   --> umap/aligned_umap.py:447:9
    |
445 |         return self.embeddings_
446 |
447 |     def update(self, X, y=None, **fit_params):
    |         ^^^^^^
448 |         if "relations" not in fit_params:
449 |             msg = "Aligned UMAP requires relations between data to be specified"
    |

N803 Argument name `X` should be lowercase
   --> umap/aligned_umap.py:447:22
    |
445 |         return self.embeddings_
446 |
447 |     def update(self, X, y=None, **fit_params):
    |                      ^
448 |         if "relations" not in fit_params:
449 |             msg = "Aligned UMAP requires relations between data to be specified"
    |

S101 Use of `assert` detected
   --> umap/aligned_umap.py:455:9
    |
454 |         new_dict_relations = fit_params["relations"]
455 |         assert isinstance(new_dict_relations, dict)
    |         ^^^^^^
456 |
457 |         X = check_array(X)
    |

N806 Variable `X` in function should be lowercase
   --> umap/aligned_umap.py:457:9
    |
455 |         assert isinstance(new_dict_relations, dict)
456 |
457 |         X = check_array(X)
    |         ^
458 |
459 |         self.__dict__ = set_aligned_params(fit_params, self.__dict__, self.n_models_)
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> umap/aligned_umap.py:541:11
    |
539 |         )
540 |
541 |         # TODO: We can likely make this more efficient and not recompute each time
    |           ^^^^
542 |         inv_dict_relations = invert_dict(new_dict_relations)
    |

TD003 Missing issue link for this TODO
   --> umap/aligned_umap.py:541:11
    |
539 |         )
540 |
541 |         # TODO: We can likely make this more efficient and not recompute each time
    |           ^^^^
542 |         inv_dict_relations = invert_dict(new_dict_relations)
    |

FIX002 Line contains TODO, consider resolving the issue
   --> umap/aligned_umap.py:541:11
    |
539 |         )
540 |
541 |         # TODO: We can likely make this more efficient and not recompute each time
    |           ^^^^
542 |         inv_dict_relations = invert_dict(new_dict_relations)
    |

D103 Missing docstring in public function
  --> umap/distances.py:15:5
   |
14 | @numba.njit()
15 | def sign(a):
   |     ^^^^
16 |     if a < 0:
17 |         return -1
   |

D401 First line of docstring should be in imperative mood: "Standard euclidean distance."
  --> umap/distances.py:23:5
   |
21 |   @numba.njit(fastmath=True)
22 |   def euclidean(x, y):
23 | /     r"""Standard euclidean distance.
24 | |
25 | |     ..math::
26 | |         D(x, y) = \sqrt{\sum_i (x_i - y_i)^2}
27 | |     """
   | |_______^
28 |       result = 0.0
29 |       for i in range(x.shape[0]):
   |

D401 First line of docstring should be in imperative mood: "Standard euclidean distance and its gradient."
  --> umap/distances.py:36:5
   |
34 |   @numba.njit(fastmath=True)
35 |   def euclidean_grad(x, y):
36 | /     r"""Standard euclidean distance and its gradient.
37 | |
38 | |     ..math::
39 | |         D(x, y) = \sqrt{\sum_i (x_i - y_i)^2}
40 | |         \frac{dD(x, y)}{dx} = (x_i - y_i)/D(x,y)
41 | |     """
   | |_______^
42 |       result = 0.0
43 |       for i in range(x.shape[0]):
   |

D205 1 blank line required between summary line and description
  --> umap/distances.py:52:5
   |
50 |   @numba.njit()
51 |   def standardised_euclidean(x, y, sigma=_mock_ones):
52 | /     r"""Euclidean distance standardised against a vector of standard
53 | |     deviations per coordinate.
54 | |
55 | |     ..math::
56 | |         D(x, y) = \sqrt{\sum_i \frac{(x_i - y_i)**2}{v_i}}
57 | |     """
   | |_______^
58 |       result = 0.0
59 |       for i in range(x.shape[0]):
   |
help: Insert single blank line

D205 1 blank line required between summary line and description
  --> umap/distances.py:67:5
   |
65 |   @numba.njit(fastmath=True)
66 |   def standardised_euclidean_grad(x, y, sigma=_mock_ones):
67 | /     r"""Euclidean distance standardised against a vector of standard
68 | |     deviations per coordinate with gradient.
69 | |
70 | |     ..math::
71 | |         D(x, y) = \sqrt{\sum_i \frac{(x_i - y_i)**2}{v_i}}
72 | |     """
   | |_______^
73 |       result = 0.0
74 |       for i in range(x.shape[0]):
   |
help: Insert single blank line

D103 Missing docstring in public function
   --> umap/distances.py:205:5
    |
204 | @numba.njit()
205 | def hyperboloid_grad(x, y):
    |     ^^^^^^^^^^^^^^^^
206 |     s = np.sqrt(1 + np.sum(x**2))
207 |     t = np.sqrt(1 + np.sum(y**2))
    |

N806 Variable `B` in function should be lowercase
   --> umap/distances.py:209:5
    |
207 |     t = np.sqrt(1 + np.sum(y**2))
208 |
209 |     B = s * t
    |     ^
210 |     for i in range(x.shape[0]):
211 |         B -= x[i] * y[i]
    |

N806 Variable `B` in function should be lowercase
   --> umap/distances.py:211:9
    |
209 |     B = s * t
210 |     for i in range(x.shape[0]):
211 |         B -= x[i] * y[i]
    |         ^
212 |
213 |     if B <= 1:
    |

N806 Variable `B` in function should be lowercase
   --> umap/distances.py:214:9
    |
213 |     if B <= 1:
214 |         B = 1.0 + 1e-8
    |         ^
215 |
216 |     grad_coeff = 1.0 / (np.sqrt(B - 1) * np.sqrt(B + 1))
    |

ERA001 Found commented-out code
   --> umap/distances.py:218:5
    |
216 |     grad_coeff = 1.0 / (np.sqrt(B - 1) * np.sqrt(B + 1))
217 |
218 |     # return np.arccosh(B), np.zeros(x.shape[0])
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
219 |
220 |     grad = np.zeros(x.shape[0])
    |
help: Remove commented-out code

D401 First line of docstring should be in imperative mood: "A weighted version of Minkowski distance."
   --> umap/distances.py:229:5
    |
227 |   @numba.njit()
228 |   def weighted_minkowski(x, y, w=_mock_ones, p=2):
229 | /     r"""A weighted version of Minkowski distance.
230 | |
231 | |     ..math::
232 | |         D(x, y) = \left(\sum_i w_i |x_i - y_i|^p\right)^{\frac{1}{p}}
233 | |
234 | |     If weights w_i are inverse standard deviations of data in each dimension
235 | |     then this represented a standardised Minkowski distance (and is
236 | |     equivalent to standardised Euclidean distance for p=1).
237 | |     """
    | |_______^
238 |       result = 0.0
239 |       for i in range(x.shape[0]):
    |

D401 First line of docstring should be in imperative mood: "A weighted version of Minkowski distance with gradient."
   --> umap/distances.py:247:5
    |
245 |   @numba.njit()
246 |   def weighted_minkowski_grad(x, y, w=_mock_ones, p=2):
247 | /     r"""A weighted version of Minkowski distance with gradient.
248 | |
249 | |     ..math::
250 | |         D(x, y) = \left(\sum_i w_i |x_i - y_i|^p\right)^{\frac{1}{p}}
251 | |
252 | |     If weights w_i are inverse standard deviations of data in each dimension
253 | |     then this represented a standardised Minkowski distance (and is
254 | |     equivalent to standardised Euclidean distance for p=1).
255 | |     """
    | |_______^
256 |       result = 0.0
257 |       for i in range(x.shape[0]):
    |

D103 Missing docstring in public function
   --> umap/distances.py:273:5
    |
272 | @numba.njit()
273 | def mahalanobis(x, y, vinv=_mock_identity):
    |     ^^^^^^^^^^^
274 |     result = 0.0
    |

D103 Missing docstring in public function
   --> umap/distances.py:291:5
    |
290 | @numba.njit()
291 | def mahalanobis_grad(x, y, vinv=_mock_identity):
    |     ^^^^^^^^^^^^^^^^
292 |     result = 0.0
    |

D103 Missing docstring in public function
   --> umap/distances.py:312:5
    |
311 | @numba.njit()
312 | def hamming(x, y):
    |     ^^^^^^^
313 |     result = 0.0
314 |     for i in range(x.shape[0]):
    |

D103 Missing docstring in public function
   --> umap/distances.py:322:5
    |
321 | @numba.njit()
322 | def canberra(x, y):
    |     ^^^^^^^^
323 |     result = 0.0
324 |     for i in range(x.shape[0]):
    |

D103 Missing docstring in public function
   --> umap/distances.py:333:5
    |
332 | @numba.njit()
333 | def canberra_grad(x, y):
    |     ^^^^^^^^^^^^^
334 |     result = 0.0
335 |     grad = np.zeros(x.shape)
    |

D103 Missing docstring in public function
   --> umap/distances.py:349:5
    |
348 | @numba.njit()
349 | def bray_curtis(x, y):
    |     ^^^^^^^^^^^
350 |     numerator = 0.0
351 |     denominator = 0.0
    |

D103 Missing docstring in public function
   --> umap/distances.py:362:5
    |
361 | @numba.njit()
362 | def bray_curtis_grad(x, y):
    |     ^^^^^^^^^^^^^^^^
363 |     numerator = 0.0
364 |     denominator = 0.0
    |

D103 Missing docstring in public function
   --> umap/distances.py:380:5
    |
379 | @numba.njit()
380 | def jaccard(x, y):
    |     ^^^^^^^
381 |     num_non_zero = 0.0
382 |     num_equal = 0.0
    |

D103 Missing docstring in public function
   --> umap/distances.py:395:5
    |
394 | @numba.njit()
395 | def matching(x, y):
    |     ^^^^^^^^
396 |     num_not_equal = 0.0
397 |     for i in range(x.shape[0]):
    |

D103 Missing docstring in public function
   --> umap/distances.py:406:5
    |
405 | @numba.njit()
406 | def dice(x, y):
    |     ^^^^
407 |     num_true_true = 0.0
408 |     num_not_equal = 0.0
    |

D103 Missing docstring in public function
   --> umap/distances.py:421:5
    |
420 | @numba.njit()
421 | def kulsinski(x, y):
    |     ^^^^^^^^^
422 |     num_true_true = 0.0
423 |     num_not_equal = 0.0
    |

D103 Missing docstring in public function
   --> umap/distances.py:438:5
    |
437 | @numba.njit()
438 | def rogers_tanimoto(x, y):
    |     ^^^^^^^^^^^^^^^
439 |     num_not_equal = 0.0
440 |     for i in range(x.shape[0]):
    |

D103 Missing docstring in public function
   --> umap/distances.py:449:5
    |
448 | @numba.njit()
449 | def russellrao(x, y):
    |     ^^^^^^^^^^
450 |     num_true_true = 0.0
451 |     for i in range(x.shape[0]):
    |

D103 Missing docstring in public function
   --> umap/distances.py:462:5
    |
461 | @numba.njit()
462 | def sokal_michener(x, y):
    |     ^^^^^^^^^^^^^^
463 |     num_not_equal = 0.0
464 |     for i in range(x.shape[0]):
    |

D103 Missing docstring in public function
   --> umap/distances.py:473:5
    |
472 | @numba.njit()
473 | def sokal_sneath(x, y):
    |     ^^^^^^^^^^^^
474 |     num_true_true = 0.0
475 |     num_not_equal = 0.0
    |

D103 Missing docstring in public function
   --> umap/distances.py:488:5
    |
487 | @numba.njit()
488 | def haversine(x, y):
    |     ^^^^^^^^^
489 |     if x.shape[0] != 2:
490 |         msg = "haversine is only defined for 2 dimensional data"
    |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> umap/distances.py:489:22
    |
487 | @numba.njit()
488 | def haversine(x, y):
489 |     if x.shape[0] != 2:
    |                      ^
490 |         msg = "haversine is only defined for 2 dimensional data"
491 |         raise ValueError(msg)
    |

D103 Missing docstring in public function
   --> umap/distances.py:499:5
    |
498 | @numba.njit()
499 | def haversine_grad(x, y):
    |     ^^^^^^^^^^^^^^
500 |     # spectral initialization puts many points near the poles
501 |     # currently, adding pi/2 to the latitude avoids problems
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> umap/distances.py:502:7
    |
500 |     # spectral initialization puts many points near the poles
501 |     # currently, adding pi/2 to the latitude avoids problems
502 |     # TODO: reimplement with quaternions to avoid singularity
    |       ^^^^
503 |
504 |     if x.shape[0] != 2:
    |

TD003 Missing issue link for this TODO
   --> umap/distances.py:502:7
    |
500 |     # spectral initialization puts many points near the poles
501 |     # currently, adding pi/2 to the latitude avoids problems
502 |     # TODO: reimplement with quaternions to avoid singularity
    |       ^^^^
503 |
504 |     if x.shape[0] != 2:
    |

FIX002 Line contains TODO, consider resolving the issue
   --> umap/distances.py:502:7
    |
500 |     # spectral initialization puts many points near the poles
501 |     # currently, adding pi/2 to the latitude avoids problems
502 |     # TODO: reimplement with quaternions to avoid singularity
    |       ^^^^
503 |
504 |     if x.shape[0] != 2:
    |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> umap/distances.py:504:22
    |
502 |     # TODO: reimplement with quaternions to avoid singularity
503 |
504 |     if x.shape[0] != 2:
    |                      ^
505 |         msg = "haversine is only defined for 2 dimensional data"
506 |         raise ValueError(msg)
    |

D103 Missing docstring in public function
   --> umap/distances.py:530:5
    |
529 | @numba.njit()
530 | def yule(x, y):
    |     ^^^^
531 |     num_true_true = 0.0
532 |     num_true_false = 0.0
    |

D103 Missing docstring in public function
   --> umap/distances.py:551:5
    |
550 | @numba.njit()
551 | def cosine(x, y):
    |     ^^^^^^
552 |     result = 0.0
553 |     norm_x = 0.0
    |

D103 Missing docstring in public function
   --> umap/distances.py:568:5
    |
567 | @numba.njit(fastmath=True)
568 | def cosine_grad(x, y):
    |     ^^^^^^^^^^^
569 |     result = 0.0
570 |     norm_x = 0.0
    |

D103 Missing docstring in public function
   --> umap/distances.py:591:5
    |
590 | @numba.njit()
591 | def correlation(x, y):
    |     ^^^^^^^^^^^
592 |     mu_x = 0.0
593 |     mu_y = 0.0
    |

D103 Missing docstring in public function
   --> umap/distances.py:620:5
    |
619 | @numba.njit()
620 | def hellinger(x, y):
    |     ^^^^^^^^^
621 |     result = 0.0
622 |     l1_norm_x = 0.0
    |

D103 Missing docstring in public function
   --> umap/distances.py:638:5
    |
637 | @numba.njit()
638 | def hellinger_grad(x, y):
    |     ^^^^^^^^^^^^^^
639 |     result = 0.0
640 |     l1_norm_x = 0.0
    |

N802 Function name `approx_log_Gamma` should be lowercase
   --> umap/distances.py:669:5
    |
668 | @numba.njit()
669 | def approx_log_Gamma(x):
    |     ^^^^^^^^^^^^^^^^
670 |     if x == 1:
671 |         return 0
    |

D103 Missing docstring in public function
   --> umap/distances.py:669:5
    |
668 | @numba.njit()
669 | def approx_log_Gamma(x):
    |     ^^^^^^^^^^^^^^^^
670 |     if x == 1:
671 |         return 0
    |

ERA001 Found commented-out code
   --> umap/distances.py:672:5
    |
670 |     if x == 1:
671 |         return 0
672 |     # x2= 1/(x*x);
    |     ^^^^^^^^^^^^^^
673 |     return x * np.log(x) - x + 0.5 * np.log(2.0 * np.pi / x) + 1.0 / (x * 12.0)
674 |     # + x2*(-1.0/360.0) + x2* (1.0/1260.0 + x2*(-1.0/(1680.0)  +\
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> umap/distances.py:674:5
    |
672 |     # x2= 1/(x*x);
673 |     return x * np.log(x) - x + 0.5 * np.log(2.0 * np.pi / x) + 1.0 / (x * 12.0)
674 |     # + x2*(-1.0/360.0) + x2* (1.0/1260.0 + x2*(-1.0/(1680.0)  +\
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
675 |     #  x2*(1.0/1188.0 + x2*(-691.0/360360.0 + x2*(1.0/156.0 +\
676 |     #  x2*(-3617.0/122400.0 + x2*(43687.0/244188.0 + x2*(-174611.0/125400.0) +\
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> umap/distances.py:675:5
    |
673 |     return x * np.log(x) - x + 0.5 * np.log(2.0 * np.pi / x) + 1.0 / (x * 12.0)
674 |     # + x2*(-1.0/360.0) + x2* (1.0/1260.0 + x2*(-1.0/(1680.0)  +\
675 |     #  x2*(1.0/1188.0 + x2*(-691.0/360360.0 + x2*(1.0/156.0 +\
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
676 |     #  x2*(-3617.0/122400.0 + x2*(43687.0/244188.0 + x2*(-174611.0/125400.0) +\
677 |     #  x2*(77683.0/5796.0 + x2*(-236364091.0/1506960.0 + x2*(657931.0/300.0))))))))))))
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> umap/distances.py:676:5
    |
674 |     # + x2*(-1.0/360.0) + x2* (1.0/1260.0 + x2*(-1.0/(1680.0)  +\
675 |     #  x2*(1.0/1188.0 + x2*(-691.0/360360.0 + x2*(1.0/156.0 +\
676 |     #  x2*(-3617.0/122400.0 + x2*(43687.0/244188.0 + x2*(-174611.0/125400.0) +\
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
677 |     #  x2*(77683.0/5796.0 + x2*(-236364091.0/1506960.0 + x2*(657931.0/300.0))))))))))))
    |
help: Remove commented-out code

D103 Missing docstring in public function
   --> umap/distances.py:681:5
    |
680 | @numba.njit()
681 | def log_beta(x, y):
    |     ^^^^^^^^
682 |     a = min(x, y)
683 |     b = max(x, y)
    |

PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   --> umap/distances.py:684:12
    |
682 |     a = min(x, y)
683 |     b = max(x, y)
684 |     if b < 5:
    |            ^
685 |         value = -np.log(b)
686 |         for i in range(1, int(a)):
    |

D103 Missing docstring in public function
   --> umap/distances.py:693:5
    |
692 | @numba.njit()
693 | def log_single_beta(x):
    |     ^^^^^^^^^^^^^^^
694 |     return np.log(2.0) * (-2.0 * x + 0.5) + 0.5 * np.log(2.0 * np.pi / x) + 0.125 / x
    |

ERA001 Found commented-out code
   --> umap/distances.py:697:1
    |
697 | # + x2*(-1.0/192.0 + x2* (1.0/640.0 + x2*(-17.0/(14336.0) +\
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
698 | #  x2*(31.0/18432.0 + x2*(-691.0/180224.0 +\
699 | #  x2*(5461.0/425984.0 + x2*(-929569.0/15728640.0 +\
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> umap/distances.py:698:1
    |
697 | # + x2*(-1.0/192.0 + x2* (1.0/640.0 + x2*(-17.0/(14336.0) +\
698 | #  x2*(31.0/18432.0 + x2*(-691.0/180224.0 +\
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
699 | #  x2*(5461.0/425984.0 + x2*(-929569.0/15728640.0 +\
700 | #  x2*(3189151.0/8912896.0 + x2*(-221930581.0/79691776.0) +\
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> umap/distances.py:699:1
    |
697 | # + x2*(-1.0/192.0 + x2* (1.0/640.0 + x2*(-17.0/(14336.0) +\
698 | #  x2*(31.0/18432.0 + x2*(-691.0/180224.0 +\
699 | #  x2*(5461.0/425984.0 + x2*(-929569.0/15728640.0 +\
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
700 | #  x2*(3189151.0/8912896.0 + x2*(-221930581.0/79691776.0) +\
701 | #  x2*(4722116521.0/176160768.0 + x2*(-968383680827.0/3087007744.0 +\
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> umap/distances.py:700:1
    |
698 | #  x2*(31.0/18432.0 + x2*(-691.0/180224.0 +\
699 | #  x2*(5461.0/425984.0 + x2*(-929569.0/15728640.0 +\
700 | #  x2*(3189151.0/8912896.0 + x2*(-221930581.0/79691776.0) +\
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
701 | #  x2*(4722116521.0/176160768.0 + x2*(-968383680827.0/3087007744.0 +\
702 | #  x2*(14717667114151.0/3355443200.0 ))))))))))))
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> umap/distances.py:701:1
    |
699 | #  x2*(5461.0/425984.0 + x2*(-929569.0/15728640.0 +\
700 | #  x2*(3189151.0/8912896.0 + x2*(-221930581.0/79691776.0) +\
701 | #  x2*(4722116521.0/176160768.0 + x2*(-968383680827.0/3087007744.0 +\
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
702 | #  x2*(14717667114151.0/3355443200.0 ))))))))))))
    |
help: Remove commented-out code

D205 1 blank line required between summary line and description
   --> umap/distances.py:707:5
    |
705 |   @numba.njit()
706 |   def ll_dirichlet(data1, data2):
707 | /     """The symmetric relative log likelihood of rolling data2 vs data1
708 | |     in n trials on a die that rolled data1 in sum(data1) trials.
709 | |
710 | |     ..math::
711 | |         D(data1, data2) = DirichletMultinomail(data2 | data1)
712 | |     """
    | |_______^
713 |       n1 = np.sum(data1)
714 |       n2 = np.sum(data2)
    |
help: Insert single blank line

D401 First line of docstring should be in imperative mood: "The symmetric relative log likelihood of rolling data2 vs data1"
   --> umap/distances.py:707:5
    |
705 |   @numba.njit()
706 |   def ll_dirichlet(data1, data2):
707 | /     """The symmetric relative log likelihood of rolling data2 vs data1
708 | |     in n trials on a die that rolled data1 in sum(data1) trials.
709 | |
710 | |     ..math::
711 | |         D(data1, data2) = DirichletMultinomail(data2 | data1)
712 | |     """
    | |_______^
713 |       n1 = np.sum(data1)
714 |       n2 = np.sum(data2)
    |

PLR2004 Magic value used in comparison, consider replacing `0.9` with a constant variable
   --> umap/distances.py:721:34
    |
720 |     for i in range(data1.shape[0]):
721 |         if data1[i] * data2[i] > 0.9:
    |                                  ^^^
722 |             log_b += log_beta(data1[i], data2[i])
723 |             self_denom1 += log_single_beta(data1[i])
    |

PLR2004 Magic value used in comparison, consider replacing `0.9` with a constant variable
   --> umap/distances.py:727:27
    |
726 |         else:
727 |             if data1[i] > 0.9:
    |                           ^^^
728 |                 self_denom1 += log_single_beta(data1[i])
    |

PLR2004 Magic value used in comparison, consider replacing `0.9` with a constant variable
   --> umap/distances.py:730:27
    |
728 |                 self_denom1 += log_single_beta(data1[i])
729 |
730 |             if data2[i] > 0.9:
    |                           ^^^
731 |                 self_denom2 += log_single_beta(data2[i])
    |

D103 Missing docstring in public function
   --> umap/distances.py:799:5
    |
798 | @numba.njit()
799 | def correlation_grad(x, y):
    |     ^^^^^^^^^^^^^^^^
800 |     mu_x = 0.0
801 |     mu_y = 0.0
    |

D103 Missing docstring in public function
   --> umap/distances.py:834:5
    |
833 | @numba.njit(fastmath=True)
834 | def sinkhorn_distance(
    |     ^^^^^^^^^^^^^^^^^
835 |     x, y, M=_mock_identity, cost=_mock_cost, maxiter=64,
836 | ):  # pragma: no cover
    |

N803 Argument name `M` should be lowercase
   --> umap/distances.py:835:11
    |
833 | @numba.njit(fastmath=True)
834 | def sinkhorn_distance(
835 |     x, y, M=_mock_identity, cost=_mock_cost, maxiter=64,
    |           ^^^^^^^^^^^^^^^^
836 | ):  # pragma: no cover
837 |     p = (x / x.sum()).astype(np.float32)
    |

D103 Missing docstring in public function
   --> umap/distances.py:860:5
    |
859 | @numba.njit(fastmath=True)
860 | def spherical_gaussian_energy_grad(x, y):  # pragma: no cover
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
861 |     mu_1 = x[0] - y[0]
862 |     mu_2 = x[1] - y[1]
    |

D103 Missing docstring in public function
   --> umap/distances.py:878:5
    |
877 | @numba.njit(fastmath=True)
878 | def diagonal_gaussian_energy_grad(x, y):  # pragma: no cover
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
879 |     mu_1 = x[0] - y[0]
880 |     mu_2 = x[1] - y[1]
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> umap/distances.py:891:11
    |
890 |     if det == 0.0:
891 |         # TODO: figure out the right thing to do here
    |           ^^^^
892 |         return mu_1**2 + mu_2**2, np.array([0.0, 0.0, 1.0, 1.0], dtype=np.float32)
    |

TD003 Missing issue link for this TODO
   --> umap/distances.py:891:11
    |
890 |     if det == 0.0:
891 |         # TODO: figure out the right thing to do here
    |           ^^^^
892 |         return mu_1**2 + mu_2**2, np.array([0.0, 0.0, 1.0, 1.0], dtype=np.float32)
    |

FIX002 Line contains TODO, consider resolving the issue
   --> umap/distances.py:891:11
    |
890 |     if det == 0.0:
891 |         # TODO: figure out the right thing to do here
    |           ^^^^
892 |         return mu_1**2 + mu_2**2, np.array([0.0, 0.0, 1.0, 1.0], dtype=np.float32)
    |

D103 Missing docstring in public function
   --> umap/distances.py:913:5
    |
912 | @numba.njit(fastmath=True)
913 | def gaussian_energy_grad(x, y):  # pragma: no cover
    |     ^^^^^^^^^^^^^^^^^^^^
914 |     mu_1 = x[0] - y[0]
915 |     mu_2 = x[1] - y[1]
    |

PLR2004 Magic value used in comparison, consider replacing `1e-32` with a constant variable
   --> umap/distances.py:945:20
    |
943 |     )
944 |
945 |     if det_sigma < 1e-32:
    |                    ^^^^^
946 |         return (
947 |             mu_1**2 + mu_2**2,
    |

D103 Missing docstring in public function
   --> umap/distances.py:986:5
    |
985 | @numba.njit(fastmath=True)
986 | def spherical_gaussian_grad(x, y):  # pragma: no cover
    |     ^^^^^^^^^^^^^^^^^^^^^^^
987 |     mu_1 = x[0] - y[0]
988 |     mu_2 = x[1] - y[1]
    |

D103 Missing docstring in public function
    --> umap/distances.py:1013:5
     |
1013 | def get_discrete_params(data, metric):
     |     ^^^^^^^^^^^^^^^^^^^
1014 |     if metric == "ordinal":
1015 |         return {"support_size": float(data.max() - data.min()) / 2.0}
     |

D103 Missing docstring in public function
    --> umap/distances.py:1036:5
     |
1035 | @numba.njit()
1036 | def categorical_distance(x, y):
     |     ^^^^^^^^^^^^^^^^^^^^
1037 |     if x == y:
1038 |         return 0.0
     |

D103 Missing docstring in public function
    --> umap/distances.py:1043:5
     |
1042 | @numba.njit()
1043 | def hierarchical_categorical_distance(x, y, cat_hierarchy=None):
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1044 |     if cat_hierarchy is None:
1045 |         cat_hierarchy = [{}]
     |

D103 Missing docstring in public function
    --> umap/distances.py:1054:5
     |
1053 | @numba.njit()
1054 | def ordinal_distance(x, y, support_size=1.0):
     |     ^^^^^^^^^^^^^^^^
1055 |     return abs(x - y) / support_size
     |

D103 Missing docstring in public function
    --> umap/distances.py:1059:5
     |
1058 | @numba.njit()
1059 | def count_distance(x, y, poisson_lambda=1.0, normalisation=1.0):
     |     ^^^^^^^^^^^^^^
1060 |     lo = int(min(x, y))
1061 |     hi = int(max(x, y))
     |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    --> umap/distances.py:1065:13
     |
1063 |     log_lambda = np.log(poisson_lambda)
1064 |
1065 |     if lo < 2:
     |             ^
1066 |         log_k_factorial = 0.0
1067 |     elif lo < 10:
     |

PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    --> umap/distances.py:1067:15
     |
1065 |     if lo < 2:
1066 |         log_k_factorial = 0.0
1067 |     elif lo < 10:
     |               ^^
1068 |         log_k_factorial = 0.0
1069 |         for k in range(2, lo):
     |

D103 Missing docstring in public function
    --> umap/distances.py:1084:5
     |
1083 | @numba.njit()
1084 | def levenshtein(x, y, normalisation=1.0, max_distance=20):
     |     ^^^^^^^^^^^
1085 |     x_len, y_len = len(x), len(y)
     |

D103 Missing docstring in public function
    --> umap/distances.py:1215:5
     |
1214 | @numba.njit(parallel=True)
1215 | def parallel_special_metric(X, Y=None, metric=hellinger):
     |     ^^^^^^^^^^^^^^^^^^^^^^^
1216 |     if Y is None:
1217 |         result = np.zeros((X.shape[0], X.shape[0]))
     |

N803 Argument name `X` should be lowercase
    --> umap/distances.py:1215:29
     |
1214 | @numba.njit(parallel=True)
1215 | def parallel_special_metric(X, Y=None, metric=hellinger):
     |                             ^
1216 |     if Y is None:
1217 |         result = np.zeros((X.shape[0], X.shape[0]))
     |

N803 Argument name `Y` should be lowercase
    --> umap/distances.py:1215:32
     |
1214 | @numba.njit(parallel=True)
1215 | def parallel_special_metric(X, Y=None, metric=hellinger):
     |                                ^^^^^^
1216 |     if Y is None:
1217 |         result = np.zeros((X.shape[0], X.shape[0]))
     |

D103 Missing docstring in public function
    --> umap/distances.py:1236:5
     |
1234 | # this keeps data vectors in cache better
1235 | @numba.njit(parallel=True, nogil=True)
1236 | def chunked_parallel_special_metric(X, Y=None, metric=hellinger, chunk_size=16):
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1237 |     if Y is None:
1238 |         XX, symmetrical = X, True
     |

N803 Argument name `X` should be lowercase
    --> umap/distances.py:1236:37
     |
1234 | # this keeps data vectors in cache better
1235 | @numba.njit(parallel=True, nogil=True)
1236 | def chunked_parallel_special_metric(X, Y=None, metric=hellinger, chunk_size=16):
     |                                     ^
1237 |     if Y is None:
1238 |         XX, symmetrical = X, True
     |

N803 Argument name `Y` should be lowercase
    --> umap/distances.py:1236:40
     |
1234 | # this keeps data vectors in cache better
1235 | @numba.njit(parallel=True, nogil=True)
1236 | def chunked_parallel_special_metric(X, Y=None, metric=hellinger, chunk_size=16):
     |                                        ^^^^^^
1237 |     if Y is None:
1238 |         XX, symmetrical = X, True
     |

N806 Variable `XX` in function should be lowercase
    --> umap/distances.py:1238:9
     |
1236 | def chunked_parallel_special_metric(X, Y=None, metric=hellinger, chunk_size=16):
1237 |     if Y is None:
1238 |         XX, symmetrical = X, True
     |         ^^
1239 |         row_size = col_size = X.shape[0]
1240 |     else:
     |

N806 Variable `XX` in function should be lowercase
    --> umap/distances.py:1241:9
     |
1239 |         row_size = col_size = X.shape[0]
1240 |     else:
1241 |         XX, symmetrical = Y, False
     |         ^^
1242 |         row_size, col_size = X.shape[0], Y.shape[0]
     |

D103 Missing docstring in public function
    --> umap/distances.py:1258:5
     |
1258 | def pairwise_special_metric(
     |     ^^^^^^^^^^^^^^^^^^^^^^^
1259 |     X, Y=None, metric="hellinger", kwds=None, ensure_all_finite=True,
1260 | ):
     |

N803 Argument name `X` should be lowercase
    --> umap/distances.py:1259:5
     |
1258 | def pairwise_special_metric(
1259 |     X, Y=None, metric="hellinger", kwds=None, ensure_all_finite=True,
     |     ^
1260 | ):
1261 |     if callable(metric):
     |

N803 Argument name `Y` should be lowercase
    --> umap/distances.py:1259:8
     |
1258 | def pairwise_special_metric(
1259 |     X, Y=None, metric="hellinger", kwds=None, ensure_all_finite=True,
     |        ^^^^^^
1260 | ):
1261 |     if callable(metric):
     |

FBT002 Boolean default positional argument in function definition
    --> umap/distances.py:1259:47
     |
1258 | def pairwise_special_metric(
1259 |     X, Y=None, metric="hellinger", kwds=None, ensure_all_finite=True,
     |                                               ^^^^^^^^^^^^^^^^^
1260 | ):
1261 |     if callable(metric):
     |

N803 Argument name `_X` should be lowercase
    --> umap/distances.py:1265:29
     |
1264 |         @numba.njit(fastmath=True)
1265 |         def _partial_metric(_X, _Y=None):
     |                             ^^
1266 |             return metric(_X, _Y, *kwd_vals)
     |

N803 Argument name `_Y` should be lowercase
    --> umap/distances.py:1265:33
     |
1264 |         @numba.njit(fastmath=True)
1265 |         def _partial_metric(_X, _Y=None):
     |                                 ^^^^^^^
1266 |             return metric(_X, _Y, *kwd_vals)
     |

D205 1 blank line required between summary line and description
  --> umap/layouts.py:11:5
   |
 9 |   @numba.njit()
10 |   def clip(val):
11 | /     """Standard clamping of a value into a fixed range (in this case -4.0 to
12 | |     4.0).
13 | |
14 | |     Parameters
15 | |     ----------
16 | |     val: float
17 | |         The value to be clamped.
18 | |
19 | |     Returns
20 | |     -------
21 | |     The clamped value, now fixed to be in the range -4.0 to 4.0.
22 | |
23 | |     """
   | |_______^
24 |       if val > 4.0:
25 |           return 4.0
   |
help: Insert single blank line

D401 First line of docstring should be in imperative mood: "Standard clamping of a value into a fixed range (in this case -4.0 to"
  --> umap/layouts.py:11:5
   |
 9 |   @numba.njit()
10 |   def clip(val):
11 | /     """Standard clamping of a value into a fixed range (in this case -4.0 to
12 | |     4.0).
13 | |
14 | |     Parameters
15 | |     ----------
16 | |     val: float
17 | |         The value to be clamped.
18 | |
19 | |     Returns
20 | |     -------
21 | |     The clamped value, now fixed to be in the range -4.0 to 4.0.
22 | |
23 | |     """
   | |_______^
24 |       if val > 4.0:
25 |           return 4.0
   |

PLR2004 Magic value used in comparison, consider replacing `4.0` with a constant variable
  --> umap/layouts.py:24:14
   |
23 |     """
24 |     if val > 4.0:
   |              ^^^
25 |         return 4.0
26 |     if val < -4.0:
   |

PLR2004 Magic value used in comparison, consider replacing `-4.0` with a constant variable
  --> umap/layouts.py:26:14
   |
24 |     if val > 4.0:
25 |         return 4.0
26 |     if val < -4.0:
   |              ^^^^
27 |         return -4.0
28 |     return val
   |

D417 Missing argument descriptions in the docstring for `rdist`: `x`, `y`
  --> umap/layouts.py:42:5
   |
40 |     },
41 | )
42 | def rdist(x, y):
   |     ^^^^^
43 |     """Reduced Euclidean distance.
   |

C901 `_optimize_layout_euclidean_single_epoch` is too complex (13 > 10)
  --> umap/layouts.py:64:5
   |
64 | def _optimize_layout_euclidean_single_epoch(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
65 |     head_embedding,
66 |     tail_embedding,
   |

PLR0913 Too many arguments in function definition (27 > 5)
  --> umap/layouts.py:64:5
   |
64 | def _optimize_layout_euclidean_single_epoch(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
65 |     head_embedding,
66 |     tail_embedding,
   |

PLR0912 Too many branches (15 > 12)
  --> umap/layouts.py:64:5
   |
64 | def _optimize_layout_euclidean_single_epoch(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
65 |     head_embedding,
66 |     tail_embedding,
   |

N803 Argument name `dens_R` should be lowercase
  --> umap/layouts.py:89:5
   |
87 |     dens_re_mean,
88 |     dens_lambda,
89 |     dens_R,
   |     ^^^^^^
90 |     dens_mu,
91 |     dens_mu_tot,
   |

TD001 Invalid TODO tag: `FIXME`
   --> umap/layouts.py:147:23
    |
146 |                 if densmap_flag:
147 |                     # FIXME: grad_cor_coeff might be referenced before assignment
    |                       ^^^^^
148 |
149 |                     grad_d += clip(2 * grad_cor_coeff * (current[d] - other[d]))
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> umap/layouts.py:147:23
    |
146 |                 if densmap_flag:
147 |                     # FIXME: grad_cor_coeff might be referenced before assignment
    |                       ^^^^^
148 |
149 |                     grad_d += clip(2 * grad_cor_coeff * (current[d] - other[d]))
    |

TD003 Missing issue link for this TODO
   --> umap/layouts.py:147:23
    |
146 |                 if densmap_flag:
147 |                     # FIXME: grad_cor_coeff might be referenced before assignment
    |                       ^^^^^
148 |
149 |                     grad_d += clip(2 * grad_cor_coeff * (current[d] - other[d]))
    |

FIX001 Line contains FIXME, consider resolving the issue
   --> umap/layouts.py:147:23
    |
146 |                 if densmap_flag:
147 |                     # FIXME: grad_cor_coeff might be referenced before assignment
    |                       ^^^^^
148 |
149 |                     grad_d += clip(2 * grad_cor_coeff * (current[d] - other[d]))
    |

PLR0913 Too many arguments in function definition (8 > 5)
   --> umap/layouts.py:190:5
    |
190 | def _optimize_layout_euclidean_densmap_epoch_init(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
191 |     head_embedding,
192 |     tail_embedding,
    |

FBT001 Boolean-typed positional argument in function definition
   --> umap/layouts.py:232:52
    |
232 | def _get_optimize_layout_euclidean_single_epoch_fn(parallel: bool = False):
    |                                                    ^^^^^^^^
233 |     if parallel:
234 |         return _nb_optimize_layout_euclidean_single_epoch_parallel
    |

FBT002 Boolean default positional argument in function definition
   --> umap/layouts.py:232:52
    |
232 | def _get_optimize_layout_euclidean_single_epoch_fn(parallel: bool = False):
    |                                                    ^^^^^^^^
233 |     if parallel:
234 |         return _nb_optimize_layout_euclidean_single_epoch_parallel
    |

C901 `optimize_layout_euclidean` is too complex (11 > 10)
   --> umap/layouts.py:238:5
    |
238 | def optimize_layout_euclidean(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
239 |     head_embedding,
240 |     tail_embedding,
    |

PLR0913 Too many arguments in function definition (19 > 5)
   --> umap/layouts.py:238:5
    |
238 | def optimize_layout_euclidean(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
239 |     head_embedding,
240 |     tail_embedding,
    |

PLR0915 Too many statements (53 > 50)
   --> umap/layouts.py:238:5
    |
238 | def optimize_layout_euclidean(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
239 |     head_embedding,
240 |     tail_embedding,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/layouts.py:252:5
    |
250 |     initial_alpha=1.0,
251 |     negative_sample_rate=5.0,
252 |     parallel=False,
    |     ^^^^^^^^
253 |     verbose=False,
254 |     densmap=False,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/layouts.py:253:5
    |
251 |     negative_sample_rate=5.0,
252 |     parallel=False,
253 |     verbose=False,
    |     ^^^^^^^
254 |     densmap=False,
255 |     densmap_kwds=None,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/layouts.py:254:5
    |
252 |     parallel=False,
253 |     verbose=False,
254 |     densmap=False,
    |     ^^^^^^^
255 |     densmap_kwds=None,
256 |     tqdm_kwds=None,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/layouts.py:257:5
    |
255 |     densmap_kwds=None,
256 |     tqdm_kwds=None,
257 |     move_other=False,
    |     ^^^^^^^^^^
258 | ):
259 |     """Improve an embedding using stochastic gradient descent to minimize the
    |

D205 1 blank line required between summary line and description
   --> umap/layouts.py:259:5
    |
257 |       move_other=False,
258 |   ):
259 | /     """Improve an embedding using stochastic gradient descent to minimize the
260 | |     fuzzy set cross entropy between the 1-skeletons of the high dimensional
261 | |     and low dimensional fuzzy simplicial sets. In practice this is done by
262 | |     sampling edges based on their membership strength (with the (1-p) terms
263 | |     coming from negative sampling similar to word2vec).
264 | |
265 | |     Parameters.
266 | |     ----------
267 | |     head_embedding: array of shape (n_samples, n_components)
268 | |         The initial embedding to be improved by SGD.
269 | |     tail_embedding: array of shape (source_samples, n_components)
270 | |         The reference embedding of embedded points. If not embedding new
271 | |         previously unseen points with respect to an existing embedding this
272 | |         is simply the head_embedding (again); otherwise it provides the
273 | |         existing embedding to embed with respect to.
274 | |     head: array of shape (n_1_simplices)
275 | |         The indices of the heads of 1-simplices with non-zero membership.
276 | |     tail: array of shape (n_1_simplices)
277 | |         The indices of the tails of 1-simplices with non-zero membership.
278 | |     n_epochs: int, or list of int
279 | |         The number of training epochs to use in optimization, or a list of
280 | |         epochs at which to save the embedding. In case of a list, the optimization
281 | |         will use the maximum number of epochs in the list, and will return a list
282 | |         of embedding in the order of increasing epoch, regardless of the order in
283 | |         the epoch list.
284 | |     n_vertices: int
285 | |         The number of vertices (0-simplices) in the dataset.
286 | |     epochs_per_sample: array of shape (n_1_simplices)
287 | |         A float value of the number of epochs per 1-simplex. 1-simplices with
288 | |         weaker membership strength will have more epochs between being sampled.
289 | |     a: float
290 | |         Parameter of differentiable approximation of right adjoint functor
291 | |     b: float
292 | |         Parameter of differentiable approximation of right adjoint functor
293 | |     rng_state: array of int64, shape (3,)
294 | |         The internal state of the rng
295 | |     gamma: float (optional, default 1.0)
296 | |         Weight to apply to negative samples.
297 | |     initial_alpha: float (optional, default 1.0)
298 | |         Initial learning rate for the SGD.
299 | |     negative_sample_rate: int (optional, default 5)
300 | |         Number of negative samples to use per positive sample.
301 | |     parallel: bool (optional, default False)
302 | |         Whether to run the computation using numba parallel.
303 | |         Running in parallel is non-deterministic, and is not used
304 | |         if a random seed has been set, to ensure reproducibility.
305 | |     verbose: bool (optional, default False)
306 | |         Whether to report information on the current progress of the algorithm.
307 | |     densmap: bool (optional, default False)
308 | |         Whether to use the density-augmented densMAP objective
309 | |     densmap_kwds: dict (optional, default None)
310 | |         Auxiliary data for densMAP
311 | |     tqdm_kwds: dict (optional, default None)
312 | |         Keyword arguments for tqdm progress bar.
313 | |     move_other: bool (optional, default False)
314 | |         Whether to adjust tail_embedding alongside head_embedding
315 | |
316 | |     Returns
317 | |     -------
318 | |     embedding: array of shape (n_samples, n_components)
319 | |         The optimized embedding.
320 | |
321 | |     """
    | |_______^
322 |       dim = head_embedding.shape[1]
323 |       alpha = initial_alpha
    |
help: Insert single blank line

N806 Variable `dens_R` in function should be lowercase
   --> umap/layouts.py:347:9
    |
345 |         dens_mu_tot = np.sum(densmap_kwds["mu_sum"]) / 2
346 |         dens_lambda = densmap_kwds["lambda"]
347 |         dens_R = densmap_kwds["R"]
    |         ^^^^^^
348 |         dens_mu = densmap_kwds["mu"]
349 |         dens_phi_sum = np.zeros(n_vertices, dtype=np.float32)
    |

N806 Variable `dens_R` in function should be lowercase
   --> umap/layouts.py:355:9
    |
353 |         dens_mu_tot = 0
354 |         dens_lambda = 0
355 |         dens_R = np.zeros(1, dtype=np.float32)
    |         ^^^^^^
356 |         dens_mu = np.zeros(1, dtype=np.float32)
357 |         dens_phi_sum = np.zeros(1, dtype=np.float32)
    |

TD001 Invalid TODO tag: `FIXME`
   --> umap/layouts.py:381:15
    |
380 |         if densmap_flag:
381 |             # FIXME: dens_init_fn might be referenced before assignment
    |               ^^^^^
382 |
383 |             dens_init_fn(
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> umap/layouts.py:381:15
    |
380 |         if densmap_flag:
381 |             # FIXME: dens_init_fn might be referenced before assignment
    |               ^^^^^
382 |
383 |             dens_init_fn(
    |

TD003 Missing issue link for this TODO
   --> umap/layouts.py:381:15
    |
380 |         if densmap_flag:
381 |             # FIXME: dens_init_fn might be referenced before assignment
    |               ^^^^^
382 |
383 |             dens_init_fn(
    |

FIX001 Line contains FIXME, consider resolving the issue
   --> umap/layouts.py:381:15
    |
380 |         if densmap_flag:
381 |             # FIXME: dens_init_fn might be referenced before assignment
    |               ^^^^^
382 |
383 |             dens_init_fn(
    |

TD001 Invalid TODO tag: `FIXME`
   --> umap/layouts.py:394:15
    |
392 |             )
393 |
394 |             # FIXME: dens_var_shift might be referenced before assignment
    |               ^^^^^
395 |             dens_re_std = np.sqrt(np.var(dens_re_sum) + dens_var_shift)
396 |             dens_re_mean = np.mean(dens_re_sum)
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> umap/layouts.py:394:15
    |
392 |             )
393 |
394 |             # FIXME: dens_var_shift might be referenced before assignment
    |               ^^^^^
395 |             dens_re_std = np.sqrt(np.var(dens_re_sum) + dens_var_shift)
396 |             dens_re_mean = np.mean(dens_re_sum)
    |

TD003 Missing issue link for this TODO
   --> umap/layouts.py:394:15
    |
392 |             )
393 |
394 |             # FIXME: dens_var_shift might be referenced before assignment
    |               ^^^^^
395 |             dens_re_std = np.sqrt(np.var(dens_re_sum) + dens_var_shift)
396 |             dens_re_mean = np.mean(dens_re_sum)
    |

FIX001 Line contains FIXME, consider resolving the issue
   --> umap/layouts.py:394:15
    |
392 |             )
393 |
394 |             # FIXME: dens_var_shift might be referenced before assignment
    |               ^^^^^
395 |             dens_re_std = np.sqrt(np.var(dens_re_sum) + dens_var_shift)
396 |             dens_re_mean = np.mean(dens_re_sum)
    |

PLR0913 Too many arguments in function definition (19 > 5)
   --> umap/layouts.py:448:5
    |
448 | def _optimize_layout_generic_single_epoch(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
449 |     epochs_per_sample,
450 |     epoch_of_next_sample,
    |

PLR0913 Too many arguments in function definition (18 > 5)
   --> umap/layouts.py:527:5
    |
527 | def optimize_layout_generic(
    |     ^^^^^^^^^^^^^^^^^^^^^^^
528 |     head_embedding,
529 |     tail_embedding,
    |

D417 Missing argument descriptions in the docstring for `optimize_layout_generic`: `output_metric`, `output_metric_kwds`
   --> umap/layouts.py:527:5
    |
527 | def optimize_layout_generic(
    |     ^^^^^^^^^^^^^^^^^^^^^^^
528 |     head_embedding,
529 |     tail_embedding,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/layouts.py:543:5
    |
541 |     output_metric=dist.euclidean,
542 |     output_metric_kwds=(),
543 |     verbose=False,
    |     ^^^^^^^
544 |     tqdm_kwds=None,
545 |     move_other=False,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/layouts.py:545:5
    |
543 |     verbose=False,
544 |     tqdm_kwds=None,
545 |     move_other=False,
    |     ^^^^^^^^^^
546 | ):
547 |     """Improve an embedding using stochastic gradient descent to minimize the
    |

D205 1 blank line required between summary line and description
   --> umap/layouts.py:547:5
    |
545 |       move_other=False,
546 |   ):
547 | /     """Improve an embedding using stochastic gradient descent to minimize the
548 | |     fuzzy set cross entropy between the 1-skeletons of the high dimensional
549 | |     and low dimensional fuzzy simplicial sets. In practice this is done by
550 | |     sampling edges based on their membership strength (with the (1-p) terms
551 | |     coming from negative sampling similar to word2vec).
552 | |
553 | |     Parameters
554 | |     ----------
555 | |     head_embedding: array of shape (n_samples, n_components)
556 | |         The initial embedding to be improved by SGD.
557 | |
558 | |     tail_embedding: array of shape (source_samples, n_components)
559 | |         The reference embedding of embedded points. If not embedding new
560 | |         previously unseen points with respect to an existing embedding this
561 | |         is simply the head_embedding (again); otherwise it provides the
562 | |         existing embedding to embed with respect to.
563 | |
564 | |     head: array of shape (n_1_simplices)
565 | |         The indices of the heads of 1-simplices with non-zero membership.
566 | |
567 | |     tail: array of shape (n_1_simplices)
568 | |         The indices of the tails of 1-simplices with non-zero membership.
569 | |
570 | |     n_epochs: int
571 | |         The number of training epochs to use in optimization.
572 | |
573 | |     n_vertices: int
574 | |         The number of vertices (0-simplices) in the dataset.
575 | |
576 | |     epochs_per_sample: array of shape (n_1_simplices)
577 | |         A float value of the number of epochs per 1-simplex. 1-simplices with
578 | |         weaker membership strength will have more epochs between being sampled.
579 | |
580 | |     a: float
581 | |         Parameter of differentiable approximation of right adjoint functor
582 | |
583 | |     b: float
584 | |         Parameter of differentiable approximation of right adjoint functor
585 | |
586 | |     rng_state: array of int64, shape (3,)
587 | |         The internal state of the rng
588 | |
589 | |     gamma: float (optional, default 1.0)
590 | |         Weight to apply to negative samples.
591 | |
592 | |     initial_alpha: float (optional, default 1.0)
593 | |         Initial learning rate for the SGD.
594 | |
595 | |     negative_sample_rate: int (optional, default 5)
596 | |         Number of negative samples to use per positive sample.
597 | |
598 | |     verbose: bool (optional, default False)
599 | |         Whether to report information on the current progress of the algorithm.
600 | |
601 | |     tqdm_kwds: dict (optional, default None)
602 | |         Keyword arguments for tqdm progress bar.
603 | |
604 | |     move_other: bool (optional, default False)
605 | |         Whether to adjust tail_embedding alongside head_embedding
606 | |
607 | |     Returns
608 | |     -------
609 | |     embedding: array of shape (n_samples, n_components)
610 | |         The optimized embedding.
611 | |
612 | |     """
    | |_______^
613 |       dim = head_embedding.shape[1]
614 |       alpha = initial_alpha
    |
help: Insert single blank line

PLR0913 Too many arguments in function definition (20 > 5)
   --> umap/layouts.py:662:5
    |
662 | def _optimize_layout_inverse_single_epoch(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
663 |     epochs_per_sample,
664 |     epoch_of_next_sample,
    |

ERA001 Found commented-out code
   --> umap/layouts.py:721:17
    |
719 |                 )
720 |
721 |                 # w_l = 0.0 # for negative samples, the edge does not exist
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
722 |                 w_h = np.exp(-max(dist_output - rhos[k], 1e-6) / (sigmas[k] + 1e-6))
723 |                 grad_coeff = -gamma * ((0 - w_h) / ((1 - w_h) * sigmas[k] + 1e-6))
    |
help: Remove commented-out code

PLR0913 Too many arguments in function definition (21 > 5)
   --> umap/layouts.py:734:5
    |
734 | def optimize_layout_inverse(
    |     ^^^^^^^^^^^^^^^^^^^^^^^
735 |     head_embedding,
736 |     tail_embedding,
    |

D417 Missing argument descriptions in the docstring for `optimize_layout_inverse`: `output_metric`, `output_metric_kwds`, `rhos`, `sigmas`
   --> umap/layouts.py:734:5
    |
734 | def optimize_layout_inverse(
    |     ^^^^^^^^^^^^^^^^^^^^^^^
735 |     head_embedding,
736 |     tail_embedding,
    |

ARG001 Unused function argument: `a`
   --> umap/layouts.py:745:5
    |
743 |     n_vertices,
744 |     epochs_per_sample,
745 |     a,
    |     ^
746 |     b,
747 |     rng_state,
    |

ARG001 Unused function argument: `b`
   --> umap/layouts.py:746:5
    |
744 |     epochs_per_sample,
745 |     a,
746 |     b,
    |     ^
747 |     rng_state,
748 |     gamma=1.0,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/layouts.py:753:5
    |
751 |     output_metric=dist.euclidean,
752 |     output_metric_kwds=(),
753 |     verbose=False,
    |     ^^^^^^^
754 |     tqdm_kwds=None,
755 |     move_other=False,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/layouts.py:755:5
    |
753 |     verbose=False,
754 |     tqdm_kwds=None,
755 |     move_other=False,
    |     ^^^^^^^^^^
756 | ):
757 |     """Improve an embedding using stochastic gradient descent to minimize the
    |

D205 1 blank line required between summary line and description
   --> umap/layouts.py:757:5
    |
755 |       move_other=False,
756 |   ):
757 | /     """Improve an embedding using stochastic gradient descent to minimize the
758 | |     fuzzy set cross entropy between the 1-skeletons of the high dimensional
759 | |     and low dimensional fuzzy simplicial sets. In practice this is done by
760 | |     sampling edges based on their membership strength (with the (1-p) terms
761 | |     coming from negative sampling similar to word2vec).
762 | |
763 | |     Parameters
764 | |     ----------
765 | |     head_embedding: array of shape (n_samples, n_components)
766 | |         The initial embedding to be improved by SGD.
767 | |
768 | |     tail_embedding: array of shape (source_samples, n_components)
769 | |         The reference embedding of embedded points. If not embedding new
770 | |         previously unseen points with respect to an existing embedding this
771 | |         is simply the head_embedding (again); otherwise it provides the
772 | |         existing embedding to embed with respect to.
773 | |
774 | |     head: array of shape (n_1_simplices)
775 | |         The indices of the heads of 1-simplices with non-zero membership.
776 | |
777 | |     tail: array of shape (n_1_simplices)
778 | |         The indices of the tails of 1-simplices with non-zero membership.
779 | |
780 | |     weight: array of shape (n_1_simplices)
781 | |         The membership weights of the 1-simplices.
782 | |
783 | |     sigmas:
784 | |
785 | |     rhos:
786 | |
787 | |     n_epochs: int
788 | |         The number of training epochs to use in optimization.
789 | |
790 | |     n_vertices: int
791 | |         The number of vertices (0-simplices) in the dataset.
792 | |
793 | |     epochs_per_sample: array of shape (n_1_simplices)
794 | |         A float value of the number of epochs per 1-simplex. 1-simplices with
795 | |         weaker membership strength will have more epochs between being sampled.
796 | |
797 | |     a: float
798 | |         Parameter of differentiable approximation of right adjoint functor
799 | |
800 | |     b: float
801 | |         Parameter of differentiable approximation of right adjoint functor
802 | |
803 | |     rng_state: array of int64, shape (3,)
804 | |         The internal state of the rng
805 | |
806 | |     gamma: float (optional, default 1.0)
807 | |         Weight to apply to negative samples.
808 | |
809 | |     initial_alpha: float (optional, default 1.0)
810 | |         Initial learning rate for the SGD.
811 | |
812 | |     negative_sample_rate: int (optional, default 5)
813 | |         Number of negative samples to use per positive sample.
814 | |
815 | |     verbose: bool (optional, default False)
816 | |         Whether to report information on the current progress of the algorithm.
817 | |
818 | |     tqdm_kwds: dict (optional, default None)
819 | |         Keyword arguments for tqdm progress bar.
820 | |
821 | |     move_other: bool (optional, default False)
822 | |         Whether to adjust tail_embedding alongside head_embedding
823 | |
824 | |     Returns
825 | |     -------
826 | |     embedding: array of shape (n_samples, n_components)
827 | |         The optimized embedding.
828 | |
829 | |     """
    | |_______^
830 |       dim = head_embedding.shape[1]
831 |       alpha = initial_alpha
    |
help: Insert single blank line

C901 `_optimize_layout_aligned_euclidean_single_epoch` is too complex (23 > 10)
   --> umap/layouts.py:876:5
    |
876 | def _optimize_layout_aligned_euclidean_single_epoch(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
877 |     head_embeddings,
878 |     tail_embeddings,
    |

PLR0913 Too many arguments in function definition (19 > 5)
   --> umap/layouts.py:876:5
    |
876 | def _optimize_layout_aligned_euclidean_single_epoch(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
877 |     head_embeddings,
878 |     tail_embeddings,
    |

PLR0912 Too many branches (26 > 12)
   --> umap/layouts.py:876:5
    |
876 | def _optimize_layout_aligned_euclidean_single_epoch(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
877 |     head_embeddings,
878 |     tail_embeddings,
    |

PLR0915 Too many statements (59 > 50)
   --> umap/layouts.py:876:5
    |
876 | def _optimize_layout_aligned_euclidean_single_epoch(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
877 |     head_embeddings,
878 |     tail_embeddings,
    |

NPY002 Replace legacy `np.random.seed` call with `np.random.Generator`
   --> umap/layouts.py:905:5
    |
904 |     embedding_order = np.arange(n_embeddings).astype(np.int32)
905 |     np.random.seed(abs(rng_state[0]))
    |     ^^^^^^^^^^^^^^
906 |     np.random.shuffle(embedding_order)
    |

NPY002 Replace legacy `np.random.shuffle` call with `np.random.Generator`
   --> umap/layouts.py:906:5
    |
904 |     embedding_order = np.arange(n_embeddings).astype(np.int32)
905 |     np.random.seed(abs(rng_state[0]))
906 |     np.random.shuffle(embedding_order)
    |     ^^^^^^^^^^^^^^^^^
907 |
908 |     for i in range(max_n_edges):
    |

PLR0913 Too many arguments in function definition (19 > 5)
    --> umap/layouts.py:1026:5
     |
1026 | def optimize_layout_aligned_euclidean(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1027 |     head_embeddings,
1028 |     tail_embeddings,
     |

D103 Missing docstring in public function
    --> umap/layouts.py:1026:5
     |
1026 | def optimize_layout_aligned_euclidean(
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1027 |     head_embeddings,
1028 |     tail_embeddings,
     |

FBT002 Boolean default positional argument in function definition
    --> umap/layouts.py:1042:5
     |
1040 |     initial_alpha=1.0,
1041 |     negative_sample_rate=5.0,
1042 |     parallel=True,
     |     ^^^^^^^^
1043 |     verbose=False,
1044 |     tqdm_kwds=None,
     |

FBT002 Boolean default positional argument in function definition
    --> umap/layouts.py:1043:5
     |
1041 |     negative_sample_rate=5.0,
1042 |     parallel=True,
1043 |     verbose=False,
     |     ^^^^^^^
1044 |     tqdm_kwds=None,
1045 |     move_other=False,
     |

FBT002 Boolean default positional argument in function definition
    --> umap/layouts.py:1045:5
     |
1043 |     verbose=False,
1044 |     tqdm_kwds=None,
1045 |     move_other=False,
     |     ^^^^^^^^^^
1046 | ):
1047 |     dim = head_embeddings[0].shape[1]
     |

N812 Lowercase `functional` imported as non-lowercase `F`
  --> umap/parametric_umap.py:43:12
   |
41 |     import numpy as np
42 |     import torch
43 |     import torch.nn.functional as F
   |            ^^^^^^^^^^^^^^^^^^^^^^^^
44 |     import torch.onnx
45 |     import torchvision
   |

F401 `torchvision` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> umap/parametric_umap.py:45:12
   |
43 |     import torch.nn.functional as F
44 |     import torch.onnx
45 |     import torchvision
   |            ^^^^^^^^^^^
46 |     from torch import nn
47 | except ImportError:
   |
help: Remove unused import: `torchvision`

D101 Missing docstring in public class
  --> umap/parametric_umap.py:52:7
   |
52 | class ParametricUMAP(UMAP):
   |       ^^^^^^^^^^^^^^
53 |     def __init__(
54 |         self,
   |

PLR0913 Too many arguments in function definition (13 > 5)
  --> umap/parametric_umap.py:53:9
   |
52 | class ParametricUMAP(UMAP):
53 |     def __init__(
   |         ^^^^^^^^
54 |         self,
55 |         batch_size=None,
   |

D417 Missing argument description in the docstring for `__init__`: `**kwargs`
  --> umap/parametric_umap.py:53:9
   |
52 | class ParametricUMAP(UMAP):
53 |     def __init__(
   |         ^^^^^^^^
54 |         self,
55 |         batch_size=None,
   |

FBT002 Boolean default positional argument in function definition
  --> umap/parametric_umap.py:59:9
   |
57 |         encoder=None,
58 |         decoder=None,
59 |         parametric_reconstruction=False,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
60 |         parametric_reconstruction_loss_fcn=None,
61 |         parametric_reconstruction_loss_weight=1.0,
   |

FBT002 Boolean default positional argument in function definition
  --> umap/parametric_umap.py:62:9
   |
60 |         parametric_reconstruction_loss_fcn=None,
61 |         parametric_reconstruction_loss_weight=1.0,
62 |         autoencoder_loss=False,
   |         ^^^^^^^^^^^^^^^^
63 |         reconstruction_validation=None,
64 |         global_correlation_loss_weight=0,
   |

D205 1 blank line required between summary line and description
   --> umap/parametric_umap.py:70:9
    |
 68 |           **kwargs,
 69 |       ):
 70 | /         """Parametric UMAP subclassing UMAP-learn, based on keras/tensorflow.
 71 | |         There is also a non-parametric implementation contained within to compare
 72 | |         with the base non-parametric implementation.
 73 | |
 74 | |         Parameters
 75 | |         ----------
 76 | |         batch_size : int, optional
 77 | |             size of batch used for batch training, by default None
 78 | |         dims :  tuple, optional
 79 | |             dimensionality of data, if not flat (e.g. (32x32x3 images for ConvNet), by default None
 80 | |         encoder : keras.Sequential, optional
 81 | |             The encoder Keras network
 82 | |         decoder : keras.Sequential, optional
 83 | |             the decoder Keras network
 84 | |         parametric_reconstruction : bool, optional
 85 | |             Whether the decoder is parametric or non-parametric, by default False
 86 | |         parametric_reconstruction_loss_fcn : bool, optional
 87 | |             What loss function to use for parametric reconstruction,
 88 | |             by default keras.losses.BinaryCrossentropy
 89 | |         parametric_reconstruction_loss_weight : float, optional
 90 | |             How to weight the parametric reconstruction loss relative to umap loss, by default 1.0
 91 | |         autoencoder_loss : bool, optional
 92 | |             [description], by default False
 93 | |         reconstruction_validation : array, optional
 94 | |             validation X data for reconstruction loss, by default None
 95 | |         global_correlation_loss_weight : float, optional
 96 | |             Whether to additionally train on correlation of global pairwise relationships (>0), by default 0
 97 | |         landmark_loss_fn : callable, optional
 98 | |             The function to use for landmark loss, by default the euclidean distance
 99 | |         landmark_loss_weight : float, optional
100 | |             How to weight the landmark loss relative to umap loss, by default 1.0
101 | |         keras_fit_kwargs : dict, optional
102 | |             additional arguments for model.fit (like callbacks), by default {}
103 | |
104 | |         """
    | |___________^
105 |           if keras_fit_kwargs is None:
106 |               keras_fit_kwargs = {}
    |
help: Insert single blank line

SIM102 Use a single `if` statement instead of nested `if` statements
   --> umap/parametric_umap.py:147:9
    |
145 |           self.optimizer = keras.optimizers.Adam(1e-3, clipvalue=4.0)
146 |
147 | /         if self.encoder is not None:
148 | |             if encoder.outputs[0].shape[-1] != self.n_components:
    | |_________________________________________________________________^
149 |                   msg = (
150 |                       f"Dimensionality of embedder network output ({encoder.outputs[0].shape[-1]}) does"
    |
help: Combine `if` statements using `and`

N803 Argument name `X` should be lowercase
   --> umap/parametric_umap.py:159:19
    |
157 |                 )
158 |
159 |     def fit(self, X, y=None, precomputed_distances=None, landmark_positions=None):
    |                   ^
160 |         """Fit X into an embedded space.
    |

N806 Variable `X` in function should be lowercase
   --> umap/parametric_umap.py:197:13
    |
195 |                 ),
196 |             )
197 |             X = np.concatenate((X, self.prev_epoch_X))
    |             ^
198 |
199 |         if landmark_positions is not None:
    |

N806 Variable `len_X` in function should be lowercase
   --> umap/parametric_umap.py:200:13
    |
199 |         if landmark_positions is not None:
200 |             len_X = len(X)
    |             ^^^^^
201 |             len_land = len(landmark_positions)
202 |             if len_X != len_land:
    |

N803 Argument name `X` should be lowercase
   --> umap/parametric_umap.py:230:15
    |
229 |     def fit_transform(
230 |         self, X, y=None, precomputed_distances=None, landmark_positions=None,
    |               ^
231 |     ):
232 |         """Fit X into an embedded space.
    |

N806 Variable `X` in function should be lowercase
   --> umap/parametric_umap.py:269:13
    |
267 |                 ),
268 |             )
269 |             X = np.concatenate((X, self.prev_epoch_X))
    |             ^
270 |
271 |         if landmark_positions is not None:
    |

N806 Variable `len_X` in function should be lowercase
   --> umap/parametric_umap.py:272:13
    |
271 |         if landmark_positions is not None:
272 |             len_X = len(X)
    |             ^^^^^
273 |             len_land = len(landmark_positions)
274 |             if len_X != len_land:
    |

N803 Argument name `X` should be lowercase
   --> umap/parametric_umap.py:304:25
    |
302 |         return super().fit_transform(X, y, landmark_positions=landmark_positions)
303 |
304 |     def transform(self, X, batch_size=None):
    |                         ^
305 |         """Transform X into the existing embedded space and return that
306 |         transformed output.
    |

D205 1 blank line required between summary line and description
   --> umap/parametric_umap.py:305:9
    |
304 |       def transform(self, X, batch_size=None):
305 | /         """Transform X into the existing embedded space and return that
306 | |         transformed output.
307 | |
308 | |         Parameters
309 | |         ----------
310 | |         X : array, shape (n_samples, n_features)
311 | |             New data to be transformed.
312 | |         batch_size : int, optional
313 | |             Batch size for inference, defaults to the self.batch_size used in training.
314 | |
315 | |         Returns
316 | |         -------
317 | |         X_new : array, shape (n_samples, n_components)
318 | |             Embedding of the new data in low-dimensional space.
319 | |
320 | |         """
    | |___________^
321 |           batch_size = batch_size if batch_size else self.batch_size
    |
help: Insert single blank line

N803 Argument name `X` should be lowercase
   --> umap/parametric_umap.py:327:33
    |
325 |         )
326 |
327 |     def inverse_transform(self, X):
    |                                 ^
328 |         """Transform X in the existing embedded space back into the input
329 |         data space and return that transformed output.
    |

D205 1 blank line required between summary line and description
   --> umap/parametric_umap.py:328:9
    |
327 |       def inverse_transform(self, X):
328 | /         """Transform X in the existing embedded space back into the input
329 | |         data space and return that transformed output.
330 | |
331 | |         Parameters
332 | |         ----------
333 | |         X : array, shape (n_samples, n_components)
334 | |             New points to be inverse transformed.
335 | |
336 | |         Returns
337 | |         -------
338 | |         X_new : array, shape (n_samples, n_features)
339 | |             Generated data points new data in data space.
340 | |
341 | |         """
    | |___________^
342 |           if self.parametric_reconstruction:
343 |               return self.decoder.predict(
    |
help: Insert single blank line

C901 `_fit_embed_data` is too complex (11 > 10)
   --> umap/parametric_umap.py:367:9
    |
365 |         )
366 |
367 |     def _fit_embed_data(self, X, n_epochs, init, random_state, landmark_positions=None):
    |         ^^^^^^^^^^^^^^^
368 |
369 |         if self.metric == "precomputed":
    |

N803 Argument name `X` should be lowercase
   --> umap/parametric_umap.py:367:31
    |
365 |         )
366 |
367 |     def _fit_embed_data(self, X, n_epochs, init, random_state, landmark_positions=None):
    |                               ^
368 |
369 |         if self.metric == "precomputed":
    |

ARG002 Unused method argument: `n_epochs`
   --> umap/parametric_umap.py:367:34
    |
365 |         )
366 |
367 |     def _fit_embed_data(self, X, n_epochs, init, random_state, landmark_positions=None):
    |                                  ^^^^^^^^
368 |
369 |         if self.metric == "precomputed":
    |

ARG002 Unused method argument: `init`
   --> umap/parametric_umap.py:367:44
    |
365 |         )
366 |
367 |     def _fit_embed_data(self, X, n_epochs, init, random_state, landmark_positions=None):
    |                                            ^^^^
368 |
369 |         if self.metric == "precomputed":
    |

ARG002 Unused method argument: `random_state`
   --> umap/parametric_umap.py:367:50
    |
365 |         )
366 |
367 |     def _fit_embed_data(self, X, n_epochs, init, random_state, landmark_positions=None):
    |                                                  ^^^^^^^^^^^^
368 |
369 |         if self.metric == "precomputed":
    |

N806 Variable `X` in function should be lowercase
   --> umap/parametric_umap.py:370:13
    |
369 |         if self.metric == "precomputed":
370 |             X = self._X
    |             ^
371 |
372 |         # get dimensionality of dataset
    |

N806 Variable `X` in function should be lowercase
   --> umap/parametric_umap.py:377:13
    |
375 |         # reshape data for network
376 |         elif len(self.dims) > 1:
377 |             X = np.reshape(X, [len(X), *list(self.dims)])
    |             ^
378 |
379 |         if self.parametric_reconstruction and (np.max(X) > 1.0 or np.min(X) < 0.0):
    |

C901 `save` is too complex (14 > 10)
   --> umap/parametric_umap.py:485:9
    |
483 |         }
484 |
485 |     def save(self, save_location, verbose=True, exclude_raw_data=False):
    |         ^^^^
486 |
487 |         # save encoder
    |

PLR0912 Too many branches (13 > 12)
   --> umap/parametric_umap.py:485:9
    |
483 |         }
484 |
485 |     def save(self, save_location, verbose=True, exclude_raw_data=False):
    |         ^^^^
486 |
487 |         # save encoder
    |

D102 Missing docstring in public method
   --> umap/parametric_umap.py:485:9
    |
483 |         }
484 |
485 |     def save(self, save_location, verbose=True, exclude_raw_data=False):
    |         ^^^^
486 |
487 |         # save encoder
    |

FBT002 Boolean default positional argument in function definition
   --> umap/parametric_umap.py:485:35
    |
483 |         }
484 |
485 |     def save(self, save_location, verbose=True, exclude_raw_data=False):
    |                                   ^^^^^^^
486 |
487 |         # save encoder
    |

FBT002 Boolean default positional argument in function definition
   --> umap/parametric_umap.py:485:49
    |
483 |         }
484 |
485 |     def save(self, save_location, verbose=True, exclude_raw_data=False):
    |                                                 ^^^^^^^^^^^^^^^^
486 |
487 |         # save encoder
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> umap/parametric_umap.py:489:30
    |
487 |         # save encoder
488 |         if self.encoder is not None:
489 |             encoder_output = os.path.join(save_location, "encoder.keras")
    |                              ^^^^^^^^^^^^
490 |             self.encoder.save(encoder_output)
491 |             if verbose:
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> umap/parametric_umap.py:496:30
    |
494 |         # save decoder
495 |         if self.decoder is not None:
496 |             decoder_output = os.path.join(save_location, "decoder.keras")
    |                              ^^^^^^^^^^^^
497 |             self.decoder.save(decoder_output)
498 |             if verbose:
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> umap/parametric_umap.py:503:39
    |
501 |         # save parametric_model
502 |         if self.parametric_model is not None:
503 |             parametric_model_output = os.path.join(
    |                                       ^^^^^^^^^^^^
504 |                 save_location, "parametric_model.keras",
505 |             )
    |

SLF001 Private member accessed: `_raw_data`
   --> umap/parametric_umap.py:519:35
    |
517 |             if hasattr(self, "knn_search_index") and hasattr(self.knn_search_index,
518 |                                                              "_raw_data"):
519 |                 raw_data["knn"] = self.knn_search_index._raw_data
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
520 |                 del self.knn_search_index._raw_data
    |

SLF001 Private member accessed: `_raw_data`
   --> umap/parametric_umap.py:520:21
    |
518 |                                                              "_raw_data"):
519 |                 raw_data["knn"] = self.knn_search_index._raw_data
520 |                 del self.knn_search_index._raw_data
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
521 |
522 |         # # save model.pkl (ignoring unpickleable warnings)
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> umap/parametric_umap.py:525:28
    |
523 |         with catch_warnings():
524 |             filterwarnings("ignore")
525 |             model_output = os.path.join(save_location, "model.pkl")
    |                            ^^^^^^^^^^^^
526 |             with open(model_output, "wb") as output:
527 |                 pickle.dump(self, output, pickle.HIGHEST_PROTOCOL)
    |

PTH123 `open()` should be replaced by `Path.open()`
   --> umap/parametric_umap.py:526:18
    |
524 |             filterwarnings("ignore")
525 |             model_output = os.path.join(save_location, "model.pkl")
526 |             with open(model_output, "wb") as output:
    |                  ^^^^
527 |                 pickle.dump(self, output, pickle.HIGHEST_PROTOCOL)
528 |             if verbose:
    |
help: Replace with `Path.open()`

SLF001 Private member accessed: `_raw_data`
   --> umap/parametric_umap.py:536:17
    |
534 |                 self._raw_data = raw_data["root"]
535 |             if "knn" in raw_data:
536 |                 self.knn_search_index._raw_data = raw_data["knn"]
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
537 |
538 |     def add_landmarks(
    |

D417 Missing argument description in the docstring for `add_landmarks`: `idx`
   --> umap/parametric_umap.py:538:9
    |
536 |                 self.knn_search_index._raw_data = raw_data["knn"]
537 |
538 |     def add_landmarks(
    |         ^^^^^^^^^^^^^
539 |         self,
540 |         X,
    |

N803 Argument name `X` should be lowercase
   --> umap/parametric_umap.py:540:9
    |
538 |     def add_landmarks(
539 |         self,
540 |         X,
    |         ^
541 |         sample_pct=0.01,
542 |         sample_mode="uniform",
    |

NPY002 Replace legacy `np.random.choice` call with `np.random.Generator`
   --> umap/parametric_umap.py:566:17
    |
564 |         if self.sample_mode == "uniform":
565 |             self.prev_epoch_idx = list(
566 |                 np.random.choice(
    |                 ^^^^^^^^^^^^^^^^
567 |                     range(X.shape[0]), int(X.shape[0]*sample_pct), replace=False,
568 |                 ),
    |

D102 Missing docstring in public method
   --> umap/parametric_umap.py:586:9
    |
584 |             )
585 |
586 |     def remove_landmarks(self):
    |         ^^^^^^^^^^^^^^^^
587 |         self.prev_epoch_X = None
    |

N802 Function name `to_ONNX` should be lowercase
   --> umap/parametric_umap.py:589:9
    |
587 |         self.prev_epoch_X = None
588 |
589 |     def to_ONNX(self, save_location):
    |         ^^^^^^^
590 |         """Exports trained parametric UMAP as ONNX."""
591 |         # Extract encoder
    |

D401 First line of docstring should be in imperative mood: "Exports trained parametric UMAP as ONNX."
   --> umap/parametric_umap.py:590:9
    |
589 |     def to_ONNX(self, save_location):
590 |         """Exports trained parametric UMAP as ONNX."""
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
591 |         # Extract encoder
592 |         km = self.encoder
    |

D401 First line of docstring should be in imperative mood: "Gets elements of graphs, weights, and number of epochs per edge."
   --> umap/parametric_umap.py:604:5
    |
603 |   def get_graph_elements(graph_, n_epochs):
604 | /     """Gets elements of graphs, weights, and number of epochs per edge.
605 | |
606 | |     Parameters
607 | |     ----------
608 | |     graph_ : scipy.sparse.csr.csr_matrix
609 | |         umap graph of probabilities
610 | |     n_epochs : int
611 | |         maximum number of epochs per edge
612 | |
613 | |     Returns
614 | |     -------
615 | |     graph scipy.sparse.csr.csr_matrix
616 | |         umap graph
617 | |     epochs_per_sample np.array
618 | |         number of epochs to train each sample for
619 | |     head np.array
620 | |         edge head
621 | |     tail np.array
622 | |         edge tail
623 | |     weight np.array
624 | |         edge weight
625 | |     n_vertices int
626 | |         number of vertices in graph
627 | |
628 | |     """
    | |_______^
629 |       ### should we remove redundancies () here??
630 |       # graph_ = remove_redundant_edges(graph_)
    |

ERA001 Found commented-out code
   --> umap/parametric_umap.py:630:5
    |
628 |     """
629 |     ### should we remove redundancies () here??
630 |     # graph_ = remove_redundant_edges(graph_)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
631 |
632 |     graph = graph_.tocoo()
    |
help: Remove commented-out code

PLR2004 Magic value used in comparison, consider replacing `10000` with a constant variable
   --> umap/parametric_umap.py:640:45
    |
638 |     if n_epochs is None:
639 |         # For smaller datasets we can use more epochs
640 |         n_epochs = 500 if graph.shape[0] <= 10000 else 200
    |                                             ^^^^^
641 |     # remove elements with very low probability
642 |     graph.data[graph.data < (graph.data.max() / float(n_epochs))] = 0.0
    |

D417 Missing argument descriptions in the docstring for `init_embedding_from_graph`: `graph`, `metric`, `n_components`, `random_state`
   --> umap/parametric_umap.py:654:5
    |
654 | def init_embedding_from_graph(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
655 |     _raw_data, graph, n_components, random_state, metric, _metric_kwds, init="spectral",
656 | ):
    |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> umap/parametric_umap.py:699:36
    |
697 |     else:
698 |         init_data = np.array(init)
699 |         if len(init_data.shape) == 2:
    |                                    ^
700 |             if np.unique(init_data, axis=0).shape[0] < init_data.shape[0]:
701 |                 tree = KDTree(init_data)
    |

D205 1 blank line required between summary line and description
   --> umap/parametric_umap.py:714:5
    |
713 |   def convert_distance_to_log_probability(distances, a=1.0, b=1.0):
714 | /     """Convert distance representation into log probability,
715 | |         as a function of a, b params.
716 | |
717 | |     Parameters
718 | |     ----------
719 | |     distances : array
720 | |         euclidean distance between two points in embedding
721 | |     a : float, optional
722 | |         parameter based on min_dist, by default 1.0
723 | |     b : float, optional
724 | |         parameter based on min_dist, by default 1.0
725 | |
726 | |     Returns
727 | |     -------
728 | |     float
729 | |         log probability in embedding space
730 | |
731 | |     """
    | |_______^
732 |       return -ops.log1p(a * distances ** (2 * b))
    |
help: Insert single blank line

N803 Argument name `EPS` should be lowercase
   --> umap/parametric_umap.py:736:54
    |
735 | def compute_cross_entropy(
736 |     probabilities_graph, log_probabilities_distance, EPS=1e-4, repulsion_strength=1.0,
    |                                                      ^^^^^^^^
737 | ):
738 |     """Compute cross entropy between low and high probability.
    |

ARG001 Unused function argument: `EPS`
   --> umap/parametric_umap.py:736:54
    |
735 | def compute_cross_entropy(
736 |     probabilities_graph, log_probabilities_distance, EPS=1e-4, repulsion_strength=1.0,
    |                                                      ^^^
737 | ):
738 |     """Compute cross entropy between low and high probability.
    |

N806 Variable `CE` in function should be lowercase
   --> umap/parametric_umap.py:773:5
    |
772 |     # balance the expected losses between attraction and repel
773 |     CE = attraction_term + repellant_term
    |     ^^
774 |     return attraction_term, repellant_term, CE
    |

PLR0913 Too many arguments in function definition (7 > 5)
   --> umap/parametric_umap.py:777:5
    |
777 | def prepare_networks(
    |     ^^^^^^^^^^^^^^^^
778 |     encoder,
779 |     decoder,
    |

ARG001 Unused function argument: `n_data`
   --> umap/parametric_umap.py:782:5
    |
780 |     n_components,
781 |     dims,
782 |     n_data,
    |     ^^^^^^
783 |     parametric_reconstruction,
784 |     init_embedding=None,
    |

ARG001 Unused function argument: `init_embedding`
   --> umap/parametric_umap.py:784:5
    |
782 |     n_data,
783 |     parametric_reconstruction,
784 |     init_embedding=None,
    |     ^^^^^^^^^^^^^^
785 | ):
786 |     """Generates a set of keras networks for the encoder and decoder if one has not already
    |

D205 1 blank line required between summary line and description
   --> umap/parametric_umap.py:786:5
    |
784 |       init_embedding=None,
785 |   ):
786 | /     """Generates a set of keras networks for the encoder and decoder if one has not already
787 | |     been predefined.
788 | |
789 | |     Parameters
790 | |     ----------
791 | |     encoder : keras.Sequential
792 | |         The encoder Keras network
793 | |     decoder : keras.Sequential
794 | |         the decoder Keras network
795 | |     n_components : int
796 | |         the dimensionality of the latent space
797 | |     dims : tuple of shape (dim1, dim2, dim3...)
798 | |         dimensionality of data
799 | |     n_data : number of elements in dataset
800 | |         # of elements in training dataset
801 | |     parametric_reconstruction : bool
802 | |         Whether the decoder is parametric or non-parametric
803 | |     init_embedding : array (optional, default None)
804 | |         The initial embedding, for nonparametric embeddings
805 | |
806 | |     Returns
807 | |     -------
808 | |     encoder: keras.Sequential
809 | |         encoder keras network
810 | |     decoder: keras.Sequential
811 | |         decoder keras network
812 | |
813 | |     """
    | |_______^
814 |       if encoder is None:
815 |           encoder = keras.Sequential(
    |
help: Insert single blank line

D401 First line of docstring should be in imperative mood: "Generates a set of keras networks for the encoder and decoder if one has not already"
   --> umap/parametric_umap.py:786:5
    |
784 |       init_embedding=None,
785 |   ):
786 | /     """Generates a set of keras networks for the encoder and decoder if one has not already
787 | |     been predefined.
788 | |
789 | |     Parameters
790 | |     ----------
791 | |     encoder : keras.Sequential
792 | |         The encoder Keras network
793 | |     decoder : keras.Sequential
794 | |         the decoder Keras network
795 | |     n_components : int
796 | |         the dimensionality of the latent space
797 | |     dims : tuple of shape (dim1, dim2, dim3...)
798 | |         dimensionality of data
799 | |     n_data : number of elements in dataset
800 | |         # of elements in training dataset
801 | |     parametric_reconstruction : bool
802 | |         Whether the decoder is parametric or non-parametric
803 | |     init_embedding : array (optional, default None)
804 | |         The initial embedding, for nonparametric embeddings
805 | |
806 | |     Returns
807 | |     -------
808 | |     encoder: keras.Sequential
809 | |         encoder keras network
810 | |     decoder: keras.Sequential
811 | |         decoder keras network
812 | |
813 | |     """
    | |_______^
814 |       if encoder is None:
815 |           encoder = keras.Sequential(
    |

C901 `construct_edge_dataset` is too complex (11 > 10)
   --> umap/parametric_umap.py:843:5
    |
843 | def construct_edge_dataset(
    |     ^^^^^^^^^^^^^^^^^^^^^^
844 |     X,
845 |     graph_,
    |

PLR0913 Too many arguments in function definition (7 > 5)
   --> umap/parametric_umap.py:843:5
    |
843 | def construct_edge_dataset(
    |     ^^^^^^^^^^^^^^^^^^^^^^
844 |     X,
845 |     graph_,
    |

D417 Missing argument description in the docstring for `construct_edge_dataset`: `global_correlation_loss_weight`
   --> umap/parametric_umap.py:843:5
    |
843 | def construct_edge_dataset(
    |     ^^^^^^^^^^^^^^^^^^^^^^
844 |     X,
845 |     graph_,
    |

N803 Argument name `X` should be lowercase
   --> umap/parametric_umap.py:844:5
    |
843 | def construct_edge_dataset(
844 |     X,
    |     ^
845 |     graph_,
846 |     n_epochs,
    |

PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
   --> umap/parametric_umap.py:877:50
    |
875 |     # if X is > 512Mb in size, we need to use a different, slower method for
876 |     #    batching data.
877 |     gather_indices_in_python = X.nbytes * 1e-9 > 0.5
    |                                                  ^^^
878 |     if landmark_positions is not None:
879 |         gather_landmark_indices_in_python = (
    |

PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
   --> umap/parametric_umap.py:880:48
    |
878 |     if landmark_positions is not None:
879 |         gather_landmark_indices_in_python = (
880 |             landmark_positions.nbytes * 1e-9 > 0.5
    |                                                ^^^
881 |         )
    |

N802 Function name `gather_X` should be lowercase
   --> umap/parametric_umap.py:883:9
    |
881 |         )
882 |
883 |     def gather_X(edge_to, edge_from):
    |         ^^^^^^^^
884 |         # gather data from indexes (edges) in either numpy of tf, depending on array size
885 |         if gather_indices_in_python:
    |

ARG001 Unused function argument: `edge_from`
   --> umap/parametric_umap.py:895:30
    |
893 |         return edge_to, edge_from, edge_to_batch, edge_from_batch
894 |
895 |     def get_outputs(edge_to, edge_from, edge_to_batch, edge_from_batch):
    |                              ^^^^^^^^^
896 |         outputs = {"umap": ops.repeat(0, batch_size)}
897 |         if global_correlation_loss_weight > 0:
    |

ERA001 Found commented-out code
   --> umap/parametric_umap.py:901:13
    |
899 |         if parametric_reconstruction:
900 |             # add reconstruction to iterator output
901 |             # edge_out = ops.concatenate([edge_to_batch, edge_from_batch], axis=0)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
902 |             outputs["reconstruction"] = edge_to_batch
903 |         if landmark_positions is not None:
    |
help: Remove commented-out code

NPY002 Replace legacy `np.random.permutation` call with `np.random.Generator`
   --> umap/parametric_umap.py:930:20
    |
929 |     # shuffle edges
930 |     shuffle_mask = np.random.permutation(range(len(edges_to_exp)))
    |                    ^^^^^^^^^^^^^^^^^^^^^
931 |     edges_to_exp = edges_to_exp[shuffle_mask].astype(np.int64)
932 |     edges_from_exp = edges_from_exp[shuffle_mask].astype(np.int64)
    |

D401 First line of docstring should be in imperative mood: "Checks if a dictionary item can be pickled."
   --> umap/parametric_umap.py:951:5
    |
950 |   def should_pickle(key, val):
951 | /     """Checks if a dictionary item can be pickled.
952 | |
953 | |     Parameters
954 | |     ----------
955 | |     key : try
956 | |         key for dictionary element
957 | |     val : None
958 | |         element of dictionary
959 | |
960 | |     Returns
961 | |     -------
962 | |     picklable: bool
963 | |         whether the dictionary item can be pickled
964 | |
965 | |     """
    | |_______^
966 |       try:
967 |           ## make sure object can be pickled and then re-read
    |

S301 `pickle` and modules that wrap it can be unsafe when used to deserialize untrusted data, possible security issue
   --> umap/parametric_umap.py:971:13
    |
969 |         pickled = codecs.encode(pickle.dumps(val), "base64").decode()
970 |         # unpickle object
971 |         _ = pickle.loads(codecs.decode(pickled.encode(), "base64"))
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
972 |     except (
973 |         pickle.PicklingError,
    |

N802 Function name `load_ParametricUMAP` should be lowercase
   --> umap/parametric_umap.py:990:5
    |
990 | def load_ParametricUMAP(save_location, verbose=True):
    |     ^^^^^^^^^^^^^^^^^^^
991 |     """Load a parametric UMAP model consisting of a umap-learn UMAP object
992 |     and corresponding keras models.
    |

FBT002 Boolean default positional argument in function definition
   --> umap/parametric_umap.py:990:40
    |
990 | def load_ParametricUMAP(save_location, verbose=True):
    |                                        ^^^^^^^
991 |     """Load a parametric UMAP model consisting of a umap-learn UMAP object
992 |     and corresponding keras models.
    |

D205 1 blank line required between summary line and description
    --> umap/parametric_umap.py:991:5
     |
 990 |   def load_ParametricUMAP(save_location, verbose=True):
 991 | /     """Load a parametric UMAP model consisting of a umap-learn UMAP object
 992 | |     and corresponding keras models.
 993 | |
 994 | |     Parameters
 995 | |     ----------
 996 | |     save_location : str
 997 | |         the folder that the model was saved in
 998 | |     verbose : bool, optional
 999 | |         Whether to print the loading steps, by default True
1000 | |
1001 | |     Returns
1002 | |     -------
1003 | |     parametric_umap.ParametricUMAP
1004 | |         Parametric UMAP objects
1005 | |
1006 | |     """
     | |_______^
1007 |       ## Loads a ParametricUMAP model and its related keras models
     |
help: Insert single blank line

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
    --> umap/parametric_umap.py:1009:20
     |
1007 |     ## Loads a ParametricUMAP model and its related keras models
1008 |
1009 |     model_output = os.path.join(save_location, "model.pkl")
     |                    ^^^^^^^^^^^^
1010 |     model = pickle.load(open(model_output, "rb"))
1011 |     if verbose:
     |

S301 `pickle` and modules that wrap it can be unsafe when used to deserialize untrusted data, possible security issue
    --> umap/parametric_umap.py:1010:13
     |
1009 |     model_output = os.path.join(save_location, "model.pkl")
1010 |     model = pickle.load(open(model_output, "rb"))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1011 |     if verbose:
1012 |         pass
     |

SIM115 Use a context manager for opening files
    --> umap/parametric_umap.py:1010:25
     |
1009 |     model_output = os.path.join(save_location, "model.pkl")
1010 |     model = pickle.load(open(model_output, "rb"))
     |                         ^^^^
1011 |     if verbose:
1012 |         pass
     |

PTH123 `open()` should be replaced by `Path.open()`
    --> umap/parametric_umap.py:1010:25
     |
1009 |     model_output = os.path.join(save_location, "model.pkl")
1010 |     model = pickle.load(open(model_output, "rb"))
     |                         ^^^^
1011 |     if verbose:
1012 |         pass
     |
help: Replace with `Path.open()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
    --> umap/parametric_umap.py:1015:22
     |
1014 |     # load encoder
1015 |     encoder_output = os.path.join(save_location, "encoder.keras")
     |                      ^^^^^^^^^^^^
1016 |     if os.path.exists(encoder_output):
1017 |         model.encoder = keras.models.load_model(encoder_output)
     |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
    --> umap/parametric_umap.py:1016:8
     |
1014 |     # load encoder
1015 |     encoder_output = os.path.join(save_location, "encoder.keras")
1016 |     if os.path.exists(encoder_output):
     |        ^^^^^^^^^^^^^^
1017 |         model.encoder = keras.models.load_model(encoder_output)
1018 |         if verbose:
     |
help: Replace with `Path(...).exists()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
    --> umap/parametric_umap.py:1022:22
     |
1021 |     # save decoder
1022 |     decoder_output = os.path.join(save_location, "decoder.keras")
     |                      ^^^^^^^^^^^^
1023 |     if os.path.exists(decoder_output):
1024 |         model.decoder = keras.models.load_model(decoder_output)
     |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
    --> umap/parametric_umap.py:1023:8
     |
1021 |     # save decoder
1022 |     decoder_output = os.path.join(save_location, "decoder.keras")
1023 |     if os.path.exists(decoder_output):
     |        ^^^^^^^^^^^^^^
1024 |         model.decoder = keras.models.load_model(decoder_output)
     |
help: Replace with `Path(...).exists()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
    --> umap/parametric_umap.py:1027:31
     |
1026 |     # save parametric_model
1027 |     parametric_model_output = os.path.join(save_location, "parametric_model")
     |                               ^^^^^^^^^^^^
1028 |     if os.path.exists(parametric_model_output):
1029 |         model.parametric_model = keras.models.load_model(parametric_model_output)
     |

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
    --> umap/parametric_umap.py:1028:8
     |
1026 |     # save parametric_model
1027 |     parametric_model_output = os.path.join(save_location, "parametric_model")
1028 |     if os.path.exists(parametric_model_output):
     |        ^^^^^^^^^^^^^^
1029 |         model.parametric_model = keras.models.load_model(parametric_model_output)
     |
help: Replace with `Path(...).exists()`

FBT002 Boolean default positional argument in function definition
    --> umap/parametric_umap.py:1034:27
     |
1034 | def covariance(x, y=None, keepdims=False):
     |                           ^^^^^^^^
1035 |     """Adapted from TF Probability."""
1036 |     x = ops.convert_to_tensor(x)
     |

D103 Missing docstring in public function
    --> umap/parametric_umap.py:1093:5
     |
1093 | def correlation(x, y=None, keepdims=False):
     |     ^^^^^^^^^^^
1094 |     x = x / ops.std(x, axis=0, keepdims=True)
1095 |     if y is not None:
     |

FBT002 Boolean default positional argument in function definition
    --> umap/parametric_umap.py:1093:28
     |
1093 | def correlation(x, y=None, keepdims=False):
     |                            ^^^^^^^^
1094 |     x = x / ops.std(x, axis=0, keepdims=True)
1095 |     if y is not None:
     |

D101 Missing docstring in public class
    --> umap/parametric_umap.py:1100:7
     |
1100 | class StopGradient(keras.layers.Layer):
     |       ^^^^^^^^^^^^
1101 |     def call(self, x):
1102 |         return ops.stop_gradient(x)
     |

D102 Missing docstring in public method
    --> umap/parametric_umap.py:1101:9
     |
1100 | class StopGradient(keras.layers.Layer):
1101 |     def call(self, x):
     |         ^^^^
1102 |         return ops.stop_gradient(x)
     |

D101 Missing docstring in public class
    --> umap/parametric_umap.py:1111:7
     |
1111 | class UMAPModel(keras.Model):
     |       ^^^^^^^^^
1112 |     def __init__(
1113 |         self,
     |

PLR0913 Too many arguments in function definition (14 > 5)
    --> umap/parametric_umap.py:1112:9
     |
1111 | class UMAPModel(keras.Model):
1112 |     def __init__(
     |         ^^^^^^^^
1113 |         self,
1114 |         umap_loss_a,
     |

D107 Missing docstring in `__init__`
    --> umap/parametric_umap.py:1112:9
     |
1111 | class UMAPModel(keras.Model):
1112 |     def __init__(
     |         ^^^^^^^^
1113 |         self,
1114 |         umap_loss_a,
     |

FBT002 Boolean default positional argument in function definition
    --> umap/parametric_umap.py:1121:9
     |
1119 |         optimizer=None,
1120 |         parametric_reconstruction_loss_fn=None,
1121 |         parametric_reconstruction=False,
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^
1122 |         parametric_reconstruction_loss_weight=1.0,
1123 |         global_correlation_loss_weight=0.0,
     |

FBT002 Boolean default positional argument in function definition
    --> umap/parametric_umap.py:1124:9
     |
1122 |         parametric_reconstruction_loss_weight=1.0,
1123 |         global_correlation_loss_weight=0.0,
1124 |         autoencoder_loss=False,
     |         ^^^^^^^^^^^^^^^^
1125 |         landmark_loss_fn=None,
1126 |         landmark_loss_weight=1.0,
     |

D102 Missing docstring in public method
    --> umap/parametric_umap.py:1162:9
     |
1160 |             self.landmark_loss_fn = landmark_loss_fn
1161 |
1162 |     def call(self, inputs):
     |         ^^^^
1163 |         to_x, from_x = inputs
1164 |         embedding_to = self.encoder(to_x)
     |

D102 Missing docstring in public method
    --> umap/parametric_umap.py:1181:9
     |
1179 |         return y_pred
1180 |
1181 |     def compute_loss(self, x=None, y=None, y_pred=None, sample_weight=None, **kwargs):
     |         ^^^^^^^^^^^^
1182 |         losses = []
1183 |         # Regularization losses.
     |

ARG002 Unused method argument: `x`
    --> umap/parametric_umap.py:1181:28
     |
1179 |         return y_pred
1180 |
1181 |     def compute_loss(self, x=None, y=None, y_pred=None, sample_weight=None, **kwargs):
     |                            ^
1182 |         losses = []
1183 |         # Regularization losses.
     |

ARG002 Unused method argument: `sample_weight`
    --> umap/parametric_umap.py:1181:57
     |
1179 |         return y_pred
1180 |
1181 |     def compute_loss(self, x=None, y=None, y_pred=None, sample_weight=None, **kwargs):
     |                                                         ^^^^^^^^^^^^^
1182 |         losses = []
1183 |         # Regularization losses.
     |

ARG002 Unused method argument: `kwargs`
    --> umap/parametric_umap.py:1181:79
     |
1179 |         return y_pred
1180 |
1181 |     def compute_loss(self, x=None, y=None, y_pred=None, sample_weight=None, **kwargs):
     |                                                                               ^^^^^^
1182 |         losses = []
1183 |         # Regularization losses.
     |

PERF401 Use a list comprehension to create a transformed list
    --> umap/parametric_umap.py:1185:13
     |
1183 |         # Regularization losses.
1184 |         for loss in self.losses:
1185 |             losses.append(ops.cast(loss, dtype=keras.backend.floatx()))
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1186 |
1187 |         # umap loss
     |
help: Replace for loop with list comprehension

D101 Missing docstring in public class
    --> umap/parametric_umap.py:1315:11
     |
1313 | if torch_imported:
1314 |
1315 |     class PumapNet(nn.Module):
     |           ^^^^^^^^
1316 |
1317 |         def __init__(self, indim, outdim):
     |

D107 Missing docstring in `__init__`
    --> umap/parametric_umap.py:1317:13
     |
1315 |     class PumapNet(nn.Module):
1316 |
1317 |         def __init__(self, indim, outdim):
     |             ^^^^^^^^
1318 |
1319 |             super().__init__()
     |

D102 Missing docstring in public method
    --> umap/parametric_umap.py:1337:13
     |
1335 |             """
1336 |
1337 |         def forward(self, x):
     |             ^^^^^^^
1338 |             x = self.dense1(x)
1339 |             x = F.relu(x)
     |

D401 First line of docstring should be in imperative mood: "Copies weights from a parametric UMAP encoder to pytorch."
    --> umap/parametric_umap.py:1352:9
     |
1351 |       def weight_copier(km, pm):
1352 | /         """Copies weights from a parametric UMAP encoder to pytorch.
1353 | |
1354 | |         Parameters.
1355 | |         ----------
1356 | |         km : encoder extracted from parametric UMAP.
1357 | |         pm: a PumapNet object. Will be overwritten.
1358 | |
1359 | |         Returns
1360 | |         -------
1361 | |         pm : PumapNet Object.
1362 | |             Net with copied weights.
1363 | |
1364 | |         """
     | |___________^
1365 |           kweights = km.get_weights()
1366 |           n_layers = int(len(kweights) / 2)  # The actual number of layers
     |

EXE002 The file is executable but no shebang is present
--> umap/plot.py:1:1

SLF001 Private member accessed: `_metric_kwds`
   --> umap/plot.py:170:16
    |
168 | def _get_metric_kwds(umap_object):
169 |     if hasattr(umap_object, "_metric_kwds"):
170 |         return umap_object._metric_kwds
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
171 |     # Assume no keywords exist
172 |     return {}
    |

SLF001 Private member accessed: `_small_data`
   --> umap/plot.py:183:48
    |
182 | def _nhood_search(umap_object, nhood_size):
183 |     if hasattr(umap_object, "_small_data") and umap_object._small_data:
    |                                                ^^^^^^^^^^^^^^^^^^^^^^^
184 |         dmat = sklearn.metrics.pairwise_distances(umap_object._raw_data)
185 |         indices = np.argpartition(dmat, nhood_size)[:, :nhood_size]
    |

SLF001 Private member accessed: `_raw_data`
   --> umap/plot.py:184:51
    |
182 | def _nhood_search(umap_object, nhood_size):
183 |     if hasattr(umap_object, "_small_data") and umap_object._small_data:
184 |         dmat = sklearn.metrics.pairwise_distances(umap_object._raw_data)
    |                                                   ^^^^^^^^^^^^^^^^^^^^^
185 |         indices = np.argpartition(dmat, nhood_size)[:, :nhood_size]
186 |         dmat_shortened = submatrix(dmat, indices, nhood_size)
    |

SLF001 Private member accessed: `_knn_search_index`
   --> umap/plot.py:193:26
    |
191 |         np.empty(3, dtype=np.int64)
192 |
193 |         indices, dists = umap_object._knn_search_index.query(
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
194 |             umap_object._raw_data,
195 |             k=nhood_size,
    |

SLF001 Private member accessed: `_raw_data`
   --> umap/plot.py:194:13
    |
193 |         indices, dists = umap_object._knn_search_index.query(
194 |             umap_object._raw_data,
    |             ^^^^^^^^^^^^^^^^^^^^^
195 |             k=nhood_size,
196 |         )
    |

PLR2004 Magic value used in comparison, consider replacing `126` with a constant variable
   --> umap/plot.py:240:44
    |
238 |             [int("0x" + c) for c in (background[1:3], background[3:5], background[5:7])],
239 |         )
240 |         font_color = "black" if mean_val > 126 else "white"
    |                                            ^^^
241 |
242 |     else:
    |

C901 `_datashade_points` is too complex (11 > 10)
   --> umap/plot.py:248:5
    |
248 | def _datashade_points(
    |     ^^^^^^^^^^^^^^^^^
249 |     points,
250 |     ax=None,
    |

PLR0913 Too many arguments in function definition (12 > 5)
   --> umap/plot.py:248:5
    |
248 | def _datashade_points(
    |     ^^^^^^^^^^^^^^^^^
249 |     points,
250 |     ax=None,
    |

PLR0912 Too many branches (13 > 12)
   --> umap/plot.py:248:5
    |
248 | def _datashade_points(
    |     ^^^^^^^^^^^^^^^^^
249 |     points,
250 |     ax=None,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/plot.py:259:5
    |
257 |     width=800,
258 |     height=800,
259 |     show_legend=True,
    |     ^^^^^^^^^^^
260 |     alpha=255,
261 | ):
    |

PLR2004 Magic value used in comparison, consider replacing `256` with a constant variable
   --> umap/plot.py:321:38
    |
319 |             )
320 |         unique_values = np.unique(values)
321 |         if unique_values.shape[0] >= 256:
    |                                      ^^^
322 |             min_val, max_val = np.min(values), np.max(values)
323 |             bin_size = (max_val - min_val) / 255.0
    |

PLR0913 Too many arguments in function definition (12 > 5)
   --> umap/plot.py:359:5
    |
359 | def _matplotlib_points(
    |     ^^^^^^^^^^^^^^^^^^
360 |     points,
361 |     ax=None,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/plot.py:370:5
    |
368 |     width=800,
369 |     height=800,
370 |     show_legend=True,
    |     ^^^^^^^^^^^
371 |     alpha=None,
372 | ):
    |

TRY004 Prefer `TypeError` exception for invalid type
   --> umap/plot.py:477:9
    |
475 |       else:
476 |           msg = "The type of ``plot_to_show`` was not valid, or not understood."
477 | /         raise ValueError(
478 | |             msg,
479 | |         )
    | |_________^
    |

C901 `points` is too complex (13 > 10)
   --> umap/plot.py:482:5
    |
482 | def points(
    |     ^^^^^^
483 |     umap_object,
484 |     points=None,
    |

PLR0913 Too many arguments in function definition (15 > 5)
   --> umap/plot.py:482:5
    |
482 | def points(
    |     ^^^^^^
483 |     umap_object,
484 |     points=None,
    |

PLR0912 Too many branches (14 > 12)
   --> umap/plot.py:482:5
    |
482 | def points(
    |     ^^^^^^
483 |     umap_object,
484 |     points=None,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/plot.py:494:5
    |
492 |     width=800,
493 |     height=800,
494 |     show_legend=True,
    |     ^^^^^^^^^^^
495 |     subset_points=None,
496 |     ax=None,
    |

D205 1 blank line required between summary line and description
   --> umap/plot.py:499:5
    |
497 |       alpha=None,
498 |   ):
499 | /     """Plot an embedding as points. Currently this only works
500 | |     for 2D embeddings. While there are many optional parameters
501 | |     to further control and tailor the plotting, you need only
502 | |     pass in the trained/fit umap model to get results. This plot
503 | |     utility will attempt to do the hard work of avoiding
504 | |     over-plotting issues, and make it easy to automatically
505 | |     colour points by a categorical labelling or numeric values.
506 | |
507 | |     This method is intended to be used within a Jupyter
508 | |     notebook with ``%matplotlib inline``.
509 | |
510 | |     Parameters
511 | |     ----------
512 | |     umap_object: trained UMAP object
513 | |         A trained UMAP object that has a 2D embedding.
514 | |
515 | |     points: array, shape (n_samples, dim) (optional, default None)
516 | |         An array of points to be plotted. Usually this is None
517 | |         and so the original embedding points of the umap_object
518 | |         are used. However points can be passed explicitly instead
519 | |         which is useful for points manually transformed.
520 | |
521 | |     labels: array, shape (n_samples,) (optional, default None)
522 | |         An array of labels (assumed integer or categorical),
523 | |         one for each data sample.
524 | |         This will be used for coloring the points in
525 | |         the plot according to their label. Note that
526 | |         this option is mutually exclusive to the ``values``
527 | |         option.
528 | |
529 | |     values: array, shape (n_samples,) (optional, default None)
530 | |         An array of values (assumed float or continuous),
531 | |         one for each sample.
532 | |         This will be used for coloring the points in
533 | |         the plot according to a colorscale associated
534 | |         to the total range of values. Note that this
535 | |         option is mutually exclusive to the ``labels``
536 | |         option.
537 | |
538 | |     theme: string (optional, default None)
539 | |         A color theme to use for plotting. A small set of
540 | |         predefined themes are provided which have relatively
541 | |         good aesthetics. Available themes are:
542 | |            * 'blue'
543 | |            * 'red'
544 | |            * 'green'
545 | |            * 'inferno'
546 | |            * 'fire'
547 | |            * 'viridis'
548 | |            * 'darkblue'
549 | |            * 'darkred'
550 | |            * 'darkgreen'
551 | |
552 | |     cmap: string (optional, default 'Blues')
553 | |         The name of a matplotlib colormap to use for coloring
554 | |         or shading points. If no labels or values are passed
555 | |         this will be used for shading points according to
556 | |         density (largely only of relevance for very large
557 | |         datasets). If values are passed this will be used for
558 | |         shading according the value. Note that if theme
559 | |         is passed then this value will be overridden by the
560 | |         corresponding option of the theme.
561 | |
562 | |     color_key: dict or array, shape (n_categories) (optional, default None)
563 | |         A way to assign colors to categoricals. This can either be
564 | |         an explicit dict mapping labels to colors (as strings of form
565 | |         '#RRGGBB'), or an array like object providing one color for
566 | |         each distinct category being provided in ``labels``. Either
567 | |         way this mapping will be used to color points according to
568 | |         the label. Note that if theme
569 | |         is passed then this value will be overridden by the
570 | |         corresponding option of the theme.
571 | |
572 | |     color_key_cmap: string (optional, default 'Spectral')
573 | |         The name of a matplotlib colormap to use for categorical coloring.
574 | |         If an explicit ``color_key`` is not given a color mapping for
575 | |         categories can be generated from the label list and selecting
576 | |         a matching list of colors from the given colormap. Note
577 | |         that if theme
578 | |         is passed then this value will be overridden by the
579 | |         corresponding option of the theme.
580 | |
581 | |     background: string (optional, default 'white)
582 | |         The color of the background. Usually this will be either
583 | |         'white' or 'black', but any color name will work. Ideally
584 | |         one wants to match this appropriately to the colors being
585 | |         used for points etc. This is one of the things that themes
586 | |         handle for you. Note that if theme
587 | |         is passed then this value will be overridden by the
588 | |         corresponding option of the theme.
589 | |
590 | |     width: int (optional, default 800)
591 | |         The desired width of the plot in pixels.
592 | |
593 | |     height: int (optional, default 800)
594 | |         The desired height of the plot in pixels
595 | |
596 | |     show_legend: bool (optional, default True)
597 | |         Whether to display a legend of the labels
598 | |
599 | |     subset_points: array, shape (n_samples,) (optional, default None)
600 | |         A way to select a subset of points based on an array of boolean
601 | |         values.
602 | |
603 | |     ax: matplotlib axis (optional, default None)
604 | |         The matplotlib axis to draw the plot to, or if None, which is
605 | |         the default, a new axis will be created and returned.
606 | |
607 | |     alpha: float (optional, default: None)
608 | |         The alpha blending value, between 0 (transparent) and 1 (opaque).
609 | |
610 | |     Returns
611 | |     -------
612 | |     result: matplotlib axis
613 | |         The result is a matplotlib axis with the relevant plot displayed.
614 | |         If you are using a notebooks and have ``%matplotlib inline`` set
615 | |         then this will simply display inline.
616 | |
617 | |     """
    | |_______^
618 |       # if not hasattr(umap_object, "embedding_"):
619 |       #     raise ValueError(
    |
help: Insert single blank line

ERA001 Found commented-out code
   --> umap/plot.py:621:5
    |
619 |     #     raise ValueError(
620 |     #         "UMAP object must perform fit on data before it can be visualized"
621 |     #     )
    |     ^^^^^^^
622 |
623 |     if theme is not None:
    |
help: Remove commented-out code

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> umap/plot.py:656:27
    |
654 |             values = values[subset_points]
655 |
656 |     if points.shape[1] != 2:
    |                           ^
657 |         msg = "Plotting is currently only implemented for 2D embeddings"
658 |         raise ValueError(msg)
    |

PLR0913 Too many arguments in function definition (13 > 5)
   --> umap/plot.py:724:5
    |
724 | def connectivity(
    |     ^^^^^^^^^^^^
725 |     umap_object,
726 |     edge_bundling=None,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/plot.py:728:5
    |
726 |     edge_bundling=None,
727 |     edge_cmap="gray_r",
728 |     show_points=False,
    |     ^^^^^^^^^^^
729 |     labels=None,
730 |     values=None,
    |

D205 1 blank line required between summary line and description
   --> umap/plot.py:739:5
    |
737 |       height=800,
738 |   ):
739 | /     """Plot connectivity relationships of the underlying UMAP
740 | |     simplicial set data structure. Internally UMAP will make
741 | |     use of what can be viewed as a weighted graph. This graph
742 | |     can be plotted using the layout provided by UMAP as a
743 | |     potential diagnostic view of the embedding. Currently this only works
744 | |     for 2D embeddings. While there are many optional parameters
745 | |     to further control and tailor the plotting, you need only
746 | |     pass in the trained/fit umap model to get results. This plot
747 | |     utility will attempt to do the hard work of avoiding
748 | |     over-plotting issues and provide options for plotting the
749 | |     points as well as using edge bundling for graph visualization.
750 | |
751 | |     Parameters
752 | |     ----------
753 | |     umap_object: trained UMAP object
754 | |         A trained UMAP object that has a 2D embedding.
755 | |
756 | |     edge_bundling: string or None (optional, default None)
757 | |         The edge bundling method to use. Currently supported
758 | |         are None or 'hammer'. See the datashader docs
759 | |         on graph visualization for more details.
760 | |
761 | |     edge_cmap: string (default 'gray_r')
762 | |         The name of a matplotlib colormap to use for shading/
763 | |         coloring the edges of the connectivity graph. Note that
764 | |         the ``theme``, if specified, will override this.
765 | |
766 | |     show_points: bool (optional False)
767 | |         Whether to display the points over top of the edge
768 | |         connectivity. Further options allow for coloring/
769 | |         shading the points accordingly.
770 | |
771 | |     labels: array, shape (n_samples,) (optional, default None)
772 | |         An array of labels (assumed integer or categorical),
773 | |         one for each data sample.
774 | |         This will be used for coloring the points in
775 | |         the plot according to their label. Note that
776 | |         this option is mutually exclusive to the ``values``
777 | |         option.
778 | |
779 | |     values: array, shape (n_samples,) (optional, default None)
780 | |         An array of values (assumed float or continuous),
781 | |         one for each sample.
782 | |         This will be used for coloring the points in
783 | |         the plot according to a colorscale associated
784 | |         to the total range of values. Note that this
785 | |         option is mutually exclusive to the ``labels``
786 | |         option.
787 | |
788 | |     theme: string (optional, default None)
789 | |         A color theme to use for plotting. A small set of
790 | |         predefined themes are provided which have relatively
791 | |         good aesthetics. Available themes are:
792 | |            * 'blue'
793 | |            * 'red'
794 | |            * 'green'
795 | |            * 'inferno'
796 | |            * 'fire'
797 | |            * 'viridis'
798 | |            * 'darkblue'
799 | |            * 'darkred'
800 | |            * 'darkgreen'
801 | |
802 | |     cmap: string (optional, default 'Blues')
803 | |         The name of a matplotlib colormap to use for coloring
804 | |         or shading points. If no labels or values are passed
805 | |         this will be used for shading points according to
806 | |         density (largely only of relevance for very large
807 | |         datasets). If values are passed this will be used for
808 | |         shading according the value. Note that if theme
809 | |         is passed then this value will be overridden by the
810 | |         corresponding option of the theme.
811 | |
812 | |     color_key: dict or array, shape (n_categories) (optional, default None)
813 | |         A way to assign colors to categoricals. This can either be
814 | |         an explicit dict mapping labels to colors (as strings of form
815 | |         '#RRGGBB'), or an array like object providing one color for
816 | |         each distinct category being provided in ``labels``. Either
817 | |         way this mapping will be used to color points according to
818 | |         the label. Note that if theme
819 | |         is passed then this value will be overridden by the
820 | |         corresponding option of the theme.
821 | |
822 | |     color_key_cmap: string (optional, default 'Spectral')
823 | |         The name of a matplotlib colormap to use for categorical coloring.
824 | |         If an explicit ``color_key`` is not given a color mapping for
825 | |         categories can be generated from the label list and selecting
826 | |         a matching list of colors from the given colormap. Note
827 | |         that if theme
828 | |         is passed then this value will be overridden by the
829 | |         corresponding option of the theme.
830 | |
831 | |     background: string (optional, default 'white)
832 | |         The color of the background. Usually this will be either
833 | |         'white' or 'black', but any color name will work. Ideally
834 | |         one wants to match this appropriately to the colors being
835 | |         used for points etc. This is one of the things that themes
836 | |         handle for you. Note that if theme
837 | |         is passed then this value will be overridden by the
838 | |         corresponding option of the theme.
839 | |
840 | |     width: int (optional, default 800)
841 | |         The desired width of the plot in pixels.
842 | |
843 | |     height: int (optional, default 800)
844 | |         The desired height of the plot in pixels
845 | |
846 | |     Returns
847 | |     -------
848 | |     result: matplotlib axis
849 | |         The result is a matplotlib axis with the relevant plot displayed.
850 | |         If you are using a notebook and have ``%matplotlib inline`` set
851 | |         then this will simply display inline.
852 | |
853 | |     """
    | |_______^
854 |       if theme is not None:
855 |           cmap = _themes[theme]["cmap"]
    |
help: Insert single blank line

FBT003 Boolean positional value in function call
   --> umap/plot.py:915:13
    |
913 |             width,
914 |             height,
915 |             False,
    |             ^^^^^
916 |         )
917 |         if px_size > 1:
    |

C901 `diagnostic` is too complex (24 > 10)
   --> umap/plot.py:943:5
    |
941 |     return ax
942 |
943 | def diagnostic(
    |     ^^^^^^^^^^
944 |     umap_object,
945 |     diagnostic_type="pca",
    |

PLR0913 Too many arguments in function definition (12 > 5)
   --> umap/plot.py:943:5
    |
941 |     return ax
942 |
943 | def diagnostic(
    |     ^^^^^^^^^^
944 |     umap_object,
945 |     diagnostic_type="pca",
    |

PLR0912 Too many branches (25 > 12)
   --> umap/plot.py:943:5
    |
941 |     return ax
942 |
943 | def diagnostic(
    |     ^^^^^^^^^^
944 |     umap_object,
945 |     diagnostic_type="pca",
    |

PLR0915 Too many statements (102 > 50)
   --> umap/plot.py:943:5
    |
941 |     return ax
942 |
943 | def diagnostic(
    |     ^^^^^^^^^^
944 |     umap_object,
945 |     diagnostic_type="pca",
    |

FBT002 Boolean default positional argument in function definition
   --> umap/plot.py:954:5
    |
952 |     width=800,
953 |     height=800,
954 |     return_diagnostics=False,
    |     ^^^^^^^^^^^^^^^^^^
955 |     plot_result=True,
956 | ):
    |

FBT002 Boolean default positional argument in function definition
   --> umap/plot.py:955:5
    |
953 |     height=800,
954 |     return_diagnostics=False,
955 |     plot_result=True,
    |     ^^^^^^^^^^^
956 | ):
957 |     """Provide a diagnostic plot or plots for a UMAP embedding, with options to return diagnostics and control plotting.
    |

D205 1 blank line required between summary line and description
    --> umap/plot.py:957:5
     |
 955 |       plot_result=True,
 956 |   ):
 957 | /     """Provide a diagnostic plot or plots for a UMAP embedding, with options to return diagnostics and control plotting.
 958 | |     There are a number of plots that can be helpful for diagnostic
 959 | |     purposes in understanding your embedding. Currently these are
 960 | |     restricted to methods of coloring a scatterplot of the
 961 | |     embedding to show more about how the embedding is representing
 962 | |     the data. The first class of such plots uses a linear method
 963 | |     that preserves global structure well to embed the data into
 964 | |     three dimensions, and then interprets such coordinates as a
 965 | |     color space -- coloring the points by their location in the
 966 | |     linear global structure preserving embedding. In such plots
 967 | |     one should look for discontinuities of colour, and consider
 968 | |     overall global gradients of color. The diagnostic types here
 969 | |     are ``'pca'``, ``'ica'``, and ``'vq'`` (vector quantization).
 970 | |
 971 | |     The second class consider the local neighbor structure. One
 972 | |     can either look at how well the neighbor structure is
 973 | |     preserved, or how the estimated local dimension of the data
 974 | |     varies. Both of these are available, although the local
 975 | |     dimension estimation is the preferred option. You can
 976 | |     access these are diagnostic types ``'local_dim'`` and ``'neighborhood'``.
 977 | |
 978 | |     Finally the diagnostic type ``'all'`` will provide a
 979 | |     grid of diagnostic plots.
 980 | |
 981 | |     Parameters
 982 | |     ----------
 983 | |     umap_object: trained UMAP object
 984 | |         A trained UMAP object that has a 2D embedding.
 985 | |
 986 | |     diagnostic_type: str (optional, default 'pca')
 987 | |         The type of diagnostic plot to show. The options are
 988 | |            * 'pca'
 989 | |            * 'ica'
 990 | |            * 'vq'
 991 | |            * 'local_dim'
 992 | |            * 'neighborhood'
 993 | |            * 'all'
 994 | |
 995 | |     nhood_size: int (optional, default 15)
 996 | |         The size of neighborhood to compare for local
 997 | |         neighborhood preservation estimates.
 998 | |
 999 | |     local_variance_threshold: float (optional, default 0.8)
1000 | |         To estimate the local dimension we consider a PCA of
1001 | |         the local neighborhood and estimate the dimension
1002 | |         as that which provides ``local_variance_threshold``
1003 | |         or more of the ``variance_explained_ratio``.
1004 | |
1005 | |     ax: matplotlib axis (optional, default None)
1006 | |         A matplotlib axis to plot to, or, if None, a new
1007 | |         axis will be created and returned. Ignored if plot_result=False.
1008 | |
1009 | |     cmap: str (optional, default 'viridis')
1010 | |         The name of a matplotlib colormap to use for coloring
1011 | |         points if the ``'local_dim'`` or ``'neighborhood'``
1012 | |         option are selected.
1013 | |
1014 | |     point_size: int (optional, None)
1015 | |         If provided this will fix the point size for the
1016 | |         plot(s). If None then a suitable point size will
1017 | |         be estimated from the data.
1018 | |
1019 | |     background: str (optional, default 'white')
1020 | |         The background color for the plot.
1021 | |
1022 | |     width: int (optional, default 800)
1023 | |         The width of the plot in pixels.
1024 | |
1025 | |     height: int (optional, default 800)
1026 | |         The height of the plot in pixels.
1027 | |
1028 | |     return_diagnostics: bool (optional, default False)
1029 | |         If True, returns the diagnostic data (e.g., color projections or metrics)
1030 | |         instead of or in addition to the axis, depending on plot_result.
1031 | |
1032 | |     plot_result: bool (optional, default True)
1033 | |         If False, no plot is generated, and the function returns either the
1034 | |         diagnostic data (if return_diagnostics=True) or None.
1035 | |
1036 | |     Returns
1037 | |     -------
1038 | |     result: matplotlib axis or tuple or array
1039 | |         If return_diagnostics=False and plot_result=True, returns a matplotlib axis
1040 | |         with the relevant plot displayed.
1041 | |         If return_diagnostics=True and plot_result=True, returns a tuple of
1042 | |         (matplotlib axis, diagnostic data).
1043 | |         If return_diagnostics=True and plot_result=False, returns the diagnostic data.
1044 | |         If return_diagnostics=False and plot_result=False, returns None.
1045 | |         If using a notebook with ``%matplotlib inline``, plots may display inline.
1046 | |
1047 | |     """
     | |_______^
1048 |       points = _get_embedding(umap_object)
     |
help: Insert single blank line

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    --> umap/plot.py:1050:27
     |
1048 |     points = _get_embedding(umap_object)
1049 |
1050 |     if points.shape[1] != 2:
     |                           ^
1051 |         msg = "Plotting is currently only implemented for 2D embeddings"
1052 |         raise ValueError(msg)
     |

SLF001 Private member accessed: `_raw_data`
    --> umap/plot.py:1070:13
     |
1068 |     if diagnostic_type == "pca":
1069 |         color_proj = sklearn.decomposition.PCA(n_components=3).fit_transform(
1070 |             umap_object._raw_data,
     |             ^^^^^^^^^^^^^^^^^^^^^
1071 |         )
1072 |         color_proj -= np.min(color_proj)
     |

SLF001 Private member accessed: `_raw_data`
    --> umap/plot.py:1091:13
     |
1089 |     elif diagnostic_type == "ica":
1090 |         color_proj = sklearn.decomposition.FastICA(n_components=3).fit_transform(
1091 |             umap_object._raw_data,
     |             ^^^^^^^^^^^^^^^^^^^^^
1092 |         )
1093 |         color_proj -= np.min(color_proj)
     |

SLF001 Private member accessed: `_raw_data`
    --> umap/plot.py:1112:13
     |
1110 |     elif diagnostic_type == "vq":
1111 |         color_projector = sklearn.cluster.KMeans(n_clusters=3).fit(
1112 |             umap_object._raw_data,
     |             ^^^^^^^^^^^^^^^^^^^^^
1113 |         )
1114 |         color_proj = sklearn.metrics.pairwise_distances(
     |

SLF001 Private member accessed: `_raw_data`
    --> umap/plot.py:1115:13
     |
1113 |         )
1114 |         color_proj = sklearn.metrics.pairwise_distances(
1115 |             umap_object._raw_data, color_projector.cluster_centers_,
     |             ^^^^^^^^^^^^^^^^^^^^^
1116 |         )
1117 |         color_proj -= np.min(color_proj)
     |

RUF059 Unpacked variable `highd_dists` is never used
    --> umap/plot.py:1135:24
     |
1134 |     elif diagnostic_type == "neighborhood":
1135 |         highd_indices, highd_dists = _nhood_search(umap_object, nhood_size)
     |                        ^^^^^^^^^^^
1136 |         tree = sklearn.neighbors.KDTree(points)
1137 |         _lowd_dists, lowd_indices = tree.query(points, k=nhood_size)
     |
help: Prefix it with an underscore or any other dummy variable pattern

SLF001 Private member accessed: `_raw_data`
    --> umap/plot.py:1172:16
     |
1170 |     elif diagnostic_type == "local_dim":
1171 |         highd_indices, _highd_dists = _nhood_search(umap_object, umap_object.n_neighbors)
1172 |         data = umap_object._raw_data
     |                ^^^^^^^^^^^^^^^^^^^^^
1173 |         local_dim = np.empty(data.shape[0], dtype=np.int64)
1174 |         for i in range(data.shape[0]):
     |

C901 `interactive` is too complex (32 > 10)
    --> umap/plot.py:1255:5
     |
1253 |     return ax
1254 |
1255 | def interactive(
     |     ^^^^^^^^^^^
1256 |     umap_object,
1257 |     labels=None,
     |

PLR0913 Too many arguments in function definition (18 > 5)
    --> umap/plot.py:1255:5
     |
1253 |     return ax
1254 |
1255 | def interactive(
     |     ^^^^^^^^^^^
1256 |     umap_object,
1257 |     labels=None,
     |

PLR0912 Too many branches (37 > 12)
    --> umap/plot.py:1255:5
     |
1253 |     return ax
1254 |
1255 | def interactive(
     |     ^^^^^^^^^^^
1256 |     umap_object,
1257 |     labels=None,
     |

PLR0915 Too many statements (106 > 50)
    --> umap/plot.py:1255:5
     |
1253 |     return ax
1254 |
1255 | def interactive(
     |     ^^^^^^^^^^^
1256 |     umap_object,
1257 |     labels=None,
     |

D417 Missing argument description in the docstring for `interactive`: `hover_data`
    --> umap/plot.py:1255:5
     |
1253 |     return ax
1254 |
1255 | def interactive(
     |     ^^^^^^^^^^^
1256 |     umap_object,
1257 |     labels=None,
     |

FBT002 Boolean default positional argument in function definition
    --> umap/plot.py:1270:5
     |
1268 |     point_size=None,
1269 |     subset_points=None,
1270 |     interactive_text_search=False,
     |     ^^^^^^^^^^^^^^^^^^^^^^^
1271 |     interactive_text_search_columns=None,
1272 |     interactive_text_search_alpha_contrast=0.95,
     |

D205 1 blank line required between summary line and description
    --> umap/plot.py:1275:5
     |
1273 |       alpha=None,
1274 |   ):
1275 | /     """Create an interactive bokeh plot of a UMAP embedding.
1276 | |     While static plots are useful, sometimes a plot that
1277 | |     supports interactive zooming, and hover tooltips for
1278 | |     individual points is much more desirable. This function
1279 | |     provides a simple interface for creating such plots. The
1280 | |     result is a bokeh plot that will be displayed in a notebook.
1281 | |
1282 | |     Note that more complex tooltips etc. will require custom
1283 | |     code -- this is merely meant to provide fast and easy
1284 | |     access to interactive plotting.
1285 | |
1286 | |     Parameters
1287 | |     ----------
1288 | |     umap_object: trained UMAP object
1289 | |         A trained UMAP object that has a 2D embedding.
1290 | |
1291 | |     labels: array, shape (n_samples,) (optional, default None)
1292 | |         An array of labels (assumed integer or categorical),
1293 | |         one for each data sample.
1294 | |         This will be used for coloring the points in
1295 | |         the plot according to their label. Note that
1296 | |         this option is mutually exclusive to the ``values``
1297 | |         option.
1298 | |
1299 | |     values: array, shape (n_samples,) (optional, default None)
1300 | |         An array of values (assumed float or continuous),
1301 | |         one for each sample.
1302 | |         This will be used for coloring the points in
1303 | |         the plot according to a colorscale associated
1304 | |         to the total range of values. Note that this
1305 | |         option is mutually exclusive to the ``labels``
1306 | |         option.
1307 | |
1308 | |     hover_data: DataFrame, shape (n_samples, n_tooltip_features)
1309 | |     (optional, default None)
1310 | |         A dataframe of tooltip data. Each column of the dataframe
1311 | |         should be a Series of length ``n_samples`` providing a value
1312 | |         for each data point. Column names will be used for
1313 | |         identifying information within the tooltip.
1314 | |
1315 | |     tools: List (optional, default None),
1316 | |         Defines the tools to be configured for interactive plots.
1317 | |         The list can be mixed type of string and tools objects defined by
1318 | |         Bokeh like HoverTool. Default tool list Bokeh uses is
1319 | |         ["pan","wheel_zoom","box_zoom","save","reset","help",].
1320 | |         When tools are specified, and includes hovertool, automatic tooltip
1321 | |         based on hover_data is not created.
1322 | |
1323 | |     theme: string (optional, default None)
1324 | |         A color theme to use for plotting. A small set of
1325 | |         predefined themes are provided which have relatively
1326 | |         good aesthetics. Available themes are:
1327 | |            * 'blue'
1328 | |            * 'red'
1329 | |            * 'green'
1330 | |            * 'inferno'
1331 | |            * 'fire'
1332 | |            * 'viridis'
1333 | |            * 'darkblue'
1334 | |            * 'darkred'
1335 | |            * 'darkgreen'
1336 | |
1337 | |     cmap: string (optional, default 'Blues')
1338 | |         The name of a matplotlib colormap to use for coloring
1339 | |         or shading points. If no labels or values are passed
1340 | |         this will be used for shading points according to
1341 | |         density (largely only of relevance for very large
1342 | |         datasets). If values are passed this will be used for
1343 | |         shading according the value. Note that if theme
1344 | |         is passed then this value will be overridden by the
1345 | |         corresponding option of the theme.
1346 | |
1347 | |     color_key: dict or array, shape (n_categories) (optional, default None)
1348 | |         A way to assign colors to categoricals. This can either be
1349 | |         an explicit dict mapping labels to colors (as strings of form
1350 | |         '#RRGGBB'), or an array like object providing one color for
1351 | |         each distinct category being provided in ``labels``. Either
1352 | |         way this mapping will be used to color points according to
1353 | |         the label. Note that if theme
1354 | |         is passed then this value will be overridden by the
1355 | |         corresponding option of the theme.
1356 | |
1357 | |     color_key_cmap: string (optional, default 'Spectral')
1358 | |         The name of a matplotlib colormap to use for categorical coloring.
1359 | |         If an explicit ``color_key`` is not given a color mapping for
1360 | |         categories can be generated from the label list and selecting
1361 | |         a matching list of colors from the given colormap. Note
1362 | |         that if theme
1363 | |         is passed then this value will be overridden by the
1364 | |         corresponding option of the theme.
1365 | |
1366 | |     background: string (optional, default 'white')
1367 | |         The color of the background. Usually this will be either
1368 | |         'white' or 'black', but any color name will work. Ideally
1369 | |         one wants to match this appropriately to the colors being
1370 | |         used for points etc. This is one of the things that themes
1371 | |         handle for you. Note that if theme
1372 | |         is passed then this value will be overridden by the
1373 | |         corresponding option of the theme.
1374 | |
1375 | |     width: int (optional, default 800)
1376 | |         The desired width of the plot in pixels.
1377 | |
1378 | |     height: int (optional, default 800)
1379 | |         The desired height of the plot in pixels
1380 | |
1381 | |     point_size: int (optional, default None)
1382 | |         The size of each point marker
1383 | |
1384 | |     subset_points: array, shape (n_samples,) (optional, default None)
1385 | |         A way to select a subset of points based on an array of boolean
1386 | |         values.
1387 | |
1388 | |     interactive_text_search: bool (optional, default False)
1389 | |         Whether to include a text search widget above the interactive plot
1390 | |
1391 | |     interactive_text_search_columns: list (optional, default None)
1392 | |         Columns of data source to search. Searches labels and hover_data by default.
1393 | |
1394 | |     interactive_text_search_alpha_contrast: float (optional, default 0.95)
1395 | |         Alpha value for points matching text search. Alpha value for points
1396 | |         not matching text search will be 1 - interactive_text_search_alpha_contrast
1397 | |
1398 | |     alpha: float (optional, default: None)
1399 | |         The alpha blending value, between 0 (transparent) and 1 (opaque).
1400 | |
1401 | |     Returns
1402 | |     -------
1403 | |
1404 | |     """
     | |_______^
1405 |       if theme is not None:
1406 |           cmap = _themes[theme]["cmap"]
     |
help: Insert single blank line

D414 Section has no content ("Returns")
    --> umap/plot.py:1401:5
     |
1399 |         The alpha blending value, between 0 (transparent) and 1 (opaque).
1400 |
1401 |     Returns
     |     ^^^^^^^
1402 |     -------
     |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    --> umap/plot.py:1431:27
     |
1429 |         points = points[subset_points]
1430 |
1431 |     if points.shape[1] != 2:
     |                           ^
1432 |         msg = "Plotting is currently only implemented for 2D embeddings"
1433 |         raise ValueError(msg)
     |

ERA001 Found commented-out code
    --> umap/plot.py:1501:9
     |
1499 |             data["alpha"] = 1
1500 |
1501 |         # bpl.output_notebook(hide_banner=True) # this doesn't work for non-notebook use
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1502 |         data_source = bpl.ColumnDataSource(data)
     |
help: Remove commented-out code

ERA001 Found commented-out code
    --> umap/plot.py:1584:9
     |
1582 |                 plot = column(text_input, plot)
1583 |
1584 |         # bpl.show(plot)
     |         ^^^^^^^^^^^^^^^^
1585 |     else:
1586 |         if hover_data is not None:
     |
help: Remove commented-out code

PD011 Use `.to_numpy()` instead of `.values`
    --> umap/plot.py:1610:23
     |
1608 |             )
1609 |         elif values is not None:
1610 |             min_val = data.values.min()
     |                       ^^^^^^^^^^^
1611 |             val_range = data.values.max() - min_val
1612 |             data["val_cat"] = pd.Categorical(
     |

PD011 Use `.to_numpy()` instead of `.values`
    --> umap/plot.py:1611:25
     |
1609 |         elif values is not None:
1610 |             min_val = data.values.min()
1611 |             val_range = data.values.max() - min_val
     |                         ^^^^^^^^^^^
1612 |             data["val_cat"] = pd.Categorical(
1613 |                 (data.values - min_val) // (val_range // 256),
     |

PD011 Use `.to_numpy()` instead of `.values`
    --> umap/plot.py:1613:18
     |
1611 |             val_range = data.values.max() - min_val
1612 |             data["val_cat"] = pd.Categorical(
1613 |                 (data.values - min_val) // (val_range // 256),
     |                  ^^^^^^^^^^^
1614 |             )
1615 |             point_plot = hv.Points(data, kdims=["x", "y"], vdims=["val_cat"])
     |

D205 1 blank line required between summary line and description
    --> umap/plot.py:1637:5
     |
1636 |   def nearest_neighbour_distribution(umap_object, bins=25, ax=None):
1637 | /     """Create a histogram of the average distance to each points
1638 | |     nearest neighbors.
1639 | |
1640 | |     Parameters
1641 | |     ----------
1642 | |     umap_object: trained UMAP object
1643 | |         A trained UMAP object that has an embedding.
1644 | |
1645 | |     bins: int (optional, default 25)
1646 | |         Number of bins to put the points into
1647 | |
1648 | |     ax: matplotlib axis (optional, default None)
1649 | |         A matplotlib axis to plot to, or, if None, a new
1650 | |         axis will be created and returned.
1651 | |
1652 | |     Returns
1653 | |     -------
1654 | |
1655 | |     """
     | |_______^
1656 |       nn_distances = average_nn_distance(umap_object.graph_)
     |
help: Insert single blank line

D414 Section has no content ("Returns")
    --> umap/plot.py:1652:5
     |
1650 |         axis will be created and returned.
1651 |
1652 |     Returns
     |     ^^^^^^^
1653 |     -------
     |

D103 Missing docstring in public function
  --> umap/sparse.py:18:5
   |
16 | # Just reproduce a simpler version of numpy unique (not numba supported yet)
17 | @numba.njit()
18 | def arr_unique(arr):
   |     ^^^^^^^^^^
19 |     aux = np.sort(arr)
20 |     flag = np.concatenate((np.ones(1, dtype=np.bool_), aux[1:] != aux[:-1]))
   |

D103 Missing docstring in public function
  --> umap/sparse.py:26:5
   |
24 | # Just reproduce a simpler version of numpy union1d (not numba supported yet)
25 | @numba.njit()
26 | def arr_union(ar1, ar2):
   |     ^^^^^^^^^
27 |     if ar1.shape[0] == 0:
28 |         return ar2
   |

D103 Missing docstring in public function
  --> umap/sparse.py:37:5
   |
35 | # yet)
36 | @numba.njit()
37 | def arr_intersect(ar1, ar2):
   |     ^^^^^^^^^^^^^
38 |     aux = np.concatenate((ar1, ar2))
39 |     aux.sort()
   |

C901 `sparse_sum` is too complex (11 > 10)
  --> umap/sparse.py:44:5
   |
43 | @numba.njit()
44 | def sparse_sum(ind1, data1, ind2, data2):
   |     ^^^^^^^^^^
45 |     result_ind = arr_union(ind1, ind2)
46 |     result_data = np.zeros(result_ind.shape[0], dtype=np.float32)
   |

D103 Missing docstring in public function
  --> umap/sparse.py:44:5
   |
43 | @numba.njit()
44 | def sparse_sum(ind1, data1, ind2, data2):
   |     ^^^^^^^^^^
45 |     result_ind = arr_union(ind1, ind2)
46 |     result_data = np.zeros(result_ind.shape[0], dtype=np.float32)
   |

D103 Missing docstring in public function
   --> umap/sparse.py:105:5
    |
104 | @numba.njit()
105 | def sparse_diff(ind1, data1, ind2, data2):
    |     ^^^^^^^^^^^
106 |     return sparse_sum(ind1, data1, ind2, -data2)
    |

D103 Missing docstring in public function
   --> umap/sparse.py:110:5
    |
109 | @numba.njit()
110 | def sparse_mul(ind1, data1, ind2, data2):
    |     ^^^^^^^^^^
111 |     result_ind = arr_intersect(ind1, ind2)
112 |     result_data = np.zeros(result_ind.shape[0], dtype=np.float32)
    |

PLR0913 Too many arguments in function definition (11 > 5)
   --> umap/sparse.py:144:5
    |
143 | @numba.njit()
144 | def general_sset_intersection(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
145 |     indptr1,
146 |     indices1,
    |

D103 Missing docstring in public function
   --> umap/sparse.py:144:5
    |
143 | @numba.njit()
144 | def general_sset_intersection(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
145 |     indptr1,
146 |     indices1,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/sparse.py:154:5
    |
152 |     result_col,
153 |     result_val,
154 |     right_complement=False,
    |     ^^^^^^^^^^^^^^^^
155 |     mix_weight=0.5,
156 | ):
    |

PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
   --> umap/sparse.py:183:29
    |
182 |         if left_val > left_min or right_val > right_min:
183 |             if mix_weight < 0.5:
    |                             ^^^
184 |                 result_val[idx] = left_val * pow(
185 |                     right_val, mix_weight / (1.0 - mix_weight),
    |

PLR0913 Too many arguments in function definition (9 > 5)
   --> umap/sparse.py:195:5
    |
194 | @numba.njit()
195 | def general_sset_union(
    |     ^^^^^^^^^^^^^^^^^^
196 |     indptr1,
197 |     indices1,
    |

D103 Missing docstring in public function
   --> umap/sparse.py:195:5
    |
194 | @numba.njit()
195 | def general_sset_union(
    |     ^^^^^^^^^^^^^^^^^^
196 |     indptr1,
197 |     indices1,
    |

D103 Missing docstring in public function
   --> umap/sparse.py:228:5
    |
227 | @numba.njit()
228 | def sparse_euclidean(ind1, data1, ind2, data2):
    |     ^^^^^^^^^^^^^^^^
229 |     _aux_inds, aux_data = sparse_diff(ind1, data1, ind2, data2)
230 |     result = 0.0
    |

D103 Missing docstring in public function
   --> umap/sparse.py:237:5
    |
236 | @numba.njit()
237 | def sparse_manhattan(ind1, data1, ind2, data2):
    |     ^^^^^^^^^^^^^^^^
238 |     _aux_inds, aux_data = sparse_diff(ind1, data1, ind2, data2)
239 |     result = 0.0
    |

D103 Missing docstring in public function
   --> umap/sparse.py:246:5
    |
245 | @numba.njit()
246 | def sparse_chebyshev(ind1, data1, ind2, data2):
    |     ^^^^^^^^^^^^^^^^
247 |     _aux_inds, aux_data = sparse_diff(ind1, data1, ind2, data2)
248 |     result = 0.0
    |

D103 Missing docstring in public function
   --> umap/sparse.py:255:5
    |
254 | @numba.njit()
255 | def sparse_minkowski(ind1, data1, ind2, data2, p=2.0):
    |     ^^^^^^^^^^^^^^^^
256 |     _aux_inds, aux_data = sparse_diff(ind1, data1, ind2, data2)
257 |     result = 0.0
    |

D103 Missing docstring in public function
   --> umap/sparse.py:264:5
    |
263 | @numba.njit()
264 | def sparse_hamming(ind1, data1, ind2, data2, n_features):
    |     ^^^^^^^^^^^^^^
265 |     num_not_equal = sparse_diff(ind1, data1, ind2, data2)[0].shape[0]
266 |     return float(num_not_equal) / n_features
    |

D103 Missing docstring in public function
   --> umap/sparse.py:270:5
    |
269 | @numba.njit()
270 | def sparse_canberra(ind1, data1, ind2, data2):
    |     ^^^^^^^^^^^^^^^
271 |     abs_data1 = np.abs(data1)
272 |     abs_data2 = np.abs(data2)
    |

D103 Missing docstring in public function
   --> umap/sparse.py:284:5
    |
283 | @numba.njit()
284 | def sparse_bray_curtis(ind1, data1, ind2, data2):  # pragma: no cover
    |     ^^^^^^^^^^^^^^^^^^
285 |     _denom_inds, denom_data = sparse_sum(ind1, data1, ind2, data2)
286 |     denom_data = np.abs(denom_data)
    |

D103 Missing docstring in public function
   --> umap/sparse.py:305:5
    |
304 | @numba.njit()
305 | def sparse_jaccard(ind1, data1, ind2, data2):
    |     ^^^^^^^^^^^^^^
306 |     num_non_zero = arr_union(ind1, ind2).shape[0]
307 |     num_equal = arr_intersect(ind1, ind2).shape[0]
    |

ARG001 Unused function argument: `data1`
   --> umap/sparse.py:305:26
    |
304 | @numba.njit()
305 | def sparse_jaccard(ind1, data1, ind2, data2):
    |                          ^^^^^
306 |     num_non_zero = arr_union(ind1, ind2).shape[0]
307 |     num_equal = arr_intersect(ind1, ind2).shape[0]
    |

ARG001 Unused function argument: `data2`
   --> umap/sparse.py:305:39
    |
304 | @numba.njit()
305 | def sparse_jaccard(ind1, data1, ind2, data2):
    |                                       ^^^^^
306 |     num_non_zero = arr_union(ind1, ind2).shape[0]
307 |     num_equal = arr_intersect(ind1, ind2).shape[0]
    |

D103 Missing docstring in public function
   --> umap/sparse.py:315:5
    |
314 | @numba.njit()
315 | def sparse_matching(ind1, data1, ind2, data2, n_features):
    |     ^^^^^^^^^^^^^^^
316 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
317 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

ARG001 Unused function argument: `data1`
   --> umap/sparse.py:315:27
    |
314 | @numba.njit()
315 | def sparse_matching(ind1, data1, ind2, data2, n_features):
    |                           ^^^^^
316 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
317 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

ARG001 Unused function argument: `data2`
   --> umap/sparse.py:315:40
    |
314 | @numba.njit()
315 | def sparse_matching(ind1, data1, ind2, data2, n_features):
    |                                        ^^^^^
316 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
317 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

D103 Missing docstring in public function
   --> umap/sparse.py:324:5
    |
323 | @numba.njit()
324 | def sparse_dice(ind1, data1, ind2, data2):
    |     ^^^^^^^^^^^
325 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
326 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

ARG001 Unused function argument: `data1`
   --> umap/sparse.py:324:23
    |
323 | @numba.njit()
324 | def sparse_dice(ind1, data1, ind2, data2):
    |                       ^^^^^
325 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
326 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

ARG001 Unused function argument: `data2`
   --> umap/sparse.py:324:36
    |
323 | @numba.njit()
324 | def sparse_dice(ind1, data1, ind2, data2):
    |                                    ^^^^^
325 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
326 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

D103 Missing docstring in public function
   --> umap/sparse.py:335:5
    |
334 | @numba.njit()
335 | def sparse_kulsinski(ind1, data1, ind2, data2, n_features):
    |     ^^^^^^^^^^^^^^^^
336 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
337 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

ARG001 Unused function argument: `data1`
   --> umap/sparse.py:335:28
    |
334 | @numba.njit()
335 | def sparse_kulsinski(ind1, data1, ind2, data2, n_features):
    |                            ^^^^^
336 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
337 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

ARG001 Unused function argument: `data2`
   --> umap/sparse.py:335:41
    |
334 | @numba.njit()
335 | def sparse_kulsinski(ind1, data1, ind2, data2, n_features):
    |                                         ^^^^^
336 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
337 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

D103 Missing docstring in public function
   --> umap/sparse.py:348:5
    |
347 | @numba.njit()
348 | def sparse_rogers_tanimoto(ind1, data1, ind2, data2, n_features):
    |     ^^^^^^^^^^^^^^^^^^^^^^
349 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
350 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

ARG001 Unused function argument: `data1`
   --> umap/sparse.py:348:34
    |
347 | @numba.njit()
348 | def sparse_rogers_tanimoto(ind1, data1, ind2, data2, n_features):
    |                                  ^^^^^
349 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
350 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

ARG001 Unused function argument: `data2`
   --> umap/sparse.py:348:47
    |
347 | @numba.njit()
348 | def sparse_rogers_tanimoto(ind1, data1, ind2, data2, n_features):
    |                                               ^^^^^
349 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
350 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

D103 Missing docstring in public function
   --> umap/sparse.py:357:5
    |
356 | @numba.njit()
357 | def sparse_russellrao(ind1, data1, ind2, data2, n_features):
    |     ^^^^^^^^^^^^^^^^^
358 |     if ind1.shape[0] == ind2.shape[0] and np.all(ind1 == ind2):
359 |         return 0.0
    |

D103 Missing docstring in public function
   --> umap/sparse.py:369:5
    |
368 | @numba.njit()
369 | def sparse_sokal_michener(ind1, data1, ind2, data2, n_features):
    |     ^^^^^^^^^^^^^^^^^^^^^
370 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
371 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

ARG001 Unused function argument: `data1`
   --> umap/sparse.py:369:33
    |
368 | @numba.njit()
369 | def sparse_sokal_michener(ind1, data1, ind2, data2, n_features):
    |                                 ^^^^^
370 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
371 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

ARG001 Unused function argument: `data2`
   --> umap/sparse.py:369:46
    |
368 | @numba.njit()
369 | def sparse_sokal_michener(ind1, data1, ind2, data2, n_features):
    |                                              ^^^^^
370 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
371 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

D103 Missing docstring in public function
   --> umap/sparse.py:378:5
    |
377 | @numba.njit()
378 | def sparse_sokal_sneath(ind1, data1, ind2, data2):
    |     ^^^^^^^^^^^^^^^^^^^
379 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
380 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

ARG001 Unused function argument: `data1`
   --> umap/sparse.py:378:31
    |
377 | @numba.njit()
378 | def sparse_sokal_sneath(ind1, data1, ind2, data2):
    |                               ^^^^^
379 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
380 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

ARG001 Unused function argument: `data2`
   --> umap/sparse.py:378:44
    |
377 | @numba.njit()
378 | def sparse_sokal_sneath(ind1, data1, ind2, data2):
    |                                            ^^^^^
379 |     num_true_true = arr_intersect(ind1, ind2).shape[0]
380 |     num_non_zero = arr_union(ind1, ind2).shape[0]
    |

D103 Missing docstring in public function
   --> umap/sparse.py:389:5
    |
388 | @numba.njit()
389 | def sparse_cosine(ind1, data1, ind2, data2):
    |     ^^^^^^^^^^^^^
390 |     _aux_inds, aux_data = sparse_mul(ind1, data1, ind2, data2)
391 |     result = 0.0
    |

D103 Missing docstring in public function
   --> umap/sparse.py:406:5
    |
405 | @numba.njit()
406 | def sparse_hellinger(ind1, data1, ind2, data2):
    |     ^^^^^^^^^^^^^^^^
407 |     _aux_inds, aux_data = sparse_mul(ind1, data1, ind2, data2)
408 |     result = 0.0
    |

C901 `sparse_correlation` is too complex (14 > 10)
   --> umap/sparse.py:426:5
    |
425 | @numba.njit()
426 | def sparse_correlation(ind1, data1, ind2, data2, n_features):
    |     ^^^^^^^^^^^^^^^^^^
427 |
428 |     mu_x = 0.0
    |

PLR0912 Too many branches (13 > 12)
   --> umap/sparse.py:426:5
    |
425 | @numba.njit()
426 | def sparse_correlation(ind1, data1, ind2, data2, n_features):
    |     ^^^^^^^^^^^^^^^^^^
427 |
428 |     mu_x = 0.0
    |

D103 Missing docstring in public function
   --> umap/sparse.py:426:5
    |
425 | @numba.njit()
426 | def sparse_correlation(ind1, data1, ind2, data2, n_features):
    |     ^^^^^^^^^^^^^^^^^^
427 |
428 |     mu_x = 0.0
    |

N802 Function name `approx_log_Gamma` should be lowercase
   --> umap/sparse.py:486:5
    |
485 | @numba.njit()
486 | def approx_log_Gamma(x):
    |     ^^^^^^^^^^^^^^^^
487 |     if x == 1:
488 |         return 0
    |

D103 Missing docstring in public function
   --> umap/sparse.py:486:5
    |
485 | @numba.njit()
486 | def approx_log_Gamma(x):
    |     ^^^^^^^^^^^^^^^^
487 |     if x == 1:
488 |         return 0
    |

ERA001 Found commented-out code
   --> umap/sparse.py:489:5
    |
487 |     if x == 1:
488 |         return 0
489 |     #    x2= 1/(x*x);
    |     ^^^^^^^^^^^^^^^^^
490 |     return (
491 |         x * np.log(x) - x + 0.5 * np.log(2.0 * np.pi / x) + 1.0 / (x * 12.0)
    |
help: Remove commented-out code

D103 Missing docstring in public function
   --> umap/sparse.py:500:5
    |
499 | @numba.njit()
500 | def log_beta(x, y):
    |     ^^^^^^^^
501 |     a = min(x, y)
502 |     b = max(x, y)
    |

PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   --> umap/sparse.py:503:12
    |
501 |     a = min(x, y)
502 |     b = max(x, y)
503 |     if b < 5:
    |            ^
504 |         value = -np.log(b)
505 |         for i in range(1, int(a)):
    |

D103 Missing docstring in public function
   --> umap/sparse.py:512:5
    |
511 | @numba.njit()
512 | def log_single_beta(x):
    |     ^^^^^^^^^^^^^^^
513 |     return (
514 |         np.log(2.0) * (-2.0 * x + 0.5) + 0.5 * np.log(2.0 * np.pi / x) + 0.125 / x
    |

D103 Missing docstring in public function
   --> umap/sparse.py:523:5
    |
522 | @numba.njit()
523 | def sparse_ll_dirichlet(ind1, data1, ind2, data2):
    |     ^^^^^^^^^^^^^^^^^^^
524 |     # The probability of rolling data2 in sum(data2) trials on a die that rolled data1 in sum(data1) trials
525 |     n1 = np.sum(data1)
    |

C901 `component_layout` is too complex (15 > 10)
  --> umap/spectral.py:16:5
   |
16 | def component_layout(
   |     ^^^^^^^^^^^^^^^^
17 |     data,
18 |     n_components,
   |

PLR0913 Too many arguments in function definition (7 > 5)
  --> umap/spectral.py:16:5
   |
16 | def component_layout(
   |     ^^^^^^^^^^^^^^^^
17 |     data,
18 |     n_components,
   |

PLR0912 Too many branches (17 > 12)
  --> umap/spectral.py:16:5
   |
16 | def component_layout(
   |     ^^^^^^^^^^^^^^^^
17 |     data,
18 |     n_components,
   |

D417 Missing argument description in the docstring for `component_layout`: `random_state`
  --> umap/spectral.py:16:5
   |
16 | def component_layout(
   |     ^^^^^^^^^^^^^^^^
17 |     data,
18 |     n_components,
   |

D205 1 blank line required between summary line and description
  --> umap/spectral.py:25:5
   |
23 |       metric_kwds=None,
24 |   ):
25 | /     """Provide a layout relating the separate connected components. This is done
26 | |     by taking the centroid of each component and then performing a spectral embedding
27 | |     of the centroids.
28 | |
29 | |     Parameters
30 | |     ----------
31 | |     data: array of shape (n_samples, n_features)
32 | |         The source data -- required so we can generate centroids for each
33 | |         connected component of the graph.
34 | |
35 | |     n_components: int
36 | |         The number of distinct components to be layed out.
37 | |
38 | |     component_labels: array of shape (n_samples)
39 | |         For each vertex in the graph the label of the component to
40 | |         which the vertex belongs.
41 | |
42 | |     dim: int
43 | |         The chosen embedding dimension.
44 | |
45 | |     metric: string or callable (optional, default 'euclidean')
46 | |         The metric used to measure distances among the source data points.
47 | |
48 | |     metric_kwds: dict (optional, default {})
49 | |         Keyword arguments to be passed to the metric function.
50 | |         If metric is 'precomputed', 'linkage' keyword can be used to specify
51 | |         'average', 'complete', or 'single' linkage. Default is 'average'
52 | |
53 | |     Returns
54 | |     -------
55 | |     component_embedding: array of shape (n_components, dim)
56 | |         The ``dim``-dimensional embedding of the ``n_components``-many
57 | |         connected components.
58 | |
59 | |     """
   | |_______^
60 |       if metric_kwds is None:
61 |           metric_kwds = {}
   |
help: Insert single blank line

NPY002 Replace legacy `np.random.random` call with `np.random.Generator`
  --> umap/spectral.py:64:16
   |
62 |     if data is None:
63 |         # We don't have data to work with; just guess
64 |         return np.random.random(size=(n_components, dim)) * 10.0
   |                ^^^^^^^^^^^^^^^^
65 |
66 |     component_centroids = np.empty((n_components, data.shape[1]), dtype=np.float64)
   |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> umap/spectral.py:130:17
    |
128 |                       "this time."
129 |                   )
130 | /                 raise NotImplementedError(
131 | |                     msg,
132 | |                 )
    | |_________________^
133 |               distance_matrix = pairwise_distances(
134 |                   component_centroids, metric=metric_name, **metric_kwds,
    |

PLR0913 Too many arguments in function definition (11 > 5)
   --> umap/spectral.py:151:5
    |
151 | def multi_component_layout(
    |     ^^^^^^^^^^^^^^^^^^^^^^
152 |     data,
153 |     graph,
    |

D417 Missing argument description in the docstring for `multi_component_layout`: `random_state`
   --> umap/spectral.py:151:5
    |
151 | def multi_component_layout(
    |     ^^^^^^^^^^^^^^^^^^^^^^
152 |     data,
153 |     graph,
    |

D205 1 blank line required between summary line and description
   --> umap/spectral.py:164:5
    |
162 |       maxiter=0,
163 |   ):
164 | /     """Specialised layout algorithm for dealing with graphs with many connected components.
165 | |     This will first find relative positions for the components by spectrally embedding
166 | |     their centroids, then spectrally embed each individual connected component positioning
167 | |     them according to the centroid embeddings. This provides a decent embedding of each
168 | |     component while placing the components in good relative positions to one another.
169 | |
170 | |     Parameters
171 | |     ----------
172 | |     data: array of shape (n_samples, n_features)
173 | |         The source data -- required so we can generate centroids for each
174 | |         connected component of the graph.
175 | |
176 | |     graph: sparse matrix
177 | |         The adjacency matrix of the graph to be embedded.
178 | |
179 | |     n_components: int
180 | |         The number of distinct components to be layed out.
181 | |
182 | |     component_labels: array of shape (n_samples)
183 | |         For each vertex in the graph the label of the component to
184 | |         which the vertex belongs.
185 | |
186 | |     dim: int
187 | |         The chosen embedding dimension.
188 | |
189 | |     metric: string or callable (optional, default 'euclidean')
190 | |         The metric used to measure distances among the source data points.
191 | |
192 | |     metric_kwds: dict (optional, default {})
193 | |         Keyword arguments to be passed to the metric function.
194 | |
195 | |     init: string, either "random" or "tsvd"
196 | |         Indicates to initialize the eigensolver. Use "random" (the default) to
197 | |         use uniformly distributed random initialization; use "tsvd" to warm-start the
198 | |         eigensolver with singular vectors of the Laplacian associated to the largest
199 | |         singular values. This latter option also forces usage of the LOBPCG eigensolver;
200 | |         with the former, ARPACK's solver ``eigsh`` will be used for smaller Laplacians.
201 | |
202 | |     tol: float, default chosen by implementation
203 | |         Stopping tolerance for the numerical algorithm computing the embedding.
204 | |
205 | |     maxiter: int, default chosen by implementation
206 | |         Number of iterations the numerical algorithm will go through at most as it
207 | |         attempts to compute the embedding.
208 | |
209 | |     Returns
210 | |     -------
211 | |     embedding: array of shape (n_samples, dim)
212 | |         The initial embedding of ``graph``.
213 | |
214 | |     """
    | |_______^
215 |       if metric_kwds is None:
216 |           metric_kwds = {}
    |
help: Insert single blank line

PLR0913 Too many arguments in function definition (8 > 5)
   --> umap/spectral.py:271:5
    |
271 | def spectral_layout(
    |     ^^^^^^^^^^^^^^^
272 |     data,
273 |     graph,
    |

D417 Missing argument descriptions in the docstring for `spectral_layout`: `metric`, `metric_kwds`
   --> umap/spectral.py:271:5
    |
271 | def spectral_layout(
    |     ^^^^^^^^^^^^^^^
272 |     data,
273 |     graph,
    |

D205 1 blank line required between summary line and description
   --> umap/spectral.py:281:5
    |
279 |       maxiter=0,
280 |   ):
281 | /     """Given a graph compute the spectral embedding of the graph. This is
282 | |     simply the eigenvectors of the laplacian of the graph. Here we use the
283 | |     normalized laplacian.
284 | |
285 | |     Parameters
286 | |     ----------
287 | |     data: array of shape (n_samples, n_features)
288 | |         The source data
289 | |
290 | |     graph: sparse matrix
291 | |         The (weighted) adjacency matrix of the graph as a sparse matrix.
292 | |
293 | |     dim: int
294 | |         The dimension of the space into which to embed.
295 | |
296 | |     random_state: numpy RandomState or equivalent
297 | |         A state capable being used as a numpy random state.
298 | |
299 | |     tol: float, default chosen by implementation
300 | |         Stopping tolerance for the numerical algorithm computing the embedding.
301 | |
302 | |     maxiter: int, default chosen by implementation
303 | |         Number of iterations the numerical algorithm will go through at most as it
304 | |         attempts to compute the embedding.
305 | |
306 | |     Returns
307 | |     -------
308 | |     embedding: array of shape (n_vertices, dim)
309 | |         The spectral embedding of the graph.
310 | |
311 | |     """
    | |_______^
312 |       if metric_kwds is None:
313 |           metric_kwds = {}
    |
help: Insert single blank line

PLR0913 Too many arguments in function definition (9 > 5)
   --> umap/spectral.py:327:5
    |
327 | def tswspectral_layout(
    |     ^^^^^^^^^^^^^^^^^^
328 |     data,
329 |     graph,
    |

D205 1 blank line required between summary line and description
   --> umap/spectral.py:338:5
    |
336 |       maxiter=0,
337 |   ):
338 | /     """Given a graph, compute the spectral embedding of the graph. This is
339 | |     simply the eigenvectors of the Laplacian of the graph. Here we use the
340 | |     normalized laplacian and a truncated SVD-based guess of the
341 | |     eigenvectors to "warm" up the eigensolver. This function should
342 | |     give results of similar accuracy to the spectral_layout function, but
343 | |     may converge more quickly for graph Laplacians that cause
344 | |     spectral_layout to take an excessive amount of time to complete.
345 | |
346 | |     Parameters
347 | |     ----------
348 | |     data: array of shape (n_samples, n_features)
349 | |         The source data
350 | |
351 | |     graph: sparse matrix
352 | |         The (weighted) adjacency matrix of the graph as a sparse matrix.
353 | |
354 | |     dim: int
355 | |         The dimension of the space into which to embed.
356 | |
357 | |     random_state: numpy RandomState or equivalent
358 | |         A state capable being used as a numpy random state.
359 | |
360 | |     metric: string or callable (optional, default 'euclidean')
361 | |         The metric used to measure distances among the source data points.
362 | |         Used only if the multiple connected components are found in the
363 | |         graph.
364 | |
365 | |     metric_kwds: dict (optional, default {})
366 | |         Keyword arguments to be passed to the metric function.
367 | |         If metric is 'precomputed', 'linkage' keyword can be used to specify
368 | |         'average', 'complete', or 'single' linkage. Default is 'average'.
369 | |         Used only if the multiple connected components are found in the
370 | |         graph.
371 | |
372 | |     method: str (optional, default None, values either 'eigsh' or 'lobpcg')
373 | |         Name of the eigenvalue computation method to use to compute the spectral
374 | |         embedding. If left to None (or empty string), as by default, the method is
375 | |         chosen from the number of vectors in play: larger vector collections are
376 | |         handled with lobpcg, smaller collections with eigsh. Method names correspond
377 | |         to SciPy routines in scipy.sparse.linalg.
378 | |
379 | |     tol: float, default chosen by implementation
380 | |         Stopping tolerance for the numerical algorithm computing the embedding.
381 | |
382 | |     maxiter: int, default chosen by implementation
383 | |         Number of iterations the numerical algorithm will go through at most as it
384 | |         attempts to compute the embedding.
385 | |
386 | |     Returns
387 | |     -------
388 | |     embedding: array of shape (n_vertices, dim)
389 | |         The spectral embedding of the graph.
390 | |
391 | |     """
    | |_______^
392 |       if metric_kwds is None:
393 |           metric_kwds = {}
    |
help: Insert single blank line

PLR0913 Too many arguments in function definition (10 > 5)
   --> umap/spectral.py:408:5
    |
408 | def _spectral_layout(
    |     ^^^^^^^^^^^^^^^^
409 |     data,
410 |     graph,
    |

D205 1 blank line required between summary line and description
   --> umap/spectral.py:420:5
    |
418 |       maxiter=0,
419 |   ):
420 | /     """General implementation of the spectral embedding of the graph, derived as
421 | |     a subset of the eigenvectors of the normalized Laplacian of the graph. The numerical
422 | |     method for computing the eigendecomposition is chosen through heuristics.
423 | |
424 | |     Parameters
425 | |     ----------
426 | |     data: array of shape (n_samples, n_features)
427 | |         The source data
428 | |
429 | |     graph: sparse matrix
430 | |         The (weighted) adjacency matrix of the graph as a sparse matrix.
431 | |
432 | |     dim: int
433 | |         The dimension of the space into which to embed.
434 | |
435 | |     random_state: numpy RandomState or equivalent
436 | |         A state capable being used as a numpy random state.
437 | |
438 | |     metric: string or callable (optional, default 'euclidean')
439 | |         The metric used to measure distances among the source data points.
440 | |         Used only if the multiple connected components are found in the
441 | |         graph.
442 | |
443 | |     metric_kwds: dict (optional, default {})
444 | |         Keyword arguments to be passed to the metric function.
445 | |         If metric is 'precomputed', 'linkage' keyword can be used to specify
446 | |         'average', 'complete', or 'single' linkage. Default is 'average'.
447 | |         Used only if the multiple connected components are found in the
448 | |         graph.
449 | |
450 | |     init: string, either "random" or "tsvd"
451 | |         Indicates to initialize the eigensolver. Use "random" (the default) to
452 | |         use uniformly distributed random initialization; use "tsvd" to warm-start the
453 | |         eigensolver with singular vectors of the Laplacian associated to the largest
454 | |         singular values. This latter option also forces usage of the LOBPCG eigensolver;
455 | |         with the former, ARPACK's solver ``eigsh`` will be used for smaller Laplacians.
456 | |
457 | |     method: string -- either "eigsh" or "lobpcg" -- or None
458 | |         Name of the eigenvalue computation method to use to compute the spectral
459 | |         embedding. If left to None (or empty string), as by default, the method is
460 | |         chosen from the number of vectors in play: larger vector collections are
461 | |         handled with lobpcg, smaller collections with eigsh. Method names correspond
462 | |         to SciPy routines in scipy.sparse.linalg.
463 | |
464 | |     tol: float, default chosen by implementation
465 | |         Stopping tolerance for the numerical algorithm computing the embedding.
466 | |
467 | |     maxiter: int, default chosen by implementation
468 | |         Number of iterations the numerical algorithm will go through at most as it
469 | |         attempts to compute the embedding.
470 | |
471 | |     Returns
472 | |     -------
473 | |     embedding: array of shape (n_vertices, dim)
474 | |         The spectral embedding of the graph.
475 | |
476 | |     """
    | |_______^
477 |       if metric_kwds is None:
478 |           metric_kwds = {}
    |
help: Insert single blank line

ERA001 Found commented-out code
   --> umap/spectral.py:496:5
    |
494 |     sqrt_deg = np.sqrt(np.asarray(graph.sum(axis=0)).squeeze())
495 |     # standard Laplacian
496 |     # D = scipy.sparse.spdiags(diag_data, 0, graph.shape[0], graph.shape[0])
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
497 |     # L = D - graph
498 |     # Normalized Laplacian
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> umap/spectral.py:497:5
    |
495 |     # standard Laplacian
496 |     # D = scipy.sparse.spdiags(diag_data, 0, graph.shape[0], graph.shape[0])
497 |     # L = D - graph
    |     ^^^^^^^^^^^^^^^
498 |     # Normalized Laplacian
499 |     I = scipy.sparse.identity(graph.shape[0], dtype=np.float64)
    |
help: Remove commented-out code

N806 Variable `I` in function should be lowercase
   --> umap/spectral.py:499:5
    |
497 |     # L = D - graph
498 |     # Normalized Laplacian
499 |     I = scipy.sparse.identity(graph.shape[0], dtype=np.float64)
    |     ^
500 |     D = scipy.sparse.spdiags(1.0 / sqrt_deg, 0, graph.shape[0], graph.shape[0])
501 |     L = I - D * graph * D
    |

E741 Ambiguous variable name: `I`
   --> umap/spectral.py:499:5
    |
497 |     # L = D - graph
498 |     # Normalized Laplacian
499 |     I = scipy.sparse.identity(graph.shape[0], dtype=np.float64)
    |     ^
500 |     D = scipy.sparse.spdiags(1.0 / sqrt_deg, 0, graph.shape[0], graph.shape[0])
501 |     L = I - D * graph * D
    |

N806 Variable `D` in function should be lowercase
   --> umap/spectral.py:500:5
    |
498 |     # Normalized Laplacian
499 |     I = scipy.sparse.identity(graph.shape[0], dtype=np.float64)
500 |     D = scipy.sparse.spdiags(1.0 / sqrt_deg, 0, graph.shape[0], graph.shape[0])
    |     ^
501 |     L = I - D * graph * D
502 |     if not scipy.sparse.issparse(L):
    |

N806 Variable `L` in function should be lowercase
   --> umap/spectral.py:501:5
    |
499 |     I = scipy.sparse.identity(graph.shape[0], dtype=np.float64)
500 |     D = scipy.sparse.spdiags(1.0 / sqrt_deg, 0, graph.shape[0], graph.shape[0])
501 |     L = I - D * graph * D
    |     ^
502 |     if not scipy.sparse.issparse(L):
503 |         L = np.asarray(L)
    |

N806 Variable `L` in function should be lowercase
   --> umap/spectral.py:503:9
    |
501 |     L = I - D * graph * D
502 |     if not scipy.sparse.issparse(L):
503 |         L = np.asarray(L)
    |         ^
504 |
505 |     k = dim + 1
    |

PLR2004 Magic value used in comparison, consider replacing `2000000` with a constant variable
   --> umap/spectral.py:513:42
    |
511 |     )
512 |     if not method:
513 |         method = "eigsh" if L.shape[0] < 2000000 else "lobpcg"
    |                                          ^^^^^^^
514 |
515 |     try:
    |

N806 Variable `X` in function should be lowercase
   --> umap/spectral.py:517:13
    |
515 |     try:
516 |         if init == "random":
517 |             X = gen.normal(size=(L.shape[0], k))
    |             ^
518 |         elif init == "tsvd":
519 |             X = TruncatedSVD(
    |

N806 Variable `X` in function should be lowercase
   --> umap/spectral.py:519:13
    |
517 |             X = gen.normal(size=(L.shape[0], k))
518 |         elif init == "tsvd":
519 |             X = TruncatedSVD(
    |             ^
520 |                 n_components=k,
521 |                 random_state=random_state,
    |

ERA001 Found commented-out code
   --> umap/spectral.py:522:17
    |
520 |                 n_components=k,
521 |                 random_state=random_state,
522 |                 # algorithm="arpack"
    |                 ^^^^^^^^^^^^^^^^^^^^
523 |             ).fit_transform(L)
524 |         else:
    |
help: Remove commented-out code

NPY002 Replace legacy `np.random.seed` call with `np.random.Generator`
  --> umap/tests/conftest.py:14:1
   |
12 | # Globals, used for all the tests
13 | SEED = 189212  # 0b101110001100011100
14 | np.random.seed(SEED)
   | ^^^^^^^^^^^^^^
   |

D103 Missing docstring in public function
  --> umap/tests/conftest.py:20:5
   |
18 | # -----------------------
19 | @pytest.fixture(scope="session")
20 | def spatial_data():
   |     ^^^^^^^^^^^^
21 |     # - Spatial Data
22 |     spatial_data = np.random.randn(10, 20)
   |

NPY002 Replace legacy `np.random.randn` call with `np.random.Generator`
  --> umap/tests/conftest.py:22:20
   |
20 | def spatial_data():
21 |     # - Spatial Data
22 |     spatial_data = np.random.randn(10, 20)
   |                    ^^^^^^^^^^^^^^^
23 |     # Add some all zero data for corner case test
24 |     return np.vstack([spatial_data, np.zeros((2, 20))])
   |

D103 Missing docstring in public function
  --> umap/tests/conftest.py:28:5
   |
27 | @pytest.fixture(scope="session")
28 | def binary_data():
   |     ^^^^^^^^^^^
29 |     binary_data = np.random.choice(a=[False, True], size=(10, 20), p=[0.66, 1 - 0.66])
30 |     # Add some all zero data for corner case test
   |

NPY002 Replace legacy `np.random.choice` call with `np.random.Generator`
  --> umap/tests/conftest.py:29:19
   |
27 | @pytest.fixture(scope="session")
28 | def binary_data():
29 |     binary_data = np.random.choice(a=[False, True], size=(10, 20), p=[0.66, 1 - 0.66])
   |                   ^^^^^^^^^^^^^^^^
30 |     # Add some all zero data for corner case test
31 |     return np.vstack([binary_data, np.zeros((2, 20), dtype="bool")])
   |

D103 Missing docstring in public function
  --> umap/tests/conftest.py:37:5
   |
35 | # ------------------------------
36 | @pytest.fixture(scope="session")
37 | def sparse_spatial_data(spatial_data, binary_data):
   |     ^^^^^^^^^^^^^^^^^^^
38 |     return sparse.csr_matrix(spatial_data * binary_data)
   |

D103 Missing docstring in public function
  --> umap/tests/conftest.py:42:5
   |
41 | @pytest.fixture(scope="session")
42 | def sparse_binary_data(binary_data):
   |     ^^^^^^^^^^^^^^^^^^
43 |     return sparse.csr_matrix(binary_data)
   |

D103 Missing docstring in public function
  --> umap/tests/conftest.py:49:5
   |
47 | # -----------------------
48 | @pytest.fixture(scope="session")
49 | def nn_data():
   |     ^^^^^^^
50 |     nn_data = np.random.uniform(0, 1, size=(1000, 5))
51 |     return np.vstack(
   |

NPY002 Replace legacy `np.random.uniform` call with `np.random.Generator`
  --> umap/tests/conftest.py:50:15
   |
48 | @pytest.fixture(scope="session")
49 | def nn_data():
50 |     nn_data = np.random.uniform(0, 1, size=(1000, 5))
   |               ^^^^^^^^^^^^^^^^^
51 |     return np.vstack(
52 |         [nn_data, np.zeros((2, 5))],
   |

D103 Missing docstring in public function
  --> umap/tests/conftest.py:57:5
   |
56 | @pytest.fixture(scope="session")
57 | def binary_nn_data():
   |     ^^^^^^^^^^^^^^
58 |     binary_nn_data = np.random.choice(
59 |         a=[False, True], size=(1000, 5), p=[0.66, 1 - 0.66],
   |

NPY002 Replace legacy `np.random.choice` call with `np.random.Generator`
  --> umap/tests/conftest.py:58:22
   |
56 | @pytest.fixture(scope="session")
57 | def binary_nn_data():
58 |     binary_nn_data = np.random.choice(
   |                      ^^^^^^^^^^^^^^^^
59 |         a=[False, True], size=(1000, 5), p=[0.66, 1 - 0.66],
60 |     )
   |

D103 Missing docstring in public function
  --> umap/tests/conftest.py:67:5
   |
66 | @pytest.fixture(scope="session")
67 | def sparse_nn_data():
   |     ^^^^^^^^^^^^^^
68 |     return sparse.random(1000, 50, density=0.5, format="csr")
   |

D103 Missing docstring in public function
  --> umap/tests/conftest.py:76:5
   |
75 | @pytest.fixture(scope="session")
76 | def repetition_dense():
   |     ^^^^^^^^^^^^^^^^
77 |     # Dense data for testing small n
78 |     return np.array(
   |

D103 Missing docstring in public function
  --> umap/tests/conftest.py:94:5
   |
93 | @pytest.fixture(scope="session")
94 | def spatial_repeats(spatial_data):
   |     ^^^^^^^^^^^^^^^
95 |     # spatial data repeats
96 |     return np.vstack(
   |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:104:5
    |
103 | @pytest.fixture(scope="session")
104 | def binary_repeats(binary_data):
    |     ^^^^^^^^^^^^^^
105 |     return np.vstack(
106 |         [
    |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:116:5
    |
115 | @pytest.fixture(scope="session")
116 | def sparse_spatial_data_repeats(spatial_repeats, binary_repeats):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
117 |     return sparse.csr_matrix(spatial_repeats * binary_repeats)
    |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:121:5
    |
120 | @pytest.fixture(scope="session")
121 | def sparse_binary_data_repeats(binary_repeats):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
122 |     return sparse.csr_matrix(binary_repeats)
    |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:126:5
    |
125 | @pytest.fixture(scope="session")
126 | def sparse_test_data(nn_data, binary_nn_data):
    |     ^^^^^^^^^^^^^^^^
127 |     return sparse.csr_matrix(nn_data * binary_nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:131:5
    |
130 | @pytest.fixture(scope="session")
131 | def iris():
    |     ^^^^
132 |     return load_iris()
    |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:136:5
    |
135 | @pytest.fixture(scope="session")
136 | def iris_selection():
    |     ^^^^^^^^^^^^^^
137 |     return np.random.choice([True, False], 150, replace=True, p=[0.75, 0.25])
    |

NPY002 Replace legacy `np.random.choice` call with `np.random.Generator`
   --> umap/tests/conftest.py:137:12
    |
135 | @pytest.fixture(scope="session")
136 | def iris_selection():
137 |     return np.random.choice([True, False], 150, replace=True, p=[0.75, 0.25])
    |            ^^^^^^^^^^^^^^^^
    |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:141:5
    |
140 | @pytest.fixture(scope="session")
141 | def aligned_iris(iris):
    |     ^^^^^^^^^^^^
142 |     slices = [iris.data[i : i + 50] for i in range(0, 125, 25)]
143 |     target = [iris.target[i : i + 50] for i in range(0, 125, 25)]
    |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:148:5
    |
147 | @pytest.fixture(scope="session")
148 | def aligned_iris_relations():
    |     ^^^^^^^^^^^^^^^^^^^^^^
149 |     return [{a: a + 25 for a in range(25)} for i in range(4)]
    |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:153:5
    |
152 | @pytest.fixture(scope="session")
153 | def iris_model(iris):
    |     ^^^^^^^^^^
154 |     return UMAP(n_neighbors=10, min_dist=0.01, random_state=42).fit(iris.data)
    |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:158:5
    |
157 | @pytest.fixture(scope="session")
158 | def iris_model_large(iris):
    |     ^^^^^^^^^^^^^^^^
159 |     return UMAP(
160 |         n_neighbors=10,
    |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:168:5
    |
167 | @pytest.fixture(scope="session")
168 | def iris_subset_model(iris, iris_selection):
    |     ^^^^^^^^^^^^^^^^^
169 |     return UMAP(n_neighbors=10, min_dist=0.01, random_state=42).fit(
170 |         iris.data[iris_selection],
    |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:175:5
    |
174 | @pytest.fixture(scope="session")
175 | def iris_subset_model_large(iris, iris_selection):
    |     ^^^^^^^^^^^^^^^^^^^^^^^
176 |     return UMAP(
177 |         n_neighbors=10,
    |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:185:5
    |
184 | @pytest.fixture(scope="session")
185 | def supervised_iris_model(iris):
    |     ^^^^^^^^^^^^^^^^^^^^^
186 |     return UMAP(n_neighbors=10, min_dist=0.01, n_epochs=200, random_state=42).fit(
187 |         iris.data, iris.target,
    |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:192:5
    |
191 | @pytest.fixture(scope="session")
192 | def aligned_iris_model(aligned_iris, aligned_iris_relations):
    |     ^^^^^^^^^^^^^^^^^^
193 |     data, _target = aligned_iris
194 |     model = AlignedUMAP()
    |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:202:5
    |
200 | # ---------------------
201 | @pytest.fixture(scope="session")
202 | def spatial_distances():
    |     ^^^^^^^^^^^^^^^^^
203 |     return (
204 |         "euclidean",
    |

D103 Missing docstring in public function
   --> umap/tests/conftest.py:217:5
    |
216 | @pytest.fixture(scope="session")
217 | def binary_distances():
    |     ^^^^^^^^^^^^^^^^
218 |     return (
219 |         "jaccard",
    |

D103 Missing docstring in public function
  --> umap/tests/test_aligned_umap.py:13:5
   |
13 | def nn_accuracy(true_nn, embd_nn):
   |     ^^^^^^^^^^^
14 |     num_correct = 0.0
15 |     for i in range(true_nn.shape[0]):
   |

D103 Missing docstring in public function
  --> umap/tests/test_aligned_umap.py:20:5
   |
20 | def test_neighbor_local_neighbor_accuracy(aligned_iris, aligned_iris_model):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
21 |     data, _target = aligned_iris
22 |     for i, slice in enumerate(data):
   |

A001 Variable `slice` is shadowing a Python builtin
  --> umap/tests/test_aligned_umap.py:22:12
   |
20 | def test_neighbor_local_neighbor_accuracy(aligned_iris, aligned_iris_model):
21 |     data, _target = aligned_iris
22 |     for i, slice in enumerate(data):
   |            ^^^^^
23 |         data_dmat = pairwise_distances(slice)
24 |         true_nn = np.argsort(data_dmat, axis=1)[:, :10]
   |

PLR2004 Magic value used in comparison, consider replacing `0.65` with a constant variable
  --> umap/tests/test_aligned_umap.py:27:49
   |
25 |         embd_dmat = pairwise_distances(aligned_iris_model.embeddings_[i])
26 |         embd_nn = np.argsort(embd_dmat, axis=1)[:, :10]
27 |         assert nn_accuracy(true_nn, embd_nn) >= 0.65
   |                                                 ^^^^
   |

D103 Missing docstring in public function
  --> umap/tests/test_aligned_umap.py:30:5
   |
30 | def test_local_clustering(aligned_iris, aligned_iris_model):
   |     ^^^^^^^^^^^^^^^^^^^^^
31 |     _data, target = aligned_iris
   |

PLR2004 Magic value used in comparison, consider replacing `0.75` with a constant variable
  --> umap/tests/test_aligned_umap.py:36:19
   |
34 |     clusters = KMeans(n_clusters=2).fit_predict(embd)
35 |     ari = adjusted_rand_score(target[1], clusters)
36 |     assert ari >= 0.75
   |                   ^^^^
37 |
38 |     embd = aligned_iris_model.embeddings_[3]
   |

PLR2004 Magic value used in comparison, consider replacing `0.40` with a constant variable
  --> umap/tests/test_aligned_umap.py:41:19
   |
39 |     clusters = KMeans(n_clusters=2).fit_predict(embd)
40 |     ari = adjusted_rand_score(target[3], clusters)
41 |     assert ari >= 0.40
   |                   ^^^^
   |

D103 Missing docstring in public function
  --> umap/tests/test_aligned_umap.py:44:5
   |
44 | def test_aligned_update(aligned_iris, aligned_iris_relations):
   |     ^^^^^^^^^^^^^^^^^^^
45 |     data, _target = aligned_iris
46 |     small_aligned_model = AlignedUMAP()
   |

A001 Variable `slice` is shadowing a Python builtin
  --> umap/tests/test_aligned_umap.py:49:12
   |
47 |     small_aligned_model.fit(data[:3], relations=aligned_iris_relations[:2])
48 |     small_aligned_model.update(data[3], relations=aligned_iris_relations[2])
49 |     for i, slice in enumerate(data[:4]):
   |            ^^^^^
50 |         data_dmat = pairwise_distances(slice)
51 |         true_nn = np.argsort(data_dmat, axis=1)[:, :10]
   |

PLR2004 Magic value used in comparison, consider replacing `0.45` with a constant variable
  --> umap/tests/test_aligned_umap.py:54:49
   |
52 |         embd_dmat = pairwise_distances(small_aligned_model.embeddings_[i])
53 |         embd_nn = np.argsort(embd_dmat, axis=1)[:, :10]
54 |         assert nn_accuracy(true_nn, embd_nn) >= 0.45
   |                                                 ^^^^
   |

D103 Missing docstring in public function
  --> umap/tests/test_aligned_umap.py:57:5
   |
57 | def test_aligned_update_params(aligned_iris, aligned_iris_relations):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
58 |     data, _target = aligned_iris
59 |     n_neighbors = [15, 15, 15, 15, 15]
   |

A001 Variable `slice` is shadowing a Python builtin
  --> umap/tests/test_aligned_umap.py:65:12
   |
63 |         data[3], relations=aligned_iris_relations[2], n_neighbors=n_neighbors[3],
64 |     )
65 |     for i, slice in enumerate(data[:4]):
   |            ^^^^^
66 |         data_dmat = pairwise_distances(slice)
67 |         true_nn = np.argsort(data_dmat, axis=1)[:, :10]
   |

PLR2004 Magic value used in comparison, consider replacing `0.45` with a constant variable
  --> umap/tests/test_aligned_umap.py:70:49
   |
68 |         embd_dmat = pairwise_distances(small_aligned_model.embeddings_[i])
69 |         embd_nn = np.argsort(embd_dmat, axis=1)[:, :10]
70 |         assert nn_accuracy(true_nn, embd_nn) >= 0.45
   |                                                 ^^^^
   |

D103 Missing docstring in public function
  --> umap/tests/test_aligned_umap.py:74:5
   |
73 | @pytest.mark.skip(reason="Temporarily disable")
74 | def test_aligned_update_array_error(aligned_iris, aligned_iris_relations):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
75 |     data, _target = aligned_iris
76 |     n_neighbors = [15, 15, 15, 15, 15]
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_aligned_umap.py:80:24
   |
78 |     small_aligned_model.fit(data[:3], relations=aligned_iris_relations[:2])
79 |
80 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
81 |         small_aligned_model.update(
82 |             data[3:], relations=aligned_iris_relations[2:], n_neighbors=n_neighbors[3:],
   |

C901 `stashed_previous_impl_for_regression_test` is too complex (16 > 10)
  --> umap/tests/test_chunked_parallel_spatial_metric.py:24:5
   |
23 | @pytest.fixture
24 | def stashed_previous_impl_for_regression_test():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |     @numba.njit(parallel=True, nogil=True)
26 |     def stashed_chunked_parallel_special_metric(
   |

D103 Missing docstring in public function
  --> umap/tests/test_chunked_parallel_spatial_metric.py:24:5
   |
23 | @pytest.fixture
24 | def stashed_previous_impl_for_regression_test():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |     @numba.njit(parallel=True, nogil=True)
26 |     def stashed_chunked_parallel_special_metric(
   |

C901 `stashed_chunked_parallel_special_metric` is too complex (15 > 10)
  --> umap/tests/test_chunked_parallel_spatial_metric.py:26:9
   |
24 | def stashed_previous_impl_for_regression_test():
25 |     @numba.njit(parallel=True, nogil=True)
26 |     def stashed_chunked_parallel_special_metric(
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
27 |         X, Y=None, metric=dist.named_distances["hellinger"], chunk_size=16,
28 |     ):
   |

PLR0912 Too many branches (17 > 12)
  --> umap/tests/test_chunked_parallel_spatial_metric.py:26:9
   |
24 | def stashed_previous_impl_for_regression_test():
25 |     @numba.njit(parallel=True, nogil=True)
26 |     def stashed_chunked_parallel_special_metric(
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
27 |         X, Y=None, metric=dist.named_distances["hellinger"], chunk_size=16,
28 |     ):
   |

N803 Argument name `X` should be lowercase
  --> umap/tests/test_chunked_parallel_spatial_metric.py:27:9
   |
25 |     @numba.njit(parallel=True, nogil=True)
26 |     def stashed_chunked_parallel_special_metric(
27 |         X, Y=None, metric=dist.named_distances["hellinger"], chunk_size=16,
   |         ^
28 |     ):
29 |         if Y is None:
   |

N803 Argument name `Y` should be lowercase
  --> umap/tests/test_chunked_parallel_spatial_metric.py:27:12
   |
25 |     @numba.njit(parallel=True, nogil=True)
26 |     def stashed_chunked_parallel_special_metric(
27 |         X, Y=None, metric=dist.named_distances["hellinger"], chunk_size=16,
   |            ^^^^^^
28 |     ):
29 |         if Y is None:
   |

C901 `workaround_590_impl` is too complex (15 > 10)
  --> umap/tests/test_chunked_parallel_spatial_metric.py:74:5
   |
73 | @pytest.fixture
74 | def workaround_590_impl():
   |     ^^^^^^^^^^^^^^^^^^^
75 |     @numba.njit(parallel=True, nogil=True)
76 |     def chunked_parallel_special_metric(
   |

D103 Missing docstring in public function
  --> umap/tests/test_chunked_parallel_spatial_metric.py:74:5
   |
73 | @pytest.fixture
74 | def workaround_590_impl():
   |     ^^^^^^^^^^^^^^^^^^^
75 |     @numba.njit(parallel=True, nogil=True)
76 |     def chunked_parallel_special_metric(
   |

C901 `chunked_parallel_special_metric` is too complex (14 > 10)
  --> umap/tests/test_chunked_parallel_spatial_metric.py:76:9
   |
74 | def workaround_590_impl():
75 |     @numba.njit(parallel=True, nogil=True)
76 |     def chunked_parallel_special_metric(
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
77 |         X, Y=None, metric=dist.named_distances["hellinger"], chunk_size=16,
78 |     ):
   |

PLR0912 Too many branches (14 > 12)
  --> umap/tests/test_chunked_parallel_spatial_metric.py:76:9
   |
74 | def workaround_590_impl():
75 |     @numba.njit(parallel=True, nogil=True)
76 |     def chunked_parallel_special_metric(
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
77 |         X, Y=None, metric=dist.named_distances["hellinger"], chunk_size=16,
78 |     ):
   |

N803 Argument name `X` should be lowercase
  --> umap/tests/test_chunked_parallel_spatial_metric.py:77:9
   |
75 |     @numba.njit(parallel=True, nogil=True)
76 |     def chunked_parallel_special_metric(
77 |         X, Y=None, metric=dist.named_distances["hellinger"], chunk_size=16,
   |         ^
78 |     ):
79 |         if Y is None:
   |

N803 Argument name `Y` should be lowercase
  --> umap/tests/test_chunked_parallel_spatial_metric.py:77:12
   |
75 |     @numba.njit(parallel=True, nogil=True)
76 |     def chunked_parallel_special_metric(
77 |         X, Y=None, metric=dist.named_distances["hellinger"], chunk_size=16,
   |            ^^^^^^
78 |     ):
79 |         if Y is None:
   |

D103 Missing docstring in public function
   --> umap/tests/test_chunked_parallel_spatial_metric.py:123:5
    |
122 | @pytest.fixture
123 | def benchmark_data(request):
    |     ^^^^^^^^^^^^^^
124 |     shape = request.param
125 |     spatial_data = np.random.randn(*shape).astype(np.float32)
    |

NPY002 Replace legacy `np.random.randn` call with `np.random.Generator`
   --> umap/tests/test_chunked_parallel_spatial_metric.py:125:20
    |
123 | def benchmark_data(request):
124 |     shape = request.param
125 |     spatial_data = np.random.randn(*shape).astype(np.float32)
    |                    ^^^^^^^^^^^^^^^
126 |     return np.abs(spatial_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_chunked_parallel_spatial_metric.py:133:5
    |
132 | @benchmark_only
133 | def test_chunked_parallel_alternative_implementations(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
134 |     spatial_data, workaround_590_impl,
135 | ):
    |

D103 Missing docstring in public function
   --> umap/tests/test_chunked_parallel_spatial_metric.py:161:5
    |
160 | @benchmark_only
161 | def test_chunked_parallel_special_metric_implementation_hellinger(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
162 |     spatial_data,
163 |     stashed_previous_impl_for_regression_test,
    |

NPY002 Replace legacy `np.random.randn` call with `np.random.Generator`
   --> umap/tests/test_chunked_parallel_spatial_metric.py:214:24
    |
213 |     # test hellinger on different X and Y Pair
214 |     spatial_data_two = np.random.randn(10, 20)
    |                        ^^^^^^^^^^^^^^^
215 |     dist_stashed_diff_pair = stashed_previous_impl_for_regression_test(
216 |         np.abs(spatial_data[:-2]), spatial_data_two,
    |

D103 Missing docstring in public function
   --> umap/tests/test_chunked_parallel_spatial_metric.py:244:5
    |
242 |     indirect=["benchmark_data"],
243 | )
244 | def test_benchmark_chunked_parallel_special_metric_x_only(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
245 |     benchmark,
246 |     benchmark_data,
    |

D103 Missing docstring in public function
   --> umap/tests/test_chunked_parallel_spatial_metric.py:268:5
    |
266 |     indirect=["benchmark_data"],
267 | )
268 | def test_benchmark_workaround_590_x_only(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
269 |     benchmark,
270 |     benchmark_data,
    |

D103 Missing docstring in public function
   --> umap/tests/test_chunked_parallel_spatial_metric.py:298:5
    |
296 |     indirect=["benchmark_data"],
297 | )
298 | def test_benchmark_chunked_parallel_special_metric_x_y(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
299 |     benchmark,
300 |     benchmark_data,
    |

D103 Missing docstring in public function
   --> umap/tests/test_chunked_parallel_spatial_metric.py:322:5
    |
320 |     indirect=["benchmark_data"],
321 | )
322 | def test_benchmark_workaround_590_x_y(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
323 |     benchmark,
324 |     benchmark_data,
    |

D103 Missing docstring in public function
  --> umap/tests/test_composite_models.py:16:5
   |
16 | def test_composite_trustworthiness(nn_data, iris_model):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
17 |     data = nn_data[:50]
18 |     model1 = UMAP(n_neighbors=10, min_dist=0.01, random_state=42, n_epochs=50).fit(data)
   |

PLR2004 Magic value used in comparison, consider replacing `0.80` with a constant variable
  --> umap/tests/test_composite_models.py:29:18
   |
27 |     trust = trustworthiness(data, model3.embedding_, n_neighbors=10)
28 |     assert (
29 |         trust >= 0.80
   |                  ^^^^
30 |     ), f"Insufficiently trustworthy embedding fornn dataset: {trust}"
31 |     model4 = model1 + model2
   |

PLR2004 Magic value used in comparison, consider replacing `0.80` with a constant variable
  --> umap/tests/test_composite_models.py:34:18
   |
32 |     trust = trustworthiness(data, model4.embedding_, n_neighbors=10)
33 |     assert (
34 |         trust >= 0.80
   |                  ^^^^
35 |     ), f"Insufficiently trustworthy embedding fornn dataset: {trust}"
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_composite_models.py:37:24
   |
35 |     ), f"Insufficiently trustworthy embedding fornn dataset: {trust}"
36 |
37 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
38 |         _ = model1 + iris_model
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_composite_models.py:40:24
   |
38 |         _ = model1 + iris_model
39 |
40 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
41 |         _ = model1 * iris_model
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_composite_models.py:43:24
   |
41 |         _ = model1 * iris_model
42 |
43 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
44 |         _ = model1 - iris_model
   |

D103 Missing docstring in public function
  --> umap/tests/test_composite_models.py:48:5
   |
47 | @pytest.mark.skip(reason="Marked as Skipped test")
48 | def test_composite_trustworthiness_random_init(nn_data):  # pragma: no cover
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
49 |     data = nn_data[:50]
50 |     model1 = UMAP(
   |

PLR2004 Magic value used in comparison, consider replacing `0.82` with a constant variable
  --> umap/tests/test_composite_models.py:67:18
   |
65 |     trust = trustworthiness(data, model3.embedding_, n_neighbors=10)
66 |     assert (
67 |         trust >= 0.82
   |                  ^^^^
68 |     ), f"Insufficiently trustworthy embedding fornn dataset: {trust}"
69 |     model4 = model1 + model2
   |

PLR2004 Magic value used in comparison, consider replacing `0.82` with a constant variable
  --> umap/tests/test_composite_models.py:72:18
   |
70 |     trust = trustworthiness(data, model4.embedding_, n_neighbors=10)
71 |     assert (
72 |         trust >= 0.82
   |                  ^^^^
73 |     ), f"Insufficiently trustworthy embedding fornn dataset: {trust}"
   |

D103 Missing docstring in public function
  --> umap/tests/test_composite_models.py:76:5
   |
76 | def test_composite_trustworthiness_on_iris(iris):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
77 |     iris_model1 = UMAP(
78 |         n_neighbors=10,
   |

PLR2004 Magic value used in comparison, consider replacing `0.82` with a constant variable
  --> umap/tests/test_composite_models.py:92:18
   |
90 |     trust = trustworthiness(iris.data, embedding, n_neighbors=10)
91 |     assert (
92 |         trust >= 0.82
   |                  ^^^^
93 |     ), f"Insufficiently trustworthy embedding foriris dataset: {trust}"
94 |     embedding = (iris_model1 * iris_model2).embedding_
   |

PLR2004 Magic value used in comparison, consider replacing `0.82` with a constant variable
  --> umap/tests/test_composite_models.py:97:18
   |
95 |     trust = trustworthiness(iris.data, embedding, n_neighbors=10)
96 |     assert (
97 |         trust >= 0.82
   |                  ^^^^
98 |     ), f"Insufficiently trustworthy embedding foriris dataset: {trust}"
   |

D103 Missing docstring in public function
   --> umap/tests/test_composite_models.py:101:5
    |
101 | def test_contrastive_trustworthiness_on_iris(iris):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
102 |     iris_model1 = UMAP(
103 |         n_neighbors=10,
    |

PLR2004 Magic value used in comparison, consider replacing `0.75` with a constant variable
   --> umap/tests/test_composite_models.py:117:18
    |
115 |     trust = trustworthiness(iris.data, embedding, n_neighbors=10)
116 |     assert (
117 |         trust >= 0.75
    |                  ^^^^
118 |     ), f"Insufficiently trustworthy embedding foriris dataset: {trust}"
    |

D103 Missing docstring in public function
  --> umap/tests/test_data_input.py:9:5
   |
 8 | @pytest.fixture(scope="session")
 9 | def all_finite_data():
   |     ^^^^^^^^^^^^^^^
10 |     return np.arange(100.0).reshape(25, 4)
   |

D103 Missing docstring in public function
  --> umap/tests/test_data_input.py:14:5
   |
13 | @pytest.fixture(scope="session")
14 | def inverse_data():
   |     ^^^^^^^^^^^^
15 |     return np.arange(50).reshape(25, 2)
   |

D103 Missing docstring in public function
  --> umap/tests/test_data_input.py:19:5
   |
18 | @njit
19 | def nan_dist(a: np.ndarray, b: np.ndarray):
   |     ^^^^^^^^
20 |     a[0] = np.nan
21 |     a[1] = np.inf
   |

ARG001 Unused function argument: `b`
  --> umap/tests/test_data_input.py:19:29
   |
18 | @njit
19 | def nan_dist(a: np.ndarray, b: np.ndarray):
   |                             ^
20 |     a[0] = np.nan
21 |     a[1] = np.inf
   |

D417 Missing argument descriptions in the docstring for `test_check_input_data`: `all_finite_data`, `inverse_data`
  --> umap/tests/test_data_input.py:25:5
   |
25 | def test_check_input_data(all_finite_data, inverse_data):
   |     ^^^^^^^^^^^^^^^^^^^^^
26 |     """Data input to UMAP gets checked for liability.
27 |     This tests checks the if data input is dismissed/accepted
   |

D205 1 blank line required between summary line and description
  --> umap/tests/test_data_input.py:26:5
   |
25 |   def test_check_input_data(all_finite_data, inverse_data):
26 | /     """Data input to UMAP gets checked for liability.
27 | |     This tests checks the if data input is dismissed/accepted
28 | |     according to the "ensure_all_finite" keyword as used by
29 | |     sklearn.
30 | |
31 | |     Parameters
32 | |     ----------
33 | |     all_finite_data
34 | |     inverse_data
35 | |     -------
36 | |
37 | |     """
   | |_______^
38 |       inf_data = all_finite_data.copy()
39 |       inf_data[0] = np.inf
   |
help: Insert single blank line

FBT003 Boolean positional value in function call
  --> umap/tests/test_data_input.py:64:42
   |
62 |     # Check whether correct data input is accepted
63 |     call_umap_functions(all_finite_data, None)
64 |     call_umap_functions(all_finite_data, True)
   |                                          ^^^^
65 |
66 |     call_umap_functions(nan_data, "allow-nan")
   |

FBT003 Boolean positional value in function call
  --> umap/tests/test_data_input.py:69:35
   |
67 |     call_umap_functions(all_finite_data, "allow-nan")
68 |
69 |     call_umap_functions(inf_data, False)
   |                                   ^^^^^
70 |     call_umap_functions(inf_nan_data, False)
71 |     call_umap_functions(nan_data, False)
   |

FBT003 Boolean positional value in function call
  --> umap/tests/test_data_input.py:70:39
   |
69 |     call_umap_functions(inf_data, False)
70 |     call_umap_functions(inf_nan_data, False)
   |                                       ^^^^^
71 |     call_umap_functions(nan_data, False)
72 |     call_umap_functions(all_finite_data, False)
   |

FBT003 Boolean positional value in function call
  --> umap/tests/test_data_input.py:71:35
   |
69 |     call_umap_functions(inf_data, False)
70 |     call_umap_functions(inf_nan_data, False)
71 |     call_umap_functions(nan_data, False)
   |                                   ^^^^^
72 |     call_umap_functions(all_finite_data, False)
   |

FBT003 Boolean positional value in function call
  --> umap/tests/test_data_input.py:72:42
   |
70 |     call_umap_functions(inf_nan_data, False)
71 |     call_umap_functions(nan_data, False)
72 |     call_umap_functions(all_finite_data, False)
   |                                          ^^^^^
73 |
74 |     # Check whether illegal data raises a ValueError
   |

PT012 `pytest.raises()` block should contain a single simple statement
  --> umap/tests/test_data_input.py:75:5
   |
74 |       # Check whether illegal data raises a ValueError
75 | /     with pytest.raises(ValueError):
76 | |         call_umap_functions(nan_data, None)
77 | |         call_umap_functions(inf_data, None)
78 | |         call_umap_functions(inf_nan_data, None)
79 | |
80 | |         call_umap_functions(nan_data, True)
81 | |         call_umap_functions(inf_data, True)
82 | |         call_umap_functions(inf_nan_data, True)
83 | |
84 | |         call_umap_functions(inf_data, "allow-nan")
85 | |         call_umap_functions(inf_nan_data, "allow-nan")
   | |______________________________________________________^
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_data_input.py:75:24
   |
74 |     # Check whether illegal data raises a ValueError
75 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
76 |         call_umap_functions(nan_data, None)
77 |         call_umap_functions(inf_data, None)
   |

FBT003 Boolean positional value in function call
  --> umap/tests/test_data_input.py:80:39
   |
78 |         call_umap_functions(inf_nan_data, None)
79 |
80 |         call_umap_functions(nan_data, True)
   |                                       ^^^^
81 |         call_umap_functions(inf_data, True)
82 |         call_umap_functions(inf_nan_data, True)
   |

FBT003 Boolean positional value in function call
  --> umap/tests/test_data_input.py:81:39
   |
80 |         call_umap_functions(nan_data, True)
81 |         call_umap_functions(inf_data, True)
   |                                       ^^^^
82 |         call_umap_functions(inf_nan_data, True)
   |

FBT003 Boolean positional value in function call
  --> umap/tests/test_data_input.py:82:43
   |
80 |         call_umap_functions(nan_data, True)
81 |         call_umap_functions(inf_data, True)
82 |         call_umap_functions(inf_nan_data, True)
   |                                           ^^^^
83 |
84 |         call_umap_functions(inf_data, "allow-nan")
   |

D103 Missing docstring in public function
  --> umap/tests/test_densmap.py:16:5
   |
16 | def test_densmap_trustworthiness(nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
17 |     data = nn_data[:50]
18 |     embedding, _rad_h, _rad_l = UMAP(
   |

PLR2004 Magic value used in comparison, consider replacing `0.72` with a constant variable
  --> umap/tests/test_densmap.py:28:18
   |
26 |     trust = trustworthiness(data, embedding, n_neighbors=10)
27 |     assert (
28 |         trust >= 0.72
   |                  ^^^^
29 |     ), f"Insufficiently trustworthy embedding fornn dataset: {trust}"
   |

D103 Missing docstring in public function
  --> umap/tests/test_densmap.py:33:5
   |
32 | @pytest.mark.skip
33 | def test_densmap_trustworthiness_random_init(nn_data):  # pragma: no cover
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
34 |     data = nn_data[:50]
35 |     embedding = UMAP(
   |

PLR2004 Magic value used in comparison, consider replacing `0.75` with a constant variable
  --> umap/tests/test_densmap.py:44:18
   |
42 |     trust = trustworthiness(data, embedding, n_neighbors=10)
43 |     assert (
44 |         trust >= 0.75
   |                  ^^^^
45 |     ), f"Insufficiently trustworthy embedding fornn dataset: {trust}"
   |

D103 Missing docstring in public function
  --> umap/tests/test_densmap.py:48:5
   |
48 | def test_densmap_trustworthiness_on_iris(iris):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
49 |     densmap_iris_model = UMAP(
50 |         n_neighbors=10,
   |

PLR2004 Magic value used in comparison, consider replacing `0.97` with a constant variable
  --> umap/tests/test_densmap.py:59:18
   |
57 |     trust = trustworthiness(iris.data, embedding, n_neighbors=10)
58 |     assert (
59 |         trust >= 0.97
   |                  ^^^^
60 |     ), f"Insufficiently trustworthy embedding foriris dataset: {trust}"
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_densmap.py:65:24
   |
63 |         densmap_iris_model.transform(iris.data[:10])
64 |
65 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
66 |         densmap_iris_model.inverse_transform(embedding[:10])
   |

D103 Missing docstring in public function
  --> umap/tests/test_densmap.py:69:5
   |
69 | def test_densmap_trustworthiness_on_iris_supervised(iris):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
70 |     densmap_iris_model = UMAP(
71 |         n_neighbors=10,
   |

PLR2004 Magic value used in comparison, consider replacing `0.97` with a constant variable
  --> umap/tests/test_densmap.py:80:18
   |
78 |     trust = trustworthiness(iris.data, embedding, n_neighbors=10)
79 |     assert (
80 |         trust >= 0.97
   |                  ^^^^
81 |     ), f"Insufficiently trustworthy embedding foriris dataset: {trust}"
   |

D103 Missing docstring in public function
  --> umap/tests/test_parametric_umap.py:26:5
   |
25 | @pytest.fixture(scope="session")
26 | def moon_dataset():
   |     ^^^^^^^^^^^^
27 |     X, _ = make_moons(200)
28 |     return X
   |

N806 Variable `X` in function should be lowercase
  --> umap/tests/test_parametric_umap.py:27:5
   |
25 | @pytest.fixture(scope="session")
26 | def moon_dataset():
27 |     X, _ = make_moons(200)
   |     ^
28 |     return X
   |

N806 Variable `X` in function should be lowercase
  --> umap/tests/test_parametric_umap.py:58:5
   |
56 |         return (x - np.min(x)) / (np.max(x) - np.min(x))
57 |
58 |     X = norm(moon_dataset)
   |     ^
59 |     embedder = ParametricUMAP(parametric_reconstruction=True)
60 |     Z = embedder.fit_transform(X)
   |

N806 Variable `Z` in function should be lowercase
  --> umap/tests/test_parametric_umap.py:60:5
   |
58 |     X = norm(moon_dataset)
59 |     embedder = ParametricUMAP(parametric_reconstruction=True)
60 |     Z = embedder.fit_transform(X)
   |     ^
61 |     X_r = embedder.inverse_transform(Z)
62 |     # completes successfully
   |

N806 Variable `X_r` in function should be lowercase
  --> umap/tests/test_parametric_umap.py:61:5
   |
59 |     embedder = ParametricUMAP(parametric_reconstruction=True)
60 |     Z = embedder.fit_transform(X)
61 |     X_r = embedder.inverse_transform(Z)
   |     ^^^
62 |     # completes successfully
63 |     assert X_r is not None
   |

N806 Variable `X_train` in function should be lowercase
   --> umap/tests/test_parametric_umap.py:112:5
    |
110 | def test_validation(moon_dataset):
111 |     """Tests adding a validation dataset."""
112 |     X_train, X_valid = train_test_split(moon_dataset, train_size=0.5)
    |     ^^^^^^^
113 |     embedder = ParametricUMAP(
114 |         parametric_reconstruction=True, reconstruction_validation=X_valid, verbose=True,
    |

N806 Variable `X_valid` in function should be lowercase
   --> umap/tests/test_parametric_umap.py:112:14
    |
110 | def test_validation(moon_dataset):
111 |     """Tests adding a validation dataset."""
112 |     X_train, X_valid = train_test_split(moon_dataset, train_size=0.5)
    |              ^^^^^^^
113 |     embedder = ParametricUMAP(
114 |         parametric_reconstruction=True, reconstruction_validation=X_valid, verbose=True,
    |

NPY002 Replace legacy `np.random.seed` call with `np.random.Generator`
  --> umap/tests/test_plot.py:8:1
   |
 6 | # Globals, used for all the tests
 7 | SEED = 189212  # 0b101110001100011100
 8 | np.random.seed(SEED)
   | ^^^^^^^^^^^^^^
 9 |
10 | try:
   |

F401 `umap.plot` imported but unused; consider using `importlib.util.find_spec` to test for availability
  --> umap/tests/test_plot.py:11:22
   |
10 | try:
11 |     from umap import plot
   |                      ^^^^
12 |
13 |     IMPORT_PLOT = True
   |
help: Remove unused import: `umap.plot`

D103 Missing docstring in public function
  --> umap/tests/test_plot.py:21:5
   |
20 | @pytest.fixture(scope="session")
21 | def mapper(iris):
   |     ^^^^^^
22 |     return umap.UMAP(n_epochs=100).fit(iris.data)
   |

D103 Missing docstring in public function
  --> umap/tests/test_plot.py:29:5
   |
27 | # property verification.
28 | @plot_only
29 | def test_plot_runs_at_all(mapper, iris, iris_selection):
   |     ^^^^^^^^^^^^^^^^^^^^^
30 |     from umap import plot as umap_plot
   |

PLC0415 `import` should be at the top-level of a file
  --> umap/tests/test_plot.py:30:5
   |
28 | @plot_only
29 | def test_plot_runs_at_all(mapper, iris, iris_selection):
30 |     from umap import plot as umap_plot
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
31 |
32 |     umap_plot.points(mapper)
   |

SLF001 Private member accessed: `_datashade_points`
  --> umap/tests/test_plot.py:49:5
   |
47 |     umap_plot.interactive(mapper, values=iris.data[:, 0], subset_points=iris_selection)
48 |     umap_plot.interactive(mapper, theme="fire")
49 |     umap_plot._datashade_points(mapper.embedding_)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
50 |     umap_plot._datashade_points(mapper.embedding_, labels=iris.target)
51 |     umap_plot._datashade_points(mapper.embedding_, values=iris.data[:, 0])
   |

SLF001 Private member accessed: `_datashade_points`
  --> umap/tests/test_plot.py:50:5
   |
48 |     umap_plot.interactive(mapper, theme="fire")
49 |     umap_plot._datashade_points(mapper.embedding_)
50 |     umap_plot._datashade_points(mapper.embedding_, labels=iris.target)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
51 |     umap_plot._datashade_points(mapper.embedding_, values=iris.data[:, 0])
   |

SLF001 Private member accessed: `_datashade_points`
  --> umap/tests/test_plot.py:51:5
   |
49 |     umap_plot._datashade_points(mapper.embedding_)
50 |     umap_plot._datashade_points(mapper.embedding_, labels=iris.target)
51 |     umap_plot._datashade_points(mapper.embedding_, values=iris.data[:, 0])
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

D103 Missing docstring in public function
  --> umap/tests/test_spectral.py:19:5
   |
17 |     reason="SciPy installing with Python 3.7 does not converge under same circumstances",
18 | )
19 | def test_tsw_spectral_init(iris):
   |     ^^^^^^^^^^^^^^^^^^^^^^
20 |     # create an arbitrary (dense) random affinity matrix
21 |     seed = 42
   |

ARG001 Unused function argument: `iris`
  --> umap/tests/test_spectral.py:19:28
   |
17 |     reason="SciPy installing with Python 3.7 does not converge under same circumstances",
18 | )
19 | def test_tsw_spectral_init(iris):
   |                            ^^^^
20 |     # create an arbitrary (dense) random affinity matrix
21 |     seed = 42
   |

PLR2004 Magic value used in comparison, consider replacing `1e-6` with a constant variable
  --> umap/tests/test_spectral.py:34:16
   |
32 |     rmsd = np.mean(np.sum((spec - tsw_spec) ** 2, axis=1))
33 |     assert (
34 |         rmsd < 1e-6
   |                ^^^^
35 |     ), "tsvd-warmed spectral init insufficiently close to standard spectral init"
   |

D103 Missing docstring in public function
  --> umap/tests/test_spectral.py:42:5
   |
40 |     reason="SciPy installing with Py 3.7 does not warn reliably on convergence failure",
41 | )
42 | def test_ensure_fallback_to_random_on_spectral_failure():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
43 |     dim = 1000
44 |     k = 10
   |

PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
  --> umap/tests/test_spectral.py:45:17
   |
43 |     dim = 1000
44 |     k = 10
45 |     assert k >= 10
   |                 ^^
46 |     assert dim // 10 > k
47 |     y = np.eye(dim, k=1)
   |

NPY002 Replace legacy `np.random.random` call with `np.random.Generator`
  --> umap/tests/test_spectral.py:48:9
   |
46 |     assert dim // 10 > k
47 |     y = np.eye(dim, k=1)
48 |     u = np.random.random((dim, dim // 10))
   |         ^^^^^^^^^^^^^^^^
49 |     graph = y + y.T + u @ u.T
50 |     with pytest.warns(UserWarning, match="Spectral initialisation failed!"):
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_get_feature_names_out.py:8:5
   |
 8 | def test_get_feature_names_out():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
 9 |     X, _ = make_classification(n_samples=30, n_features=10, random_state=42)
10 |     umap = UMAP(
   |

N806 Variable `X` in function should be lowercase
  --> umap/tests/test_umap_get_feature_names_out.py:9:5
   |
 8 | def test_get_feature_names_out():
 9 |     X, _ = make_classification(n_samples=30, n_features=10, random_state=42)
   |     ^
10 |     umap = UMAP(
11 |         n_neighbors=10,
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_get_feature_names_out.py:24:5
   |
24 | def test_get_feature_names_out_default():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |     X, _ = make_classification(n_samples=30, n_features=10, random_state=42)
26 |     umap = UMAP(
   |

N806 Variable `X` in function should be lowercase
  --> umap/tests/test_umap_get_feature_names_out.py:25:5
   |
24 | def test_get_feature_names_out_default():
25 |     X, _ = make_classification(n_samples=30, n_features=10, random_state=42)
   |     ^
26 |     umap = UMAP(
27 |         n_neighbors=10,
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_get_feature_names_out.py:39:5
   |
39 | def test_get_feature_names_out_multicomponent():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
40 |     # The output length should be equal to the number of components UMAP generates.
41 |     X, _ = make_classification(n_samples=30, n_features=10, random_state=42)
   |

N806 Variable `X` in function should be lowercase
  --> umap/tests/test_umap_get_feature_names_out.py:41:5
   |
39 | def test_get_feature_names_out_multicomponent():
40 |     # The output length should be equal to the number of components UMAP generates.
41 |     X, _ = make_classification(n_samples=30, n_features=10, random_state=42)
   |     ^
42 |     umap = UMAP(
43 |         n_neighbors=10,
   |

PLR2004 Magic value used in comparison, consider replacing `9` with a constant variable
  --> umap/tests/test_umap_get_feature_names_out.py:51:32
   |
49 |     result_umap = umap.get_feature_names_out()
50 |     expected_umap_result = [f"umap{i}" for i in range(9)]
51 |     assert len(result_umap) == 9
   |                                ^
52 |     np.testing.assert_array_equal(result_umap, expected_umap_result)
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_get_feature_names_out.py:56:5
   |
56 | def test_get_feature_names_out_featureunion():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
57 |     X, _ = make_classification(n_samples=30, n_features=10, random_state=42)
58 |     pipeline = Pipeline(
   |

N806 Variable `X` in function should be lowercase
  --> umap/tests/test_umap_get_feature_names_out.py:57:5
   |
56 | def test_get_feature_names_out_featureunion():
57 |     X, _ = make_classification(n_samples=30, n_features=10, random_state=42)
   |     ^
58 |     pipeline = Pipeline(
59 |         [
   |

FBT002 Boolean default positional argument in function definition
  --> umap/tests/test_umap_metrics.py:28:53
   |
28 | def run_test_metric(metric, test_data, dist_matrix, with_grad=False):
   |                                                     ^^^^^^^^^
29 |     """Core utility function to test target metric on test data."""
30 |     if with_grad:
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_metrics.py:51:5
   |
51 | def spatial_check(metric, spatial_data, spatial_distances, with_grad=False):
   |     ^^^^^^^^^^^^^
52 |     # Check that metric is supported for this test, otherwise, fail!
53 |     assert metric in spatial_distances, f"{metric} not valid for spatial data"
   |

FBT002 Boolean default positional argument in function definition
  --> umap/tests/test_umap_metrics.py:51:60
   |
51 | def spatial_check(metric, spatial_data, spatial_distances, with_grad=False):
   |                                                            ^^^^^^^^^
52 |     # Check that metric is supported for this test, otherwise, fail!
53 |     assert metric in spatial_distances, f"{metric} not valid for spatial data"
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_metrics.py:68:5
   |
68 | def binary_check(metric, binary_data, binary_distances):
   |     ^^^^^^^^^^^^
69 |     # Check that metric is supported for this test, otherwise, fail!
70 |     assert metric in binary_distances, f"{metric} not valid for binary data"
   |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:126:5
    |
126 | def sparse_spatial_check(metric, sparse_spatial_data):
    |     ^^^^^^^^^^^^^^^^^^^^
127 |     # Check that metric is supported for this test, otherwise, fail!
128 |     assert (
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:147:5
    |
147 | def sparse_binary_check(metric, sparse_binary_data):
    |     ^^^^^^^^^^^^^^^^^^^
148 |     # Check that metric is supported for this test, otherwise, fail!
149 |     assert (
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:172:5
    |
172 | def test_euclidean(spatial_data, spatial_distances):
    |     ^^^^^^^^^^^^^^
173 |     spatial_check("euclidean", spatial_data, spatial_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:176:5
    |
176 | def test_manhattan(spatial_data, spatial_distances):
    |     ^^^^^^^^^^^^^^
177 |     spatial_check("manhattan", spatial_data, spatial_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:180:5
    |
180 | def test_chebyshev(spatial_data, spatial_distances):
    |     ^^^^^^^^^^^^^^
181 |     spatial_check("chebyshev", spatial_data, spatial_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:184:5
    |
184 | def test_minkowski(spatial_data, spatial_distances):
    |     ^^^^^^^^^^^^^^
185 |     spatial_check("minkowski", spatial_data, spatial_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:188:5
    |
188 | def test_hamming(spatial_data, spatial_distances):
    |     ^^^^^^^^^^^^
189 |     spatial_check("hamming", spatial_data, spatial_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:192:5
    |
192 | def test_canberra(spatial_data, spatial_distances):
    |     ^^^^^^^^^^^^^
193 |     spatial_check("canberra", spatial_data, spatial_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:196:5
    |
196 | def test_braycurtis(spatial_data, spatial_distances):
    |     ^^^^^^^^^^^^^^^
197 |     spatial_check("braycurtis", spatial_data, spatial_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:200:5
    |
200 | def test_cosine(spatial_data, spatial_distances):
    |     ^^^^^^^^^^^
201 |     spatial_check("cosine", spatial_data, spatial_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:204:5
    |
204 | def test_correlation(spatial_data, spatial_distances):
    |     ^^^^^^^^^^^^^^^^
205 |     spatial_check("correlation", spatial_data, spatial_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:213:5
    |
213 | def test_jaccard(binary_data, binary_distances):
    |     ^^^^^^^^^^^^
214 |     binary_check("jaccard", binary_data, binary_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:217:5
    |
217 | def test_matching(binary_data, binary_distances):
    |     ^^^^^^^^^^^^^
218 |     binary_check("matching", binary_data, binary_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:221:5
    |
221 | def test_dice(binary_data, binary_distances):
    |     ^^^^^^^^^
222 |     binary_check("dice", binary_data, binary_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:228:5
    |
226 |     scipy_full_version >= (1, 9), reason="deprecated in SciPy 1.9, removed in 1.11",
227 | )
228 | def test_kulsinski(binary_data, binary_distances):
    |     ^^^^^^^^^^^^^^
229 |     binary_check("kulsinski", binary_data, binary_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:232:5
    |
232 | def test_rogerstanimoto(binary_data, binary_distances):
    |     ^^^^^^^^^^^^^^^^^^^
233 |     binary_check("rogerstanimoto", binary_data, binary_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:236:5
    |
236 | def test_russellrao(binary_data, binary_distances):
    |     ^^^^^^^^^^^^^^^
237 |     binary_check("russellrao", binary_data, binary_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:240:5
    |
240 | def test_sokalmichener(binary_data, binary_distances):
    |     ^^^^^^^^^^^^^^^^^^
241 |     binary_check("sokalmichener", binary_data, binary_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:244:5
    |
244 | def test_sokalsneath(binary_data, binary_distances):
    |     ^^^^^^^^^^^^^^^^
245 |     binary_check("sokalsneath", binary_data, binary_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:248:5
    |
248 | def test_yule(binary_data, binary_distances):
    |     ^^^^^^^^^
249 |     binary_check("yule", binary_data, binary_distances)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:257:5
    |
257 | def test_sparse_euclidean(sparse_spatial_data):
    |     ^^^^^^^^^^^^^^^^^^^^^
258 |     sparse_spatial_check("euclidean", sparse_spatial_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:261:5
    |
261 | def test_sparse_manhattan(sparse_spatial_data):
    |     ^^^^^^^^^^^^^^^^^^^^^
262 |     sparse_spatial_check("manhattan", sparse_spatial_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:265:5
    |
265 | def test_sparse_chebyshev(sparse_spatial_data):
    |     ^^^^^^^^^^^^^^^^^^^^^
266 |     sparse_spatial_check("chebyshev", sparse_spatial_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:269:5
    |
269 | def test_sparse_minkowski(sparse_spatial_data):
    |     ^^^^^^^^^^^^^^^^^^^^^
270 |     sparse_spatial_check("minkowski", sparse_spatial_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:273:5
    |
273 | def test_sparse_hamming(sparse_spatial_data):
    |     ^^^^^^^^^^^^^^^^^^^
274 |     sparse_spatial_check("hamming", sparse_spatial_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:277:5
    |
277 | def test_sparse_canberra(sparse_spatial_data):
    |     ^^^^^^^^^^^^^^^^^^^^
278 |     sparse_spatial_check("canberra", sparse_spatial_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:281:5
    |
281 | def test_sparse_cosine(sparse_spatial_data):
    |     ^^^^^^^^^^^^^^^^^^
282 |     sparse_spatial_check("cosine", sparse_spatial_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:285:5
    |
285 | def test_sparse_correlation(sparse_spatial_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^
286 |     sparse_spatial_check("correlation", sparse_spatial_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:289:5
    |
289 | def test_sparse_braycurtis(sparse_spatial_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^
290 |     sparse_spatial_check("braycurtis", sparse_spatial_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:298:5
    |
298 | def test_sparse_jaccard(sparse_binary_data):
    |     ^^^^^^^^^^^^^^^^^^^
299 |     sparse_binary_check("jaccard", sparse_binary_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:302:5
    |
302 | def test_sparse_matching(sparse_binary_data):
    |     ^^^^^^^^^^^^^^^^^^^^
303 |     sparse_binary_check("matching", sparse_binary_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:306:5
    |
306 | def test_sparse_dice(sparse_binary_data):
    |     ^^^^^^^^^^^^^^^^
307 |     sparse_binary_check("dice", sparse_binary_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:313:5
    |
311 |     scipy_full_version >= (1, 9), reason="deprecated in SciPy 1.9, removed in 1.11",
312 | )
313 | def test_sparse_kulsinski(sparse_binary_data):
    |     ^^^^^^^^^^^^^^^^^^^^^
314 |     sparse_binary_check("kulsinski", sparse_binary_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:317:5
    |
317 | def test_sparse_rogerstanimoto(sparse_binary_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
318 |     sparse_binary_check("rogerstanimoto", sparse_binary_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:321:5
    |
321 | def test_sparse_russellrao(sparse_binary_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^
322 |     sparse_binary_check("russellrao", sparse_binary_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:325:5
    |
325 | def test_sparse_sokalmichener(sparse_binary_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
326 |     sparse_binary_check("sokalmichener", sparse_binary_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:329:5
    |
329 | def test_sparse_sokalsneath(sparse_binary_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^
330 |     sparse_binary_check("sokalsneath", sparse_binary_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:336:5
    |
334 | # Standardised/weighted Distances
335 | # --------------------------------
336 | def test_seuclidean(spatial_data):
    |     ^^^^^^^^^^^^^^^
337 |     v = np.abs(np.random.randn(spatial_data.shape[1]))
338 |     dist_matrix = pairwise_distances(spatial_data, metric="seuclidean", V=v)
    |

NPY002 Replace legacy `np.random.randn` call with `np.random.Generator`
   --> umap/tests/test_umap_metrics.py:337:16
    |
335 | # --------------------------------
336 | def test_seuclidean(spatial_data):
337 |     v = np.abs(np.random.randn(spatial_data.shape[1]))
    |                ^^^^^^^^^^^^^^^
338 |     dist_matrix = pairwise_distances(spatial_data, metric="seuclidean", V=v)
339 |     test_matrix = np.array(
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:358:5
    |
356 |     scipy_full_version < (1, 8), reason="incorrect function in scipy<1.8",
357 | )
358 | def test_weighted_minkowski(spatial_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^
359 |     v = np.abs(np.random.randn(spatial_data.shape[1]))
360 |     dist_matrix = pairwise_distances(spatial_data, metric="minkowski", w=v, p=3)
    |

NPY002 Replace legacy `np.random.randn` call with `np.random.Generator`
   --> umap/tests/test_umap_metrics.py:359:16
    |
357 | )
358 | def test_weighted_minkowski(spatial_data):
359 |     v = np.abs(np.random.randn(spatial_data.shape[1]))
    |                ^^^^^^^^^^^^^^^
360 |     dist_matrix = pairwise_distances(spatial_data, metric="minkowski", w=v, p=3)
361 |     test_matrix = np.array(
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:377:5
    |
377 | def test_mahalanobis(spatial_data):
    |     ^^^^^^^^^^^^^^^^
378 |     v = np.cov(np.transpose(spatial_data))
379 |     dist_matrix = pairwise_distances(spatial_data, metric="mahalanobis", VI=v)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:396:5
    |
396 | def test_haversine(spatial_data):
    |     ^^^^^^^^^^^^^^
397 |     tree = BallTree(spatial_data[:, :2], metric="haversine")
398 |     dist_matrix, _ = tree.query(spatial_data[:, :2], k=spatial_data.shape[0])
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:416:5
    |
416 | def test_hellinger(spatial_data):
    |     ^^^^^^^^^^^^^^
417 |     hellinger_data = np.abs(spatial_data[:-2].copy())
418 |     hellinger_data = hellinger_data / hellinger_data.sum(axis=1)[:, np.newaxis]
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:443:5
    |
443 | def test_sparse_hellinger(sparse_spatial_data):
    |     ^^^^^^^^^^^^^^^^^^^^^
444 |     dist_matrix = dist.pairwise_special_metric(
445 |         np.abs(sparse_spatial_data[:-2].toarray()),
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_metrics.py:489:5
    |
489 | def test_grad_metrics_match_metrics(spatial_data, spatial_distances):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
490 |     for metric in dist.named_distances_with_gradients:
491 |         if metric in spatial_distances:
    |

NPY002 Replace legacy `np.random.randn` call with `np.random.Generator`
   --> umap/tests/test_umap_metrics.py:496:16
    |
494 |     # Handle the few special distances separately
495 |     # SEuclidean
496 |     v = np.abs(np.random.randn(spatial_data.shape[1]))
    |                ^^^^^^^^^^^^^^^
497 |     dist_matrix = pairwise_distances(spatial_data, metric="seuclidean", V=v)
498 |     test_matrix = np.array(
    |

NPY002 Replace legacy `np.random.randn` call with `np.random.Generator`
   --> umap/tests/test_umap_metrics.py:534:16
    |
533 |     # Mahalanobis
534 |     v = np.abs(np.random.randn(spatial_data.shape[1], spatial_data.shape[1]))
    |                ^^^^^^^^^^^^^^^
535 |     dist_matrix = pairwise_distances(spatial_data, metric="mahalanobis", VI=v)
536 |     test_matrix = np.array(
    |

D103 Missing docstring in public function
  --> umap/tests/test_umap_nn.py:20:5
   |
18 | # nearest_neighbours metric parameter validation
19 | # -----------------------------------------------
20 | def test_nn_bad_metric(nn_data):
   |     ^^^^^^^^^^^^^^^^^^
21 |     with pytest.raises(ValueError):
22 |         nearest_neighbors(nn_data, 10, 42, {}, False, np.random)
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_umap_nn.py:21:24
   |
19 | # -----------------------------------------------
20 | def test_nn_bad_metric(nn_data):
21 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
22 |         nearest_neighbors(nn_data, 10, 42, {}, False, np.random)
   |

FBT003 Boolean positional value in function call
  --> umap/tests/test_umap_nn.py:22:48
   |
20 | def test_nn_bad_metric(nn_data):
21 |     with pytest.raises(ValueError):
22 |         nearest_neighbors(nn_data, 10, 42, {}, False, np.random)
   |                                                ^^^^^
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_nn.py:25:5
   |
25 | def test_nn_bad_metric_sparse_data(sparse_nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
26 |     with pytest.raises(ValueError):
27 |         nearest_neighbors(
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_umap_nn.py:26:24
   |
25 | def test_nn_bad_metric_sparse_data(sparse_nn_data):
26 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
27 |         nearest_neighbors(
28 |             sparse_nn_data,
   |

FBT003 Boolean positional value in function call
  --> umap/tests/test_umap_nn.py:32:13
   |
30 |             "seuclidean",
31 |             {},
32 |             False,
   |             ^^^^^
33 |             np.random,
34 |         )
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_nn.py:42:5
   |
42 | def knn(indices, nn_data):  # pragma: no cover
   |     ^^^
43 |     tree = KDTree(nn_data)
44 |     true_indices = tree.query(nn_data, 10, return_distance=False)
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_nn.py:51:5
   |
51 | def smooth_knn(nn_data, local_connectivity=1.0):
   |     ^^^^^^^^^^
52 |     _knn_indices, knn_dists, _ = nearest_neighbors(
53 |         nn_data, 10, "euclidean", {}, False, np.random,
   |

FBT003 Boolean positional value in function call
  --> umap/tests/test_umap_nn.py:53:39
   |
51 | def smooth_knn(nn_data, local_connectivity=1.0):
52 |     _knn_indices, knn_dists, _ = nearest_neighbors(
53 |         nn_data, 10, "euclidean", {}, False, np.random,
   |                                       ^^^^^
54 |     )
55 |     sigmas, rhos = smooth_knn_dist(
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_nn.py:65:5
   |
64 | @pytest.mark.skip
65 | def test_nn_descent_neighbor_accuracy(nn_data):  # pragma: no cover
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
66 |     knn_indices, _knn_dists, _ = nearest_neighbors(
67 |         nn_data, 10, "euclidean", {}, False, np.random,
   |

FBT003 Boolean positional value in function call
  --> umap/tests/test_umap_nn.py:67:39
   |
65 | def test_nn_descent_neighbor_accuracy(nn_data):  # pragma: no cover
66 |     knn_indices, _knn_dists, _ = nearest_neighbors(
67 |         nn_data, 10, "euclidean", {}, False, np.random,
   |                                       ^^^^^
68 |     )
69 |     percent_correct = knn(knn_indices, nn_data)
   |

PLR2004 Magic value used in comparison, consider replacing `0.85` with a constant variable
  --> umap/tests/test_umap_nn.py:71:28
   |
69 |     percent_correct = knn(knn_indices, nn_data)
70 |     assert (
71 |         percent_correct >= 0.85
   |                            ^^^^
72 |     ), "NN-descent did not get 89% accuracy on nearest neighbors"
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_nn.py:76:5
   |
75 | @pytest.mark.skip
76 | def test_nn_descent_neighbor_accuracy_low_memory(nn_data):  # pragma: no cover
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
77 |     knn_indices, _knn_dists, _ = nearest_neighbors(
78 |         nn_data, 10, "euclidean", {}, False, np.random, low_memory=True,
   |

FBT003 Boolean positional value in function call
  --> umap/tests/test_umap_nn.py:78:39
   |
76 | def test_nn_descent_neighbor_accuracy_low_memory(nn_data):  # pragma: no cover
77 |     knn_indices, _knn_dists, _ = nearest_neighbors(
78 |         nn_data, 10, "euclidean", {}, False, np.random, low_memory=True,
   |                                       ^^^^^
79 |     )
80 |     percent_correct = knn(knn_indices, nn_data)
   |

PLR2004 Magic value used in comparison, consider replacing `0.89` with a constant variable
  --> umap/tests/test_umap_nn.py:82:28
   |
80 |     percent_correct = knn(knn_indices, nn_data)
81 |     assert (
82 |         percent_correct >= 0.89
   |                            ^^^^
83 |     ), "NN-descent did not get 89% accuracy on nearest neighbors"
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_nn.py:87:5
   |
86 | @pytest.mark.skip
87 | def test_angular_nn_descent_neighbor_accuracy(nn_data):  # pragma: no cover
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
88 |     knn_indices, _knn_dists, _ = nearest_neighbors(
89 |         nn_data, 10, "cosine", {}, True, np.random,
   |

FBT003 Boolean positional value in function call
  --> umap/tests/test_umap_nn.py:89:36
   |
87 | def test_angular_nn_descent_neighbor_accuracy(nn_data):  # pragma: no cover
88 |     knn_indices, _knn_dists, _ = nearest_neighbors(
89 |         nn_data, 10, "cosine", {}, True, np.random,
   |                                    ^^^^
90 |     )
91 |     angular_data = normalize(nn_data, norm="l2")
   |

PLR2004 Magic value used in comparison, consider replacing `0.85` with a constant variable
  --> umap/tests/test_umap_nn.py:94:28
   |
92 |     percent_correct = knn(knn_indices, angular_data)
93 |     assert (
94 |         percent_correct >= 0.85
   |                            ^^^^
95 |     ), "NN-descent did not get 89% accuracy on nearest neighbors"
   |

D103 Missing docstring in public function
   --> umap/tests/test_umap_nn.py:99:5
    |
 98 | @pytest.mark.skip
 99 | def test_sparse_nn_descent_neighbor_accuracy(sparse_nn_data):  # pragma: no cover
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
100 |     knn_indices, _knn_dists, _ = nearest_neighbors(
101 |         sparse_nn_data, 20, "euclidean", {}, False, np.random,
    |

FBT003 Boolean positional value in function call
   --> umap/tests/test_umap_nn.py:101:46
    |
 99 | def test_sparse_nn_descent_neighbor_accuracy(sparse_nn_data):  # pragma: no cover
100 |     knn_indices, _knn_dists, _ = nearest_neighbors(
101 |         sparse_nn_data, 20, "euclidean", {}, False, np.random,
    |                                              ^^^^^
102 |     )
103 |     percent_correct = knn(knn_indices, sparse_nn_data.todense())
    |

PLR2004 Magic value used in comparison, consider replacing `0.75` with a constant variable
   --> umap/tests/test_umap_nn.py:105:28
    |
103 |     percent_correct = knn(knn_indices, sparse_nn_data.todense())
104 |     assert (
105 |         percent_correct >= 0.75
    |                            ^^^^
106 |     ), "Sparse NN-descent did not get 90% accuracy on nearest neighbors"
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_nn.py:110:5
    |
109 | @pytest.mark.skip
110 | def test_sparse_nn_descent_neighbor_accuracy_low_memory(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
111 |     sparse_nn_data,
112 | ):  # pragma: no cover
    |

FBT003 Boolean positional value in function call
   --> umap/tests/test_umap_nn.py:114:46
    |
112 | ):  # pragma: no cover
113 |     knn_indices, _knn_dists, _ = nearest_neighbors(
114 |         sparse_nn_data, 20, "euclidean", {}, False, np.random, low_memory=True,
    |                                              ^^^^^
115 |     )
116 |     percent_correct = knn(knn_indices, sparse_nn_data.todense())
    |

PLR2004 Magic value used in comparison, consider replacing `0.85` with a constant variable
   --> umap/tests/test_umap_nn.py:118:28
    |
116 |     percent_correct = knn(knn_indices, sparse_nn_data.todense())
117 |     assert (
118 |         percent_correct >= 0.85
    |                            ^^^^
119 |     ), "Sparse NN-descent did not get 90% accuracy on nearest neighbors"
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_nn.py:123:5
    |
122 | @pytest.mark.skip
123 | def test_nn_descent_neighbor_accuracy_callable_metric(nn_data):  # pragma: no cover
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
124 |     knn_indices, _knn_dists, _ = nearest_neighbors(
125 |         nn_data, 10, dist.euclidean, {}, False, np.random,
    |

FBT003 Boolean positional value in function call
   --> umap/tests/test_umap_nn.py:125:42
    |
123 | def test_nn_descent_neighbor_accuracy_callable_metric(nn_data):  # pragma: no cover
124 |     knn_indices, _knn_dists, _ = nearest_neighbors(
125 |         nn_data, 10, dist.euclidean, {}, False, np.random,
    |                                          ^^^^^
126 |     )
    |

PLR2004 Magic value used in comparison, consider replacing `0.95` with a constant variable
   --> umap/tests/test_umap_nn.py:130:28
    |
128 |     percent_correct = knn(knn_indices, nn_data)
129 |     assert (
130 |         percent_correct >= 0.95
    |                            ^^^^
131 |     ), "NN-descent did not get 95% accuracy on nearest neighbors with callable metric"
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_nn.py:135:5
    |
134 | @pytest.mark.skip
135 | def test_sparse_angular_nn_descent_neighbor_accuracy(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
136 |     sparse_nn_data,
137 | ):  # pragma: no cover
    |

FBT003 Boolean positional value in function call
   --> umap/tests/test_umap_nn.py:139:43
    |
137 | ):  # pragma: no cover
138 |     knn_indices, _knn_dists, _ = nearest_neighbors(
139 |         sparse_nn_data, 20, "cosine", {}, True, np.random,
    |                                           ^^^^
140 |     )
141 |     angular_data = normalize(sparse_nn_data, norm="l2").toarray()
    |

PLR2004 Magic value used in comparison, consider replacing `0.90` with a constant variable
   --> umap/tests/test_umap_nn.py:144:28
    |
142 |     percent_correct = knn(knn_indices, angular_data)
143 |     assert (
144 |         percent_correct >= 0.90
    |                            ^^^^
145 |     ), "Sparse NN-descent did not get 90% accuracy on nearest neighbors"
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_nn.py:148:5
    |
148 | def test_smooth_knn_dist_l1norms(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
149 |     norms = smooth_knn(nn_data)
150 |     assert_array_almost_equal(
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_nn.py:158:5
    |
158 | def test_smooth_knn_dist_l1norms_w_connectivity(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
159 |     norms = smooth_knn(nn_data, local_connectivity=1.75)
160 |     assert_array_almost_equal(
    |

D103 Missing docstring in public function
  --> umap/tests/test_umap_on_iris.py:30:5
   |
28 | # UMAP Trustworthiness on iris
29 | # ----------------------------
30 | def test_umap_trustworthiness_on_iris(iris, iris_model):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
31 |     embedding = iris_model.embedding_
32 |     trust = trustworthiness(iris.data, embedding, n_neighbors=10)
   |

PLR2004 Magic value used in comparison, consider replacing `0.97` with a constant variable
  --> umap/tests/test_umap_on_iris.py:34:18
   |
32 |     trust = trustworthiness(iris.data, embedding, n_neighbors=10)
33 |     assert (
34 |         trust >= 0.97
   |                  ^^^^
35 |     ), f"Insufficiently trustworthy embedding foriris dataset: {trust}"
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_on_iris.py:38:5
   |
38 | def test_initialized_umap_trustworthiness_on_iris(iris):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
39 |     data = iris.data
40 |     embedding = UMAP(
   |

PLR2004 Magic value used in comparison, consider replacing `0.97` with a constant variable
  --> umap/tests/test_umap_on_iris.py:49:18
   |
47 |     trust = trustworthiness(iris.data, embedding, n_neighbors=10)
48 |     assert (
49 |         trust >= 0.97
   |                  ^^^^
50 |     ), f"Insufficiently trustworthy embedding foriris dataset: {trust}"
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_on_iris.py:53:5
   |
53 | def test_umap_trustworthiness_on_sphere_iris(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
54 |     iris,
55 | ):
   |

PLR2004 Magic value used in comparison, consider replacing `0.65` with a constant variable
  --> umap/tests/test_umap_on_iris.py:78:18
   |
76 |     )
77 |     assert (
78 |         trust >= 0.65
   |                  ^^^^
79 |     ), f"Insufficiently trustworthy spherical embedding for iris dataset: {trust}"
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_on_iris.py:84:5
   |
82 | # UMAP Transform on iris
83 | # ----------------------
84 | def test_umap_transform_on_iris(iris, iris_subset_model, iris_selection):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
85 |     fitter = iris_subset_model
   |

PLR2004 Magic value used in comparison, consider replacing `0.80` with a constant variable
  --> umap/tests/test_umap_on_iris.py:92:18
   |
90 |     trust = trustworthiness(new_data, embedding, n_neighbors=10)
91 |     assert (
92 |         trust >= 0.80
   |                  ^^^^
93 |     ), f"Insufficiently trustworthy transform foriris dataset: {trust}"
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_on_iris.py:96:5
   |
96 | def test_umap_transform_on_iris_w_pynndescent(iris, iris_selection):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
97 |     data = iris.data[iris_selection]
98 |     fitter = UMAP(
   |

PLR2004 Magic value used in comparison, consider replacing `0.85` with a constant variable
   --> umap/tests/test_umap_on_iris.py:111:18
    |
109 |     trust = trustworthiness(new_data, embedding, n_neighbors=10)
110 |     assert (
111 |         trust >= 0.85
    |                  ^^^^
112 |     ), f"Insufficiently trustworthy transform foriris dataset: {trust}"
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_on_iris.py:115:5
    |
115 | def test_umap_transform_on_iris_modified_dtype(iris, iris_subset_model, iris_selection):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
116 |     fitter = iris_subset_model
117 |     fitter.embedding_ = fitter.embedding_.astype(np.float64)
    |

PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
   --> umap/tests/test_umap_on_iris.py:124:18
    |
122 |     trust = trustworthiness(new_data, embedding, n_neighbors=10)
123 |     assert (
124 |         trust >= 0.8
    |                  ^^^
125 |     ), f"Insufficiently trustworthy transform for iris dataset: {trust}"
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_on_iris.py:128:5
    |
128 | def test_umap_sparse_transform_on_iris(iris, iris_selection):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
129 |     data = sparse.csr_matrix(iris.data[iris_selection])
130 |     assert sparse.issparse(data)
    |

ERA001 Found commented-out code
   --> umap/tests/test_umap_on_iris.py:136:9
    |
134 |         random_state=42,
135 |         n_epochs=100,
136 |         # force_approximation_algorithm=True,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
137 |     ).fit(data)
    |
help: Remove commented-out code

PLR2004 Magic value used in comparison, consider replacing `0.80` with a constant variable
   --> umap/tests/test_umap_on_iris.py:145:18
    |
143 |     trust = trustworthiness(new_data, embedding, n_neighbors=10)
144 |     assert (
145 |         trust >= 0.80
    |                  ^^^^
146 |     ), f"Insufficiently trustworthy transform foriris dataset: {trust}"
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_on_iris.py:151:5
    |
149 | # UMAP precomputed metric transform on iris
150 | # ----------------------
151 | def test_precomputed_transform_on_iris(iris, iris_selection):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
152 |     data = iris.data[iris_selection]
153 |     distance_matrix = squareform(pdist(data))
    |

PLR2004 Magic value used in comparison, consider replacing `0.85` with a constant variable
   --> umap/tests/test_umap_on_iris.py:169:18
    |
167 |     trust = trustworthiness(new_data, embedding, n_neighbors=10)
168 |     assert (
169 |         trust >= 0.85
    |                  ^^^^
170 |     ), f"Insufficiently trustworthy transform foriris dataset: {trust}"
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_on_iris.py:175:5
    |
173 | # UMAP precomputed metric transform on iris with sparse distances
174 | # ----------------------
175 | def test_precomputed_sparse_transform_on_iris(iris, iris_selection):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
176 |     data = iris.data[iris_selection]
177 |     distance_matrix = sparse.csr_matrix(squareform(pdist(data)))
    |

PLR2004 Magic value used in comparison, consider replacing `0.85` with a constant variable
   --> umap/tests/test_umap_on_iris.py:193:18
    |
191 |     trust = trustworthiness(new_data, embedding, n_neighbors=10)
192 |     assert (
193 |         trust >= 0.85
    |                  ^^^^
194 |     ), f"Insufficiently trustworthy transform foriris dataset: {trust}"
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_on_iris.py:199:5
    |
197 | # UMAP Clusterability on Iris
198 | # ---------------------------
199 | def test_umap_clusterability_on_supervised_iris(supervised_iris_model, iris):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
200 |     embedding = supervised_iris_model.embedding_
201 |     clusters = KMeans(3).fit_predict(embedding)
    |

PLR2004 Magic value used in comparison, consider replacing `0.95` with a constant variable
   --> umap/tests/test_umap_on_iris.py:202:58
    |
200 |     embedding = supervised_iris_model.embedding_
201 |     clusters = KMeans(3).fit_predict(embedding)
202 |     assert adjusted_rand_score(clusters, iris.target) >= 0.95
    |                                                          ^^^^
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_on_iris.py:207:5
    |
205 | # UMAP Inverse transform on Iris
206 | # ------------------------------
207 | def test_umap_inverse_transform_on_iris(iris, iris_model):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
208 |     highd_tree = KDTree(iris.data)
209 |     fitter = iris_model
    |

PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   --> umap/tests/test_umap_on_iris.py:219:78
    |
217 |             highd_centroid, k=10, return_distance=False,
218 |         )
219 |         assert np.intersect1d(near_points, highd_near_points[0]).shape[0] >= 3
    |                                                                              ^
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_on_iris.py:222:5
    |
222 | def test_precomputed_knn_on_iris(iris, iris_selection, iris_subset_model):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
223 |     # this to compare two similarity graphs which should be nearly the same
224 |     def rms(a, b):
    |

PLR2004 Magic value used in comparison, consider replacing `0.005` with a constant variable
   --> umap/tests/test_umap_on_iris.py:258:80
    |
256 |     # threshold for similarity in graph empirically chosen by comparing the iris subset
257 |     # model with force_approximation_algorithm=True and different random seeds
258 |     assert rms(fitter_with_precomputed_knn.graph_, iris_subset_model.graph_) < 0.005
    |                                                                                ^^^^^
259 |
260 |     with pytest.warns(Warning, match="transforming new data") as record:
    |

PT031 `pytest.warns()` block should contain a single simple statement
   --> umap/tests/test_umap_on_iris.py:260:5
    |
258 |       assert rms(fitter_with_precomputed_knn.graph_, iris_subset_model.graph_) < 0.005
259 |
260 | /     with pytest.warns(Warning, match="transforming new data") as record:
261 | |         fitter_ignoring_force_approx = UMAP(
262 | |             **umap_args,
263 | |             precomputed_knn=(knn[0], knn[1]),
264 | |         ).fit(data)
265 | |         assert len(record) >= 1
    | |_______________________________^
266 |       np.testing.assert_array_equal(
267 |           fitter_ignoring_force_approx.embedding_, fitter_with_precomputed_knn.embedding_,
    |

PT031 `pytest.warns()` block should contain a single simple statement
   --> umap/tests/test_umap_on_iris.py:276:5
    |
275 |       # force_approximation_algorithm parameter is ignored
276 | /     with pytest.warns(Warning, match="transforming new data") as record:
277 | |         fitter_ignoring_force_approx_True = UMAP(
278 | |             **umap_args,
279 | |             precomputed_knn=(knn[0], knn[1]),
280 | |             force_approximation_algorithm=True,
281 | |         ).fit(data)
282 | |         assert len(record) >= 1
    | |_______________________________^
283 |       np.testing.assert_array_equal(
284 |           fitter_ignoring_force_approx_True.embedding_,
    |

N806 Variable `fitter_ignoring_force_approx_True` in function should be lowercase
   --> umap/tests/test_umap_on_iris.py:277:9
    |
275 |     # force_approximation_algorithm parameter is ignored
276 |     with pytest.warns(Warning, match="transforming new data") as record:
277 |         fitter_ignoring_force_approx_True = UMAP(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
278 |             **umap_args,
279 |             precomputed_knn=(knn[0], knn[1]),
    |

ERA001 Found commented-out code
  --> umap/tests/test_umap_ops.py:26:1
   |
24 | # @SkipTest
25 | # def test_scikit_learn_compatibility():
26 | #     check_estimator(UMAP)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> umap/tests/test_umap_ops.py:33:1
   |
31 | # @SkipTest
32 | # def test_umap_regression_supervision(): # pragma: no cover
33 | #     boston = load_boston()
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
34 | #     data = boston.data
35 | #     embedding = UMAP(n_neighbors=10,
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> umap/tests/test_umap_ops.py:34:1
   |
32 | # def test_umap_regression_supervision(): # pragma: no cover
33 | #     boston = load_boston()
34 | #     data = boston.data
   | ^^^^^^^^^^^^^^^^^^^^^^^^
35 | #     embedding = UMAP(n_neighbors=10,
36 | #                      min_dist=0.01,
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> umap/tests/test_umap_ops.py:36:1
   |
34 | #     data = boston.data
35 | #     embedding = UMAP(n_neighbors=10,
36 | #                      min_dist=0.01,
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
37 | #                      target_metric='euclidean',
38 | #                      random_state=42).fit_transform(data, boston.target)
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> umap/tests/test_umap_ops.py:37:1
   |
35 | #     embedding = UMAP(n_neighbors=10,
36 | #                      min_dist=0.01,
37 | #                      target_metric='euclidean',
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 | #                      random_state=42).fit_transform(data, boston.target)
39 | #
   |
help: Remove commented-out code

D103 Missing docstring in public function
  --> umap/tests/test_umap_ops.py:43:5
   |
42 | # Umap Clusterability
43 | def test_blobs_cluster():
   |     ^^^^^^^^^^^^^^^^^^
44 |     data, labels = make_blobs(n_samples=500, n_features=10, centers=5)
45 |     embedding = UMAP(n_epochs=100).fit_transform(data)
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_ops.py:50:5
   |
49 | # Multi-components Layout
50 | def test_multi_component_layout():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
51 |     data, labels = make_blobs(
52 |         100, 2, centers=5, cluster_std=0.5, center_box=(-20, 20), random_state=42,
   |

PLR2004 Magic value used in comparison, consider replacing `15.0` with a constant variable
  --> umap/tests/test_umap_ops.py:73:20
   |
71 |     error = np.sum((true_centroids - embed_centroids) ** 2)
72 |
73 |     assert error < 15.0, "Multi component embedding to far astray"
   |                    ^^^^
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_ops.py:77:5
   |
76 | # Multi-components Layout
77 | def test_multi_component_layout_precomputed():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
78 |     data, labels = make_blobs(
79 |         100, 2, centers=5, cluster_std=0.5, center_box=(-20, 20), random_state=42,
   |

PLR2004 Magic value used in comparison, consider replacing `15.0` with a constant variable
   --> umap/tests/test_umap_ops.py:103:20
    |
101 |     error = np.sum((true_centroids - embed_centroids) ** 2)
102 |
103 |     assert error < 15.0, "Multi component embedding to far astray"
    |                    ^^^^
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_ops.py:109:5
    |
107 | @pytest.mark.parametrize("metric", ["jaccard", "hellinger"])
108 | @pytest.mark.parametrize("force_approximation", [True, False])
109 | def test_disconnected_data(num_isolates, metric, force_approximation):
    |     ^^^^^^^^^^^^^^^^^^^^^^
110 |     options = [False, True]
111 |     disconnected_data = np.random.choice(a=options, size=(10, 30), p=[0.6, 1 - 0.6])
    |

NPY002 Replace legacy `np.random.choice` call with `np.random.Generator`
   --> umap/tests/test_umap_ops.py:111:25
    |
109 | def test_disconnected_data(num_isolates, metric, force_approximation):
110 |     options = [False, True]
111 |     disconnected_data = np.random.choice(a=options, size=(10, 30), p=[0.6, 1 - 0.6])
    |                         ^^^^^^^^^^^^^^^^
112 |     # Add some disconnected data for the corner case test
113 |     disconnected_data = np.vstack(
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_ops.py:147:5
    |
145 | @pytest.mark.parametrize("num_isolates", [1])
146 | @pytest.mark.parametrize("sparse", [True, False])
147 | def test_disconnected_data_precomputed(num_isolates, sparse):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
148 |     disconnected_data = np.random.choice(
149 |         a=[False, True], size=(10, 20), p=[0.66, 1 - 0.66],
    |

NPY002 Replace legacy `np.random.choice` call with `np.random.Generator`
   --> umap/tests/test_umap_ops.py:148:25
    |
146 | @pytest.mark.parametrize("sparse", [True, False])
147 | def test_disconnected_data_precomputed(num_isolates, sparse):
148 |     disconnected_data = np.random.choice(
    |                         ^^^^^^^^^^^^^^^^
149 |         a=[False, True], size=(10, 20), p=[0.66, 1 - 0.66],
150 |     )
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_ops.py:178:5
    |
178 | def test_bad_transform_data(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^
179 |     u = UMAP().fit([[1, 1, 1, 1]])
180 |     with pytest.raises(ValueError):
    |

ARG001 Unused function argument: `nn_data`
   --> umap/tests/test_umap_ops.py:178:29
    |
178 | def test_bad_transform_data(nn_data):
    |                             ^^^^^^^
179 |     u = UMAP().fit([[1, 1, 1, 1]])
180 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_ops.py:180:24
    |
178 | def test_bad_transform_data(nn_data):
179 |     u = UMAP().fit([[1, 1, 1, 1]])
180 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
181 |         u.transform([[0, 0, 0, 0]])
    |

NPY002 Replace legacy `np.random.random` call with `np.random.Generator`
   --> umap/tests/test_umap_ops.py:200:16
    |
198 |     # The important point is that the new data has the same number of rows
199 |     # as the original fit data
200 |     new_data = np.random.random(data.shape)
    |                ^^^^^^^^^^^^^^^^
201 |     _ = fitter.transform(new_data)
    |

NPY002 Replace legacy `np.random.random` call with `np.random.Generator`
   --> umap/tests/test_umap_ops.py:210:9
    |
209 |     # Example from issue #217
210 |     a = np.random.random((100, 10))
    |         ^^^^^^^^^^^^^^^^
211 |     b = np.random.random((100, 5))
    |

NPY002 Replace legacy `np.random.random` call with `np.random.Generator`
   --> umap/tests/test_umap_ops.py:211:9
    |
209 |     # Example from issue #217
210 |     a = np.random.random((100, 10))
211 |     b = np.random.random((100, 5))
    |         ^^^^^^^^^^^^^^^^
212 |
213 |     umap = UMAP(n_epochs=100)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_ops.py:225:5
    |
223 | # UMAP Update
224 | # -----------
225 | def test_umap_update(iris, iris_subset_model, iris_selection, iris_model):
    |     ^^^^^^^^^^^^^^^^
226 |
227 |     new_data = iris.data[~iris_selection]
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_ops.py:243:5
    |
243 | def test_umap_update_large(
    |     ^^^^^^^^^^^^^^^^^^^^^^
244 |     iris, iris_subset_model_large, iris_selection, iris_model_large,
245 | ):
    |

PLR2004 Magic value used in comparison, consider replacing `3.0` with a constant variable
   --> umap/tests/test_umap_ops.py:263:20
    |
261 |     error = np.sum(np.abs((new_model.graph_ - comparison_graph).data))
262 |
263 |     assert error < 3.0  # Higher error tolerance based on approx nearest neighbors
    |                    ^^^
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_ops.py:269:5
    |
267 | # UMAP Graph output
268 | # -----------------
269 | def test_umap_graph_layout():
    |     ^^^^^^^^^^^^^^^^^^^^^^
270 |     data, _labels = make_blobs(n_samples=500, n_features=10, centers=5)
271 |     model = UMAP(n_epochs=100, transform_mode="graph")
    |

PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   --> umap/tests/test_umap_ops.py:275:18
    |
273 |     assert scipy.sparse.issparse(graph)
274 |     nc, _cl = scipy.sparse.csgraph.connected_components(graph)
275 |     assert nc == 5
    |                  ^
276 |
277 |     new_graph = model.transform(data[:10] + np.random.normal(0.0, 0.1, size=(10, 10)))
    |

NPY002 Replace legacy `np.random.normal` call with `np.random.Generator`
   --> umap/tests/test_umap_ops.py:277:45
    |
275 |     assert nc == 5
276 |
277 |     new_graph = model.transform(data[:10] + np.random.normal(0.0, 0.1, size=(10, 10)))
    |                                             ^^^^^^^^^^^^^^^^
278 |     assert scipy.sparse.issparse(graph)
279 |     assert new_graph.shape[0] == 10
    |

PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   --> umap/tests/test_umap_ops.py:279:34
    |
277 |     new_graph = model.transform(data[:10] + np.random.normal(0.0, 0.1, size=(10, 10)))
278 |     assert scipy.sparse.issparse(graph)
279 |     assert new_graph.shape[0] == 10
    |                                  ^^
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_ops.py:287:5
    |
287 | def test_component_layout_options(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
288 |     dmat = pairwise_distances(nn_data[:1000])
289 |     n_components = 5
    |

PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   --> umap/tests/test_umap_ops.py:319:31
    |
317 |     )
318 |
319 |     assert single.shape[0] == 5
    |                               ^
320 |     assert average.shape[0] == 5
321 |     assert complete.shape[0] == 5
    |

PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   --> umap/tests/test_umap_ops.py:320:32
    |
319 |     assert single.shape[0] == 5
320 |     assert average.shape[0] == 5
    |                                ^
321 |     assert complete.shape[0] == 5
    |

PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   --> umap/tests/test_umap_ops.py:321:33
    |
319 |     assert single.shape[0] == 5
320 |     assert average.shape[0] == 5
321 |     assert complete.shape[0] == 5
    |                                 ^
322 |
323 |     assert not np.all(single == average)
    |

D103 Missing docstring in public function
  --> umap/tests/test_umap_repeated_data.py:13:5
   |
13 | def test_repeated_points_large_sparse_spatial(sparse_spatial_data_repeats):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14 |     model = UMAP(
15 |         n_neighbors=3,
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_repeated_data.py:24:5
   |
24 | def test_repeated_points_small_sparse_spatial(sparse_spatial_data_repeats):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |     model = UMAP(n_neighbors=3, unique=True, n_epochs=20).fit(
26 |         sparse_spatial_data_repeats,
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_repeated_data.py:33:5
   |
31 | # Use force_approximation_algorithm in order to test the region
32 | # of the code that is called for n>4096
33 | def test_repeated_points_large_dense_spatial(spatial_repeats):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
34 |     model = UMAP(
35 |         n_neighbors=3, unique=True, force_approximation_algorithm=True, n_epochs=50,
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_repeated_data.py:40:5
   |
40 | def test_repeated_points_small_dense_spatial(spatial_repeats):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
41 |     model = UMAP(n_neighbors=3, unique=True, n_epochs=20).fit(spatial_repeats)
42 |     assert np.unique(model.embedding_[0:2], axis=0).shape[0] == 1
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_repeated_data.py:53:5
   |
53 | def test_repeated_points_large_sparse_binary(sparse_binary_data_repeats):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
54 |     model = UMAP(
55 |         n_neighbors=3, unique=True, force_approximation_algorithm=True, n_epochs=50,
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_repeated_data.py:60:5
   |
60 | def test_repeated_points_small_sparse_binary(sparse_binary_data_repeats):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
61 |     model = UMAP(n_neighbors=3, unique=True, n_epochs=20).fit(
62 |         sparse_binary_data_repeats,
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_repeated_data.py:69:5
   |
67 | # Use force_approximation_algorithm in order to test
68 | # the region of the code that is called for n>4096
69 | def test_repeated_points_large_dense_binary(binary_repeats):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
70 |     model = UMAP(
71 |         n_neighbors=3, unique=True, force_approximation_algorithm=True, n_epochs=20,
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_repeated_data.py:76:5
   |
76 | def test_repeated_points_small_dense_binary(binary_repeats):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
77 |     model = UMAP(n_neighbors=3, unique=True, n_epochs=20).fit(binary_repeats)
78 |     assert np.unique(binary_repeats[0:2], axis=0).shape[0] == 1
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_repeated_data.py:92:5
   |
90 | # than the unique data set size
91 | # ----------------------------------------------------
92 | def test_repeated_points_large_n(repetition_dense):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
93 |     model = UMAP(n_neighbors=5, unique=True, n_epochs=20).fit(repetition_dense)
94 |     assert model._n_neighbors == 3
   |

SLF001 Private member accessed: `_n_neighbors`
  --> umap/tests/test_umap_repeated_data.py:94:12
   |
92 | def test_repeated_points_large_n(repetition_dense):
93 |     model = UMAP(n_neighbors=5, unique=True, n_epochs=20).fit(repetition_dense)
94 |     assert model._n_neighbors == 3
   |            ^^^^^^^^^^^^^^^^^^
   |

PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
  --> umap/tests/test_umap_repeated_data.py:94:34
   |
92 | def test_repeated_points_large_n(repetition_dense):
93 |     model = UMAP(n_neighbors=5, unique=True, n_epochs=20).fit(repetition_dense)
94 |     assert model._n_neighbors == 3
   |                                  ^
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_trustworthiness.py:23:5
   |
23 | def test_umap_sparse_trustworthiness(sparse_test_data):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
24 |     embedding = UMAP(n_neighbors=10, n_epochs=100).fit_transform(sparse_test_data[:100])
25 |     trust = trustworthiness(sparse_test_data[:100].toarray(), embedding, n_neighbors=10)
   |

PLR2004 Magic value used in comparison, consider replacing `0.88` with a constant variable
  --> umap/tests/test_umap_trustworthiness.py:27:18
   |
25 |     trust = trustworthiness(sparse_test_data[:100].toarray(), embedding, n_neighbors=10)
26 |     assert (
27 |         trust >= 0.88
   |                  ^^^^
28 |     ), f"Insufficiently trustworthy embedding for sparse test dataset: {trust}"
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_trustworthiness.py:31:5
   |
31 | def test_umap_trustworthiness_fast_approx(nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
32 |     data = nn_data[:50]
33 |     embedding = UMAP(
   |

PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
  --> umap/tests/test_umap_trustworthiness.py:42:18
   |
40 |     trust = trustworthiness(data, embedding, n_neighbors=10)
41 |     assert (
42 |         trust >= 0.8
   |                  ^^^
43 |     ), f"Insufficiently trustworthy embedding fornn dataset: {trust}"
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_trustworthiness.py:46:5
   |
46 | def test_umap_trustworthiness_random_init(nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
47 |     data = nn_data[:50]
48 |     embedding = UMAP(
   |

PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
  --> umap/tests/test_umap_trustworthiness.py:53:18
   |
51 |     trust = trustworthiness(data, embedding, n_neighbors=10)
52 |     assert (
53 |         trust >= 0.8
   |                  ^^^
54 |     ), f"Insufficiently trustworthy embedding fornn dataset: {trust}"
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_trustworthiness.py:57:5
   |
57 | def test_supervised_umap_trustworthiness():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
58 |     data, labels = make_blobs(50, cluster_std=0.5, random_state=42)
59 |     embedding = UMAP(
   |

PLR2004 Magic value used in comparison, consider replacing `0.95` with a constant variable
  --> umap/tests/test_umap_trustworthiness.py:64:18
   |
62 |     trust = trustworthiness(data, embedding, n_neighbors=10)
63 |     assert (
64 |         trust >= 0.95
   |                  ^^^^
65 |     ), f"Insufficiently trustworthy embedding forblobs dataset: {trust}"
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_trustworthiness.py:68:5
   |
68 | def test_semisupervised_umap_trustworthiness():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
69 |     data, labels = make_blobs(50, cluster_std=0.5, random_state=42)
70 |     labels[10:30] = -1
   |

PLR2004 Magic value used in comparison, consider replacing `0.95` with a constant variable
  --> umap/tests/test_umap_trustworthiness.py:76:18
   |
74 |     trust = trustworthiness(data, embedding, n_neighbors=10)
75 |     assert (
76 |         trust >= 0.95
   |                  ^^^^
77 |     ), f"Insufficiently trustworthy embedding forblobs dataset: {trust}"
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_trustworthiness.py:80:5
   |
80 | def test_metric_supervised_umap_trustworthiness():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
81 |     data, labels = make_blobs(50, cluster_std=0.5, random_state=42)
82 |     embedding = UMAP(
   |

PLR2004 Magic value used in comparison, consider replacing `0.95` with a constant variable
  --> umap/tests/test_umap_trustworthiness.py:92:18
   |
90 |     trust = trustworthiness(data, embedding, n_neighbors=10)
91 |     assert (
92 |         trust >= 0.95
   |                  ^^^^
93 |     ), f"Insufficiently trustworthy embedding forblobs dataset: {trust}"
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_trustworthiness.py:96:5
   |
96 | def test_string_metric_supervised_umap_trustworthiness():
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
97 |     data, labels = make_blobs(50, cluster_std=0.5, random_state=42)
98 |     labels = np.array(["this", "that", "other"])[labels]
   |

PLR2004 Magic value used in comparison, consider replacing `0.95` with a constant variable
   --> umap/tests/test_umap_trustworthiness.py:109:18
    |
107 |     trust = trustworthiness(data, embedding, n_neighbors=10)
108 |     assert (
109 |         trust >= 0.95
    |                  ^^^^
110 |     ), f"Insufficiently trustworthy embedding forblobs dataset: {trust}"
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_trustworthiness.py:113:5
    |
113 | def test_discrete_metric_supervised_umap_trustworthiness():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
114 |     data, labels = make_blobs(50, cluster_std=0.5, random_state=42)
115 |     embedding = UMAP(
    |

PLR2004 Magic value used in comparison, consider replacing `0.95` with a constant variable
   --> umap/tests/test_umap_trustworthiness.py:125:18
    |
123 |     trust = trustworthiness(data, embedding, n_neighbors=10)
124 |     assert (
125 |         trust >= 0.95
    |                  ^^^^
126 |     ), f"Insufficiently trustworthy embedding forblobs dataset: {trust}"
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_trustworthiness.py:129:5
    |
129 | def test_count_metric_supervised_umap_trustworthiness():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
130 |     data, labels = make_blobs(50, cluster_std=0.5, random_state=42)
131 |     labels = (labels**2) + 2 * labels
    |

PLR2004 Magic value used in comparison, consider replacing `0.95` with a constant variable
   --> umap/tests/test_umap_trustworthiness.py:142:18
    |
140 |     trust = trustworthiness(data, embedding, n_neighbors=10)
141 |     assert (
142 |         trust >= 0.95
    |                  ^^^^
143 |     ), f"Insufficiently trustworthy embedding forblobs dataset: {trust}"
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_trustworthiness.py:146:5
    |
146 | def test_sparse_precomputed_metric_umap_trustworthiness():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
147 |     data, _labels = make_blobs(50, cluster_std=0.5, random_state=42)
148 |     dmat = scipy.sparse.csr_matrix(pairwise_distances(data))
    |

PLR2004 Magic value used in comparison, consider replacing `0.75` with a constant variable
   --> umap/tests/test_umap_trustworthiness.py:158:18
    |
156 |     trust = trustworthiness(data, embedding, n_neighbors=10)
157 |     assert (
158 |         trust >= 0.75
    |                  ^^^^
159 |     ), f"Insufficiently trustworthy embedding fornn dataset: {trust}"
    |

D103 Missing docstring in public function
  --> umap/tests/test_umap_validation_params.py:18:5
   |
18 | def test_umap_negative_op(nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^^
19 |     u = UMAP(set_op_mix_ratio=-1.0)
20 |     with pytest.raises(ValueError):
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_umap_validation_params.py:20:24
   |
18 | def test_umap_negative_op(nn_data):
19 |     u = UMAP(set_op_mix_ratio=-1.0)
20 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
21 |         u.fit(nn_data)
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_validation_params.py:24:5
   |
24 | def test_umap_too_large_op(nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^^^
25 |     u = UMAP(set_op_mix_ratio=1.5)
26 |     with pytest.raises(ValueError):
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_umap_validation_params.py:26:24
   |
24 | def test_umap_too_large_op(nn_data):
25 |     u = UMAP(set_op_mix_ratio=1.5)
26 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
27 |         u.fit(nn_data)
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_validation_params.py:30:5
   |
30 | def test_umap_bad_too_large_min_dist(nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
31 |     u = UMAP(min_dist=2.0)
32 |     # a RuntimeWarning about division by zero in a,b curve fitting is expected
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_umap_validation_params.py:36:28
   |
34 |     with warnings.catch_warnings():
35 |         warnings.filterwarnings("ignore", category=RuntimeWarning)
36 |         with pytest.raises(ValueError):
   |                            ^^^^^^^^^^
37 |             u.fit(nn_data)
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_validation_params.py:40:5
   |
40 | def test_umap_negative_min_dist(nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
41 |     u = UMAP(min_dist=-1)
42 |     with pytest.raises(ValueError):
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_umap_validation_params.py:42:24
   |
40 | def test_umap_negative_min_dist(nn_data):
41 |     u = UMAP(min_dist=-1)
42 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
43 |         u.fit(nn_data)
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_validation_params.py:46:5
   |
46 | def test_umap_negative_n_components(nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
47 |     u = UMAP(n_components=-1)
48 |     with pytest.raises(ValueError):
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_umap_validation_params.py:48:24
   |
46 | def test_umap_negative_n_components(nn_data):
47 |     u = UMAP(n_components=-1)
48 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
49 |         u.fit(nn_data)
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_validation_params.py:52:5
   |
52 | def test_umap_non_integer_n_components(nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
53 |     u = UMAP(n_components=1.5)
54 |     with pytest.raises(ValueError):
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_umap_validation_params.py:54:24
   |
52 | def test_umap_non_integer_n_components(nn_data):
53 |     u = UMAP(n_components=1.5)
54 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
55 |         u.fit(nn_data)
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_validation_params.py:58:5
   |
58 | def test_umap_too_small_n_neighbours(nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
59 |     u = UMAP(n_neighbors=0.5)
60 |     with pytest.raises(ValueError):
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_umap_validation_params.py:60:24
   |
58 | def test_umap_too_small_n_neighbours(nn_data):
59 |     u = UMAP(n_neighbors=0.5)
60 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
61 |         u.fit(nn_data)
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_validation_params.py:64:5
   |
64 | def test_umap_negative_n_neighbours(nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
65 |     u = UMAP(n_neighbors=-1)
66 |     with pytest.raises(ValueError):
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_umap_validation_params.py:66:24
   |
64 | def test_umap_negative_n_neighbours(nn_data):
65 |     u = UMAP(n_neighbors=-1)
66 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
67 |         u.fit(nn_data)
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_validation_params.py:70:5
   |
70 | def test_umap_bad_metric(nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^
71 |     u = UMAP(metric=45)
72 |     with pytest.raises(ValueError):
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_umap_validation_params.py:72:24
   |
70 | def test_umap_bad_metric(nn_data):
71 |     u = UMAP(metric=45)
72 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
73 |         u.fit(nn_data)
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_validation_params.py:76:5
   |
76 | def test_umap_negative_learning_rate(nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
77 |     u = UMAP(learning_rate=-1.5)
78 |     with pytest.raises(ValueError):
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_umap_validation_params.py:78:24
   |
76 | def test_umap_negative_learning_rate(nn_data):
77 |     u = UMAP(learning_rate=-1.5)
78 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
79 |         u.fit(nn_data)
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_validation_params.py:82:5
   |
82 | def test_umap_negative_repulsion(nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
83 |     u = UMAP(repulsion_strength=-0.5)
84 |     with pytest.raises(ValueError):
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_umap_validation_params.py:84:24
   |
82 | def test_umap_negative_repulsion(nn_data):
83 |     u = UMAP(repulsion_strength=-0.5)
84 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
85 |         u.fit(nn_data)
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_validation_params.py:88:5
   |
88 | def test_umap_negative_sample_rate(nn_data):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
89 |     u = UMAP(negative_sample_rate=-1)
90 |     with pytest.raises(ValueError):
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_umap_validation_params.py:90:24
   |
88 | def test_umap_negative_sample_rate(nn_data):
89 |     u = UMAP(negative_sample_rate=-1)
90 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
91 |         u.fit(nn_data)
   |

D103 Missing docstring in public function
  --> umap/tests/test_umap_validation_params.py:94:5
   |
94 | def test_umap_bad_init(nn_data):
   |     ^^^^^^^^^^^^^^^^^^
95 |     u = UMAP(init="foobar")
96 |     with pytest.raises(ValueError):
   |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
  --> umap/tests/test_umap_validation_params.py:96:24
   |
94 | def test_umap_bad_init(nn_data):
95 |     u = UMAP(init="foobar")
96 |     with pytest.raises(ValueError):
   |                        ^^^^^^^^^^
97 |         u.fit(nn_data)
   |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:100:5
    |
100 | def test_umap_bad_numeric_init(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
101 |     u = UMAP(init=42)
102 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:102:24
    |
100 | def test_umap_bad_numeric_init(nn_data):
101 |     u = UMAP(init=42)
102 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
103 |         u.fit(nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:106:5
    |
106 | def test_umap_bad_matrix_init(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
107 |     u = UMAP(init=np.array([[0, 0, 0], [0, 0, 0]]))
108 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:108:24
    |
106 | def test_umap_bad_matrix_init(nn_data):
107 |     u = UMAP(init=np.array([[0, 0, 0], [0, 0, 0]]))
108 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
109 |         u.fit(nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:112:5
    |
112 | def test_umap_negative_n_epochs(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
113 |     u = UMAP(n_epochs=-2)
114 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:114:24
    |
112 | def test_umap_negative_n_epochs(nn_data):
113 |     u = UMAP(n_epochs=-2)
114 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
115 |         u.fit(nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:118:5
    |
118 | def test_umap_negative_target_n_neighbours(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
119 |     u = UMAP(target_n_neighbors=1)
120 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:120:24
    |
118 | def test_umap_negative_target_n_neighbours(nn_data):
119 |     u = UMAP(target_n_neighbors=1)
120 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
121 |         u.fit(nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:124:5
    |
124 | def test_umap_bad_output_metric(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
125 |     u = UMAP(output_metric="foobar")
126 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:126:24
    |
124 | def test_umap_bad_output_metric(nn_data):
125 |     u = UMAP(output_metric="foobar")
126 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
127 |         u.fit(nn_data)
128 |     u = UMAP(output_metric="precomputed")
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:129:24
    |
127 |         u.fit(nn_data)
128 |     u = UMAP(output_metric="precomputed")
129 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
130 |         u.fit(nn_data)
131 |     u = UMAP(output_metric="hamming")
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:132:24
    |
130 |         u.fit(nn_data)
131 |     u = UMAP(output_metric="hamming")
132 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
133 |         u.fit(nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:136:5
    |
136 | def test_haversine_on_highd(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^
137 |     u = UMAP(metric="haversine")
138 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:138:24
    |
136 | def test_haversine_on_highd(nn_data):
137 |     u = UMAP(metric="haversine")
138 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
139 |         u.fit(nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:142:5
    |
142 | def test_umap_haversine_embed_to_highd(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
143 |     u = UMAP(n_components=3, output_metric="haversine")
144 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:144:24
    |
142 | def test_umap_haversine_embed_to_highd(nn_data):
143 |     u = UMAP(n_components=3, output_metric="haversine")
144 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
145 |         u.fit(nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:148:5
    |
148 | def test_umap_too_many_neighbors_warns(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
149 |     u = UMAP(a=1.2, b=1.75, n_neighbors=2000, n_epochs=11, init="random")
150 |     u.fit(nn_data[:100,])
    |

SLF001 Private member accessed: `_a`
   --> umap/tests/test_umap_validation_params.py:151:12
    |
149 |     u = UMAP(a=1.2, b=1.75, n_neighbors=2000, n_epochs=11, init="random")
150 |     u.fit(nn_data[:100,])
151 |     assert u._a == 1.2
    |            ^^^^
152 |     assert u._b == 1.75
    |

PLR2004 Magic value used in comparison, consider replacing `1.2` with a constant variable
   --> umap/tests/test_umap_validation_params.py:151:20
    |
149 |     u = UMAP(a=1.2, b=1.75, n_neighbors=2000, n_epochs=11, init="random")
150 |     u.fit(nn_data[:100,])
151 |     assert u._a == 1.2
    |                    ^^^
152 |     assert u._b == 1.75
    |

SLF001 Private member accessed: `_b`
   --> umap/tests/test_umap_validation_params.py:152:12
    |
150 |     u.fit(nn_data[:100,])
151 |     assert u._a == 1.2
152 |     assert u._b == 1.75
    |            ^^^^
    |

PLR2004 Magic value used in comparison, consider replacing `1.75` with a constant variable
   --> umap/tests/test_umap_validation_params.py:152:20
    |
150 |     u.fit(nn_data[:100,])
151 |     assert u._a == 1.2
152 |     assert u._b == 1.75
    |                    ^^^^
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:155:5
    |
155 | def test_densmap_lambda(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^
156 |     u = UMAP(densmap=True, dens_lambda=-1.0)
157 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:157:24
    |
155 | def test_densmap_lambda(nn_data):
156 |     u = UMAP(densmap=True, dens_lambda=-1.0)
157 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
158 |         u.fit(nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:161:5
    |
161 | def test_densmap_var_shift(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^
162 |     u = UMAP(densmap=True, dens_var_shift=-1.0)
163 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:163:24
    |
161 | def test_densmap_var_shift(nn_data):
162 |     u = UMAP(densmap=True, dens_var_shift=-1.0)
163 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
164 |         u.fit(nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:167:5
    |
167 | def test_densmap_frac(nn_data):
    |     ^^^^^^^^^^^^^^^^^
168 |     u = UMAP(densmap=True, dens_frac=-1.0)
169 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:169:24
    |
167 | def test_densmap_frac(nn_data):
168 |     u = UMAP(densmap=True, dens_frac=-1.0)
169 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
170 |         u.fit(nn_data)
171 |     u = UMAP(densmap=True, dens_frac=2.0)
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:172:24
    |
170 |         u.fit(nn_data)
171 |     u = UMAP(densmap=True, dens_frac=2.0)
172 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
173 |         u.fit(nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:176:5
    |
176 | def test_umap_unique_and_precomputed(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
177 |     u = UMAP(metric="precomputed", unique=True)
178 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:178:24
    |
176 | def test_umap_unique_and_precomputed(nn_data):
177 |     u = UMAP(metric="precomputed", unique=True)
178 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
179 |         u.fit(nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:182:5
    |
182 | def test_densmap_bad_output_metric(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
183 |     u = UMAP(densmap=True, output_metric="haversine")
184 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:184:24
    |
182 | def test_densmap_bad_output_metric(nn_data):
183 |     u = UMAP(densmap=True, output_metric="haversine")
184 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
185 |         u.fit(nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:188:5
    |
188 | def test_umap_bad_n_components(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
189 |     u = UMAP(n_components=2.3)
190 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:190:24
    |
188 | def test_umap_bad_n_components(nn_data):
189 |     u = UMAP(n_components=2.3)
190 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
191 |         u.fit(nn_data)
192 |     u = UMAP(n_components="23")
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:193:24
    |
191 |         u.fit(nn_data)
192 |     u = UMAP(n_components="23")
193 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
194 |         u.fit(nn_data)
195 |     u = UMAP(n_components=np.float64(2.3))
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:196:24
    |
194 |         u.fit(nn_data)
195 |     u = UMAP(n_components=np.float64(2.3))
196 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
197 |         u.fit(nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:200:5
    |
200 | def test_umap_bad_metrics(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^
201 |     u = UMAP(metric="foobar")
202 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:202:24
    |
200 | def test_umap_bad_metrics(nn_data):
201 |     u = UMAP(metric="foobar")
202 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
203 |         u.fit(nn_data)
204 |     u = UMAP(metric=2.75)
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:205:24
    |
203 |         u.fit(nn_data)
204 |     u = UMAP(metric=2.75)
205 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
206 |         u.fit(nn_data)
207 |     u = UMAP(output_metric="foobar")
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:208:24
    |
206 |         u.fit(nn_data)
207 |     u = UMAP(output_metric="foobar")
208 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
209 |         u.fit(nn_data)
210 |     u = UMAP(output_metric=2.75)
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:211:24
    |
209 |         u.fit(nn_data)
210 |     u = UMAP(output_metric=2.75)
211 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
212 |         u.fit(nn_data)
213 |     # u = UMAP(target_metric="foobar")
    |

ERA001 Found commented-out code
   --> umap/tests/test_umap_validation_params.py:213:5
    |
211 |     with pytest.raises(ValueError):
212 |         u.fit(nn_data)
213 |     # u = UMAP(target_metric="foobar")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
214 |     # assert_raises(ValueError, u.fit, nn_data)
215 |     # u = UMAP(target_metric=2.75)
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> umap/tests/test_umap_validation_params.py:214:5
    |
212 |         u.fit(nn_data)
213 |     # u = UMAP(target_metric="foobar")
214 |     # assert_raises(ValueError, u.fit, nn_data)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
215 |     # u = UMAP(target_metric=2.75)
216 |     # assert_raises(ValueError, u.fit, nn_data)
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> umap/tests/test_umap_validation_params.py:215:5
    |
213 |     # u = UMAP(target_metric="foobar")
214 |     # assert_raises(ValueError, u.fit, nn_data)
215 |     # u = UMAP(target_metric=2.75)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
216 |     # assert_raises(ValueError, u.fit, nn_data)
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> umap/tests/test_umap_validation_params.py:216:5
    |
214 |     # assert_raises(ValueError, u.fit, nn_data)
215 |     # u = UMAP(target_metric=2.75)
216 |     # assert_raises(ValueError, u.fit, nn_data)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: Remove commented-out code

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:219:5
    |
219 | def test_umap_bad_n_jobs(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^
220 |     u = UMAP(n_jobs=-2)
221 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:221:24
    |
219 | def test_umap_bad_n_jobs(nn_data):
220 |     u = UMAP(n_jobs=-2)
221 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
222 |         u.fit(nn_data)
223 |     u = UMAP(n_jobs=0)
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:224:24
    |
222 |         u.fit(nn_data)
223 |     u = UMAP(n_jobs=0)
224 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
225 |         u.fit(nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:228:5
    |
228 | def test_umap_custom_distance_w_grad(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
229 |     @numba.njit()
230 |     def dist1(x, y):
    |

PT030 `pytest.warns(UserWarning)` is too broad, set the `match` parameter or use a more specific warning
   --> umap/tests/test_umap_validation_params.py:238:23
    |
237 |     u = UMAP(metric=dist1, n_epochs=11)
238 |     with pytest.warns(UserWarning) as warnings:
    |                       ^^^^^^^^^^^
239 |         u.fit(nn_data[:10])
240 |     assert len(warnings) >= 1
    |

PT030 `pytest.warns(UserWarning)` is too broad, set the `match` parameter or use a more specific warning
   --> umap/tests/test_umap_validation_params.py:243:23
    |
242 |     u = UMAP(metric=dist2, n_epochs=11)
243 |     with pytest.warns(UserWarning) as warnings:
    |                       ^^^^^^^^^^^
244 |         u.fit(nn_data[:10])
245 |     assert len(warnings) <= 1
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:248:5
    |
248 | def test_umap_bad_output_metric_no_grad(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
249 |     @numba.njit()
250 |     def dist1(x, y):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:254:24
    |
253 |     u = UMAP(output_metric=dist1)
254 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
255 |         u.fit(nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:258:5
    |
258 | def test_umap_bad_hellinger_data(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
259 |     u = UMAP(metric="hellinger")
260 |     with pytest.raises(ValueError):
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:260:24
    |
258 | def test_umap_bad_hellinger_data(nn_data):
259 |     u = UMAP(metric="hellinger")
260 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
261 |         u.fit(-nn_data)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:264:5
    |
264 | def test_umap_update_bad_params(nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
265 |     dmat = pairwise_distances(nn_data[:100])
266 |     u = UMAP(metric="precomputed", n_epochs=11)
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:268:24
    |
266 |     u = UMAP(metric="precomputed", n_epochs=11)
267 |     u.fit(dmat)
268 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
269 |         u.update(dmat)
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:273:24
    |
271 |     u = UMAP(n_epochs=11)
272 |     u.fit(nn_data[:100], y=np.repeat(np.arange(5), 20))
273 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
274 |         u.update(nn_data[100:200])
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:277:5
    |
277 | def test_umap_fit_data_and_targets_compliant():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
278 |     # x and y are required to be the same length
279 |     u = UMAP()
    |

NPY002 Replace legacy `np.random.uniform` call with `np.random.Generator`
   --> umap/tests/test_umap_validation_params.py:280:9
    |
278 |     # x and y are required to be the same length
279 |     u = UMAP()
280 |     x = np.random.uniform(0, 1, (256, 10))
    |         ^^^^^^^^^^^^^^^^^
281 |     y = np.random.randint(10, size=(257,))
282 |     with pytest.raises(ValueError):
    |

NPY002 Replace legacy `np.random.randint` call with `np.random.Generator`
   --> umap/tests/test_umap_validation_params.py:281:9
    |
279 |     u = UMAP()
280 |     x = np.random.uniform(0, 1, (256, 10))
281 |     y = np.random.randint(10, size=(257,))
    |         ^^^^^^^^^^^^^^^^^
282 |     with pytest.raises(ValueError):
283 |         u.fit(x, y)
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:282:24
    |
280 |     x = np.random.uniform(0, 1, (256, 10))
281 |     y = np.random.randint(10, size=(257,))
282 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
283 |         u.fit(x, y)
    |

NPY002 Replace legacy `np.random.uniform` call with `np.random.Generator`
   --> umap/tests/test_umap_validation_params.py:286:9
    |
285 |     u = UMAP()
286 |     x = np.random.uniform(0, 1, (256, 10))
    |         ^^^^^^^^^^^^^^^^^
287 |     y = np.random.randint(10, size=(255,))
288 |     with pytest.raises(ValueError):
    |

NPY002 Replace legacy `np.random.randint` call with `np.random.Generator`
   --> umap/tests/test_umap_validation_params.py:287:9
    |
285 |     u = UMAP()
286 |     x = np.random.uniform(0, 1, (256, 10))
287 |     y = np.random.randint(10, size=(255,))
    |         ^^^^^^^^^^^^^^^^^
288 |     with pytest.raises(ValueError):
289 |         u.fit(x, y)
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:288:24
    |
286 |     x = np.random.uniform(0, 1, (256, 10))
287 |     y = np.random.randint(10, size=(255,))
288 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
289 |         u.fit(x, y)
    |

NPY002 Replace legacy `np.random.uniform` call with `np.random.Generator`
   --> umap/tests/test_umap_validation_params.py:292:9
    |
291 |     u = UMAP()
292 |     x = np.random.uniform(0, 1, (256, 10))
    |         ^^^^^^^^^^^^^^^^^
293 |     with pytest.raises(ValueError):
294 |         u.fit(x, [])
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:293:24
    |
291 |     u = UMAP()
292 |     x = np.random.uniform(0, 1, (256, 10))
293 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
294 |         u.fit(x, [])
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:297:5
    |
297 | def test_umap_fit_instance_returned():
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
298 |     # Test that fit returns a new UMAP instance
    |

NPY002 Replace legacy `np.random.uniform` call with `np.random.Generator`
   --> umap/tests/test_umap_validation_params.py:302:9
    |
300 |     # Passing both data and targets
301 |     u = UMAP()
302 |     x = np.random.uniform(0, 1, (256, 10))
    |         ^^^^^^^^^^^^^^^^^
303 |     y = np.random.randint(10, size=(256,))
304 |     res = u.fit(x, y)
    |

NPY002 Replace legacy `np.random.randint` call with `np.random.Generator`
   --> umap/tests/test_umap_validation_params.py:303:9
    |
301 |     u = UMAP()
302 |     x = np.random.uniform(0, 1, (256, 10))
303 |     y = np.random.randint(10, size=(256,))
    |         ^^^^^^^^^^^^^^^^^
304 |     res = u.fit(x, y)
305 |     assert isinstance(res, UMAP)
    |

NPY002 Replace legacy `np.random.uniform` call with `np.random.Generator`
   --> umap/tests/test_umap_validation_params.py:309:9
    |
307 |     # Passing only data
308 |     u = UMAP()
309 |     x = np.random.uniform(0, 1, (256, 10))
    |         ^^^^^^^^^^^^^^^^^
310 |     res = u.fit(x)
311 |     assert isinstance(res, UMAP)
    |

D103 Missing docstring in public function
   --> umap/tests/test_umap_validation_params.py:314:5
    |
314 | def test_umap_inverse_transform_fails_expectedly(sparse_spatial_data, nn_data):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
315 |     u = UMAP(n_epochs=11)
316 |     u.fit(sparse_spatial_data[:100])
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:317:24
    |
315 |     u = UMAP(n_epochs=11)
316 |     u.fit(sparse_spatial_data[:100])
317 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
318 |         u.inverse_transform(u.embedding_[:10])
319 |     u = UMAP(metric="dice", n_epochs=11)
    |

PT011 `pytest.raises(ValueError)` is too broad, set the `match` parameter or use a more specific exception
   --> umap/tests/test_umap_validation_params.py:321:24
    |
319 |     u = UMAP(metric="dice", n_epochs=11)
320 |     u.fit(nn_data[:100])
321 |     with pytest.raises(ValueError):
    |                        ^^^^^^^^^^
322 |         u.inverse_transform(u.embedding_[:10])
    |

D103 Missing docstring in public function
  --> umap/umap_.py:66:5
   |
66 | def flatten_iter(container):
   |     ^^^^^^^^^^^^
67 |     for i in container:
68 |         if isinstance(i, (list, tuple)):
   |

D103 Missing docstring in public function
  --> umap/umap_.py:74:5
   |
74 | def flattened(container):
   |     ^^^^^^^^^
75 |     return tuple(flatten_iter(container))
   |

D103 Missing docstring in public function
  --> umap/umap_.py:78:5
   |
78 | def breadth_first_search(adjmat, start, min_vertices):
   |     ^^^^^^^^^^^^^^^^^^^^
79 |     explored = []
80 |     queue = [start]
   |

PLR0913 Too many arguments in function definition (6 > 5)
   --> umap/umap_.py:104:5
    |
104 | def raise_disconnected_warning(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
105 |     edges_removed,
106 |     vertices_disconnected,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/umap_.py:110:5
    |
108 |     total_rows,
109 |     threshold=0.1,
110 |     verbose=False,
    |     ^^^^^^^
111 | ):
112 |     """A simple wrapper function to avoid large amounts of code repetition."""
    |

D401 First line of docstring should be in imperative mood: "A simple wrapper function to avoid large amounts of code repetition."
   --> umap/umap_.py:112:5
    |
110 |     verbose=False,
111 | ):
112 |     """A simple wrapper function to avoid large amounts of code repetition."""
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
113 |     if verbose & (vertices_disconnected == 0) & (edges_removed > 0):
114 |         pass
    |

C901 `smooth_knn_dist` is too complex (14 > 10)
   --> umap/umap_.py:143:5
    |
141 |     fastmath=True,
142 | )  # benchmarking `parallel=True` shows it to *decrease* performance
143 | def smooth_knn_dist(distances, k, n_iter=64, local_connectivity=1.0, bandwidth=1.0):
    |     ^^^^^^^^^^^^^^^
144 |     """Compute a continuous version of the distance to the kth nearest
145 |     neighbor. That is, this is similar to knn-distance but allows continuous
    |

PLR0912 Too many branches (17 > 12)
   --> umap/umap_.py:143:5
    |
141 |     fastmath=True,
142 | )  # benchmarking `parallel=True` shows it to *decrease* performance
143 | def smooth_knn_dist(distances, k, n_iter=64, local_connectivity=1.0, bandwidth=1.0):
    |     ^^^^^^^^^^^^^^^
144 |     """Compute a continuous version of the distance to the kth nearest
145 |     neighbor. That is, this is similar to knn-distance but allows continuous
    |

D205 1 blank line required between summary line and description
   --> umap/umap_.py:144:5
    |
142 |   )  # benchmarking `parallel=True` shows it to *decrease* performance
143 |   def smooth_knn_dist(distances, k, n_iter=64, local_connectivity=1.0, bandwidth=1.0):
144 | /     """Compute a continuous version of the distance to the kth nearest
145 | |     neighbor. That is, this is similar to knn-distance but allows continuous
146 | |     k values rather than requiring an integral k. In essence we are simply
147 | |     computing the distance such that the cardinality of fuzzy set we generate
148 | |     is k.
149 | |
150 | |     Parameters
151 | |     ----------
152 | |     distances: array of shape (n_samples, n_neighbors)
153 | |         Distances to nearest neighbors for each sample. Each row should be a
154 | |         sorted list of distances to a given samples nearest neighbors.
155 | |
156 | |     k: float
157 | |         The number of nearest neighbors to approximate for.
158 | |
159 | |     n_iter: int (optional, default 64)
160 | |         We need to binary search for the correct distance value. This is the
161 | |         max number of iterations to use in such a search.
162 | |
163 | |     local_connectivity: int (optional, default 1)
164 | |         The local connectivity required -- i.e. the number of nearest
165 | |         neighbors that should be assumed to be connected at a local level.
166 | |         The higher this value the more connected the manifold becomes
167 | |         locally. In practice this should be not more than the local intrinsic
168 | |         dimension of the manifold.
169 | |
170 | |     bandwidth: float (optional, default 1)
171 | |         The target bandwidth of the kernel, larger values will produce
172 | |         larger return values.
173 | |
174 | |     Returns
175 | |     -------
176 | |     knn_dist: array of shape (n_samples,)
177 | |         The distance to kth nearest neighbor, as suitably approximated.
178 | |
179 | |     nn_dist: array of shape (n_samples,)
180 | |         The distance to the 1st nearest neighbor for each point.
181 | |
182 | |     """
    | |_______^
183 |       target = np.log2(k) * bandwidth
184 |       rho = np.zeros(distances.shape[0], dtype=np.float32)
    |
help: Insert single blank line

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> umap/umap_.py:194:11
    |
192 |         mid = 1.0
193 |
194 |         # TODO: This is very inefficient, but will do for now. FIXME
    |           ^^^^
195 |         ith_distances = distances[i]
196 |         non_zero_dists = ith_distances[ith_distances > 0.0]
    |

TD003 Missing issue link for this TODO
   --> umap/umap_.py:194:11
    |
192 |         mid = 1.0
193 |
194 |         # TODO: This is very inefficient, but will do for now. FIXME
    |           ^^^^
195 |         ith_distances = distances[i]
196 |         non_zero_dists = ith_distances[ith_distances > 0.0]
    |

FIX002 Line contains TODO, consider resolving the issue
   --> umap/umap_.py:194:11
    |
192 |         mid = 1.0
193 |
194 |         # TODO: This is very inefficient, but will do for now. FIXME
    |           ^^^^
195 |         ith_distances = distances[i]
196 |         non_zero_dists = ith_distances[ith_distances > 0.0]
    |

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> umap/umap_.py:236:11
    |
234 |         result[i] = mid
235 |
236 |         # TODO: This is very inefficient, but will do for now. FIXME
    |           ^^^^
237 |         if rho[i] > 0.0:
238 |             mean_ith_distances = np.mean(ith_distances)
    |

TD003 Missing issue link for this TODO
   --> umap/umap_.py:236:11
    |
234 |         result[i] = mid
235 |
236 |         # TODO: This is very inefficient, but will do for now. FIXME
    |           ^^^^
237 |         if rho[i] > 0.0:
238 |             mean_ith_distances = np.mean(ith_distances)
    |

FIX002 Line contains TODO, consider resolving the issue
   --> umap/umap_.py:236:11
    |
234 |         result[i] = mid
235 |
236 |         # TODO: This is very inefficient, but will do for now. FIXME
    |           ^^^^
237 |         if rho[i] > 0.0:
238 |             mean_ith_distances = np.mean(ith_distances)
    |

PLR0913 Too many arguments in function definition (10 > 5)
   --> umap/umap_.py:246:5
    |
246 | def nearest_neighbors(
    |     ^^^^^^^^^^^^^^^^^
247 |     X,
248 |     n_neighbors,
    |

D417 Missing argument descriptions in the docstring for `nearest_neighbors`: `n_jobs`, `use_pynndescent`
   --> umap/umap_.py:246:5
    |
246 | def nearest_neighbors(
    |     ^^^^^^^^^^^^^^^^^
247 |     X,
248 |     n_neighbors,
    |

N803 Argument name `X` should be lowercase
   --> umap/umap_.py:247:5
    |
246 | def nearest_neighbors(
247 |     X,
    |     ^
248 |     n_neighbors,
249 |     metric,
    |

ARG001 Unused function argument: `angular`
   --> umap/umap_.py:251:5
    |
249 |     metric,
250 |     metric_kwds,
251 |     angular,
    |     ^^^^^^^
252 |     random_state,
253 |     low_memory=True,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/umap_.py:253:5
    |
251 |     angular,
252 |     random_state,
253 |     low_memory=True,
    |     ^^^^^^^^^^
254 |     use_pynndescent=True,
255 |     n_jobs=-1,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/umap_.py:254:5
    |
252 |     random_state,
253 |     low_memory=True,
254 |     use_pynndescent=True,
    |     ^^^^^^^^^^^^^^^
255 |     n_jobs=-1,
256 |     verbose=False,
    |

ARG001 Unused function argument: `use_pynndescent`
   --> umap/umap_.py:254:5
    |
252 |     random_state,
253 |     low_memory=True,
254 |     use_pynndescent=True,
    |     ^^^^^^^^^^^^^^^
255 |     n_jobs=-1,
256 |     verbose=False,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/umap_.py:256:5
    |
254 |     use_pynndescent=True,
255 |     n_jobs=-1,
256 |     verbose=False,
    |     ^^^^^^^
257 | ):
258 |     """Compute the ``n_neighbors`` nearest points for each data point in ``X``
    |

D205 1 blank line required between summary line and description
   --> umap/umap_.py:258:5
    |
256 |       verbose=False,
257 |   ):
258 | /     """Compute the ``n_neighbors`` nearest points for each data point in ``X``
259 | |     under ``metric``. This may be exact, but more likely is approximated via
260 | |     nearest neighbor descent.
261 | |
262 | |     Parameters
263 | |     ----------
264 | |     X: array of shape (n_samples, n_features)
265 | |         The input data to compute the k-neighbor graph of.
266 | |
267 | |     n_neighbors: int
268 | |         The number of nearest neighbors to compute for each sample in ``X``.
269 | |
270 | |     metric: string or callable
271 | |         The metric to use for the computation.
272 | |
273 | |     metric_kwds: dict
274 | |         Any arguments to pass to the metric computation function.
275 | |
276 | |     angular: bool
277 | |         Whether to use angular rp trees in NN approximation.
278 | |
279 | |     random_state: np.random state
280 | |         The random state to use for approximate NN computations.
281 | |
282 | |     low_memory: bool (optional, default True)
283 | |         Whether to pursue lower memory NNdescent.
284 | |
285 | |     verbose: bool (optional, default False)
286 | |         Whether to print status data during the computation.
287 | |
288 | |     Returns
289 | |     -------
290 | |     knn_indices: array of shape (n_samples, n_neighbors)
291 | |         The indices on the ``n_neighbors`` closest points in the dataset.
292 | |
293 | |     knn_dists: array of shape (n_samples, n_neighbors)
294 | |         The distances to the ``n_neighbors`` closest points in the dataset.
295 | |
296 | |     rp_forest: list of trees
297 | |         The random projection forest used for searching (if used, None otherwise).
298 | |
299 | |     """
    | |_______^
300 |       if verbose:
301 |           pass
    |
help: Insert single blank line

ERA001 Found commented-out code
   --> umap/umap_.py:307:9
    |
305 |         # Compute indices of n nearest neighbors
306 |         knn_indices = fast_knn_indices(X, n_neighbors)
307 |         # knn_indices = np.argsort(X)[:, :n_neighbors]
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
308 |         # Compute the nearest neighbor distances
309 |         #   (equivalent to np.sort(X)[:,:n_neighbors])
    |
help: Remove commented-out code

TD002 Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`
   --> umap/umap_.py:317:11
    |
315 |         knn_search_index = None
316 |     else:
317 |         # TODO: Hacked values for now
    |           ^^^^
318 |         n_trees = min(64, 5 + round((X.shape[0]) ** 0.5 / 20.0))
319 |         n_iters = max(5, round(np.log2(X.shape[0])))
    |

TD003 Missing issue link for this TODO
   --> umap/umap_.py:317:11
    |
315 |         knn_search_index = None
316 |     else:
317 |         # TODO: Hacked values for now
    |           ^^^^
318 |         n_trees = min(64, 5 + round((X.shape[0]) ** 0.5 / 20.0))
319 |         n_iters = max(5, round(np.log2(X.shape[0])))
    |

FIX002 Line contains TODO, consider resolving the issue
   --> umap/umap_.py:317:11
    |
315 |         knn_search_index = None
316 |     else:
317 |         # TODO: Hacked values for now
    |           ^^^^
318 |         n_trees = min(64, 5 + round((X.shape[0]) ** 0.5 / 20.0))
319 |         n_iters = max(5, round(np.log2(X.shape[0])))
    |

PLR0913 Too many arguments in function definition (6 > 5)
   --> umap/umap_.py:352:5
    |
350 |     fastmath=True,
351 | )
352 | def compute_membership_strengths(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
353 |     knn_indices,
354 |     knn_dists,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/umap_.py:357:5
    |
355 |     sigmas,
356 |     rhos,
357 |     return_dists=False,
    |     ^^^^^^^^^^^^
358 |     bipartite=False,
359 | ):
    |

FBT002 Boolean default positional argument in function definition
   --> umap/umap_.py:358:5
    |
356 |     rhos,
357 |     return_dists=False,
358 |     bipartite=False,
    |     ^^^^^^^^^
359 | ):
360 |     """Construct the membership strength data for the 1-skeleton of each local
    |

D205 1 blank line required between summary line and description
   --> umap/umap_.py:360:5
    |
358 |       bipartite=False,
359 |   ):
360 | /     """Construct the membership strength data for the 1-skeleton of each local
361 | |     fuzzy simplicial set -- this is formed as a sparse matrix where each row is
362 | |     a local fuzzy simplicial set, with a membership strength for the
363 | |     1-simplex to each other data point.
364 | |
365 | |     Parameters
366 | |     ----------
367 | |     knn_indices: array of shape (n_samples, n_neighbors)
368 | |         The indices on the ``n_neighbors`` closest points in the dataset.
369 | |
370 | |     knn_dists: array of shape (n_samples, n_neighbors)
371 | |         The distances to the ``n_neighbors`` closest points in the dataset.
372 | |
373 | |     sigmas: array of shape(n_samples)
374 | |         The normalization factor derived from the metric tensor approximation.
375 | |
376 | |     rhos: array of shape(n_samples)
377 | |         The local connectivity adjustment.
378 | |
379 | |     return_dists: bool (optional, default False)
380 | |         Whether to return the pairwise distance associated with each edge.
381 | |
382 | |     bipartite: bool (optional, default False)
383 | |         Does the nearest neighbour set represent a bipartite graph? That is, are the
384 | |         nearest neighbour indices from the same point set as the row indices?
385 | |
386 | |     Returns
387 | |     -------
388 | |     rows: array of shape (n_samples * n_neighbors)
389 | |         Row data for the resulting sparse matrix (coo format)
390 | |
391 | |     cols: array of shape (n_samples * n_neighbors)
392 | |         Column data for the resulting sparse matrix (coo format)
393 | |
394 | |     vals: array of shape (n_samples * n_neighbors)
395 | |         Entries for the resulting sparse matrix (coo format)
396 | |
397 | |     dists: array of shape (n_samples * n_neighbors)
398 | |         Distance associated with each entry in the resulting sparse matrix
399 | |
400 | |     """
    | |_______^
401 |       n_samples = knn_indices.shape[0]
402 |       n_neighbors = knn_indices.shape[1]
    |
help: Insert single blank line

PLR0913 Too many arguments in function definition (13 > 5)
   --> umap/umap_.py:431:5
    |
431 | def fuzzy_simplicial_set(
    |     ^^^^^^^^^^^^^^^^^^^^
432 |     X,
433 |     n_neighbors,
    |

D417 Missing argument description in the docstring for `fuzzy_simplicial_set`: `apply_set_operations`
   --> umap/umap_.py:431:5
    |
431 | def fuzzy_simplicial_set(
    |     ^^^^^^^^^^^^^^^^^^^^
432 |     X,
433 |     n_neighbors,
    |

N803 Argument name `X` should be lowercase
   --> umap/umap_.py:432:5
    |
431 | def fuzzy_simplicial_set(
432 |     X,
    |     ^
433 |     n_neighbors,
434 |     random_state,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/umap_.py:439:5
    |
437 |     knn_indices=None,
438 |     knn_dists=None,
439 |     angular=False,
    |     ^^^^^^^
440 |     set_op_mix_ratio=1.0,
441 |     local_connectivity=1.0,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/umap_.py:442:5
    |
440 |     set_op_mix_ratio=1.0,
441 |     local_connectivity=1.0,
442 |     apply_set_operations=True,
    |     ^^^^^^^^^^^^^^^^^^^^
443 |     verbose=False,
444 |     return_dists=None,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/umap_.py:443:5
    |
441 |     local_connectivity=1.0,
442 |     apply_set_operations=True,
443 |     verbose=False,
    |     ^^^^^^^
444 |     return_dists=None,
445 | ):
    |

D205 1 blank line required between summary line and description
   --> umap/umap_.py:446:5
    |
444 |       return_dists=None,
445 |   ):
446 | /     """Given a set of data X, a neighborhood size, and a measure of distance
447 | |     compute the fuzzy simplicial set (here represented as a fuzzy graph in
448 | |     the form of a sparse matrix) associated to the data. This is done by
449 | |     locally approximating geodesic distance at each point, creating a fuzzy
450 | |     simplicial set for each such point, and then combining all the local
451 | |     fuzzy simplicial sets into a global one via a fuzzy union.
452 | |
453 | |     Parameters
454 | |     ----------
455 | |     X: array of shape (n_samples, n_features)
456 | |         The data to be modelled as a fuzzy simplicial set.
457 | |
458 | |     n_neighbors: int
459 | |         The number of neighbors to use to approximate geodesic distance.
460 | |         Larger numbers induce more global estimates of the manifold that can
461 | |         miss finer detail, while smaller values will focus on fine manifold
462 | |         structure to the detriment of the larger picture.
463 | |
464 | |     random_state: numpy RandomState or equivalent
465 | |         A state capable being used as a numpy random state.
466 | |
467 | |     metric: string or function (optional, default 'euclidean')
468 | |         The metric to use to compute distances in high dimensional space.
469 | |         If a string is passed it must match a valid predefined metric. If
470 | |         a general metric is required a function that takes two 1d arrays and
471 | |         returns a float can be provided. For performance purposes it is
472 | |         required that this be a numba jit'd function. Valid string metrics
473 | |         include:
474 | |
475 | |         * euclidean (or l2)
476 | |         * manhattan (or l1)
477 | |         * cityblock
478 | |         * braycurtis
479 | |         * canberra
480 | |         * chebyshev
481 | |         * correlation
482 | |         * cosine
483 | |         * dice
484 | |         * hamming
485 | |         * jaccard
486 | |         * kulsinski
487 | |         * ll_dirichlet
488 | |         * mahalanobis
489 | |         * matching
490 | |         * minkowski
491 | |         * rogerstanimoto
492 | |         * russellrao
493 | |         * seuclidean
494 | |         * sokalmichener
495 | |         * sokalsneath
496 | |         * sqeuclidean
497 | |         * yule
498 | |         * wminkowski
499 | |
500 | |         Metrics that take arguments (such as minkowski, mahalanobis etc.)
501 | |         can have arguments passed via the metric_kwds dictionary. At this
502 | |         time care must be taken and dictionary elements must be ordered
503 | |         appropriately; this will hopefully be fixed in the future.
504 | |
505 | |     metric_kwds: dict (optional, default {})
506 | |         Arguments to pass on to the metric, such as the ``p`` value for
507 | |         Minkowski distance.
508 | |
509 | |     knn_indices: array of shape (n_samples, n_neighbors) (optional)
510 | |         If the k-nearest neighbors of each point has already been calculated
511 | |         you can pass them in here to save computation time. This should be
512 | |         an array with the indices of the k-nearest neighbors as a row for
513 | |         each data point.
514 | |
515 | |     knn_dists: array of shape (n_samples, n_neighbors) (optional)
516 | |         If the k-nearest neighbors of each point has already been calculated
517 | |         you can pass them in here to save computation time. This should be
518 | |         an array with the distances of the k-nearest neighbors as a row for
519 | |         each data point.
520 | |
521 | |     angular: bool (optional, default False)
522 | |         Whether to use angular/cosine distance for the random projection
523 | |         forest for seeding NN-descent to determine approximate nearest
524 | |         neighbors.
525 | |
526 | |     set_op_mix_ratio: float (optional, default 1.0)
527 | |         Interpolate between (fuzzy) union and intersection as the set operation
528 | |         used to combine local fuzzy simplicial sets to obtain a global fuzzy
529 | |         simplicial sets. Both fuzzy set operations use the product t-norm.
530 | |         The value of this parameter should be between 0.0 and 1.0; a value of
531 | |         1.0 will use a pure fuzzy union, while 0.0 will use a pure fuzzy
532 | |         intersection.
533 | |
534 | |     local_connectivity: int (optional, default 1)
535 | |         The local connectivity required -- i.e. the number of nearest
536 | |         neighbors that should be assumed to be connected at a local level.
537 | |         The higher this value the more connected the manifold becomes
538 | |         locally. In practice this should be not more than the local intrinsic
539 | |         dimension of the manifold.
540 | |
541 | |     verbose: bool (optional, default False)
542 | |         Whether to report information on the current progress of the algorithm.
543 | |
544 | |     return_dists: bool or None (optional, default None)
545 | |         Whether to return the pairwise distance associated with each edge.
546 | |
547 | |     Returns
548 | |     -------
549 | |     fuzzy_simplicial_set: coo_matrix
550 | |         A fuzzy simplicial set represented as a sparse matrix. The (i,
551 | |         j) entry of the matrix represents the membership strength of the
552 | |         1-simplex between the ith and jth sample points.
553 | |
554 | |     """
    | |_______^
555 |       if metric_kwds is None:
556 |           metric_kwds = {}
    |
help: Insert single blank line

PLR0913 Too many arguments in function definition (6 > 5)
   --> umap/umap_.py:612:5
    |
611 | @numba.njit()
612 | def fast_intersection(rows, cols, values, target, unknown_dist=1.0, far_dist=5.0):
    |     ^^^^^^^^^^^^^^^^^
613 |     """Under the assumption of categorical distance for the intersecting
614 |     simplicial set perform a fast intersection.
    |

D417 Missing argument description in the docstring for `fast_intersection`: `far_dist`
   --> umap/umap_.py:612:5
    |
611 | @numba.njit()
612 | def fast_intersection(rows, cols, values, target, unknown_dist=1.0, far_dist=5.0):
    |     ^^^^^^^^^^^^^^^^^
613 |     """Under the assumption of categorical distance for the intersecting
614 |     simplicial set perform a fast intersection.
    |

D205 1 blank line required between summary line and description
   --> umap/umap_.py:613:5
    |
611 |   @numba.njit()
612 |   def fast_intersection(rows, cols, values, target, unknown_dist=1.0, far_dist=5.0):
613 | /     """Under the assumption of categorical distance for the intersecting
614 | |     simplicial set perform a fast intersection.
615 | |
616 | |     Parameters
617 | |     ----------
618 | |     rows: array
619 | |         An array of the row of each non-zero in the sparse matrix
620 | |         representation.
621 | |
622 | |     cols: array
623 | |         An array of the column of each non-zero in the sparse matrix
624 | |         representation.
625 | |
626 | |     values: array
627 | |         An array of the value of each non-zero in the sparse matrix
628 | |         representation.
629 | |
630 | |     target: array of shape (n_samples)
631 | |         The categorical labels to use in the intersection.
632 | |
633 | |     unknown_dist: float (optional, default 1.0)
634 | |         The distance an unknown label (-1) is assumed to be from any point.
635 | |
636 | |     far_dist float (optional, default 5.0)
637 | |         The distance between unmatched labels.
638 | |
639 | |     Returns
640 | |     -------
641 | |     None
642 | |
643 | |     """
    | |_______^
644 |       for nz in range(rows.shape[0]):
645 |           i = rows[nz]
    |
help: Insert single blank line

PLR0913 Too many arguments in function definition (7 > 5)
   --> umap/umap_.py:655:5
    |
654 | @numba.njit()
655 | def fast_metric_intersection(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
656 |     rows, cols, values, discrete_space, metric, metric_args, scale,
657 | ):
    |

D417 Missing argument description in the docstring for `fast_metric_intersection`: `metric_args`
   --> umap/umap_.py:655:5
    |
654 | @numba.njit()
655 | def fast_metric_intersection(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
656 |     rows, cols, values, discrete_space, metric, metric_args, scale,
657 | ):
    |

D205 1 blank line required between summary line and description
   --> umap/umap_.py:658:5
    |
656 |       rows, cols, values, discrete_space, metric, metric_args, scale,
657 |   ):
658 | /     """Under the assumption of categorical distance for the intersecting
659 | |     simplicial set perform a fast intersection.
660 | |
661 | |     Parameters
662 | |     ----------
663 | |     rows: array
664 | |         An array of the row of each non-zero in the sparse matrix
665 | |         representation.
666 | |
667 | |     cols: array
668 | |         An array of the column of each non-zero in the sparse matrix
669 | |         representation.
670 | |
671 | |     values: array of shape
672 | |         An array of the values of each non-zero in the sparse matrix
673 | |         representation.
674 | |
675 | |     discrete_space: array of shape (n_samples, n_features)
676 | |         The vectors of categorical labels to use in the intersection.
677 | |
678 | |     metric: numba function
679 | |         The function used to calculate distance over the target array.
680 | |
681 | |     scale: float
682 | |         A scaling to apply to the metric.
683 | |
684 | |     Returns
685 | |     -------
686 | |     None
687 | |
688 | |     """
    | |_______^
689 |       for nz in range(rows.shape[0]):
690 |           i = rows[nz]
    |
help: Insert single blank line

D103 Missing docstring in public function
   --> umap/umap_.py:698:5
    |
697 | @numba.njit()
698 | def reprocess_row(probabilities, k=15, n_iters=32):
    |     ^^^^^^^^^^^^^
699 |     target = np.log2(k)
    |

D103 Missing docstring in public function
   --> umap/umap_.py:728:5
    |
727 | @numba.njit()
728 | def reset_local_metrics(simplicial_set_indptr, simplicial_set_data):
    |     ^^^^^^^^^^^^^^^^^^^
729 |     for i in range(simplicial_set_indptr.shape[0] - 1):
730 |         simplicial_set_data[simplicial_set_indptr[i] : simplicial_set_indptr[i + 1]] = (
    |

D417 Missing argument description in the docstring for `reset_local_connectivity`: `reset_local_metric`
   --> umap/umap_.py:739:5
    |
739 | def reset_local_connectivity(simplicial_set, reset_local_metric=False):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
740 |     """Reset the local connectivity requirement -- each data sample should
741 |     have complete confidence in at least one 1-simplex in the simplicial set.
    |

FBT002 Boolean default positional argument in function definition
   --> umap/umap_.py:739:46
    |
739 | def reset_local_connectivity(simplicial_set, reset_local_metric=False):
    |                                              ^^^^^^^^^^^^^^^^^^
740 |     """Reset the local connectivity requirement -- each data sample should
741 |     have complete confidence in at least one 1-simplex in the simplicial set.
    |

D205 1 blank line required between summary line and description
   --> umap/umap_.py:740:5
    |
739 |   def reset_local_connectivity(simplicial_set, reset_local_metric=False):
740 | /     """Reset the local connectivity requirement -- each data sample should
741 | |     have complete confidence in at least one 1-simplex in the simplicial set.
742 | |     We can enforce this by locally rescaling confidences, and then remerging the
743 | |     different local simplicial sets together.
744 | |
745 | |     Parameters
746 | |     ----------
747 | |     simplicial_set: sparse matrix
748 | |         The simplicial set for which to recalculate with respect to local
749 | |         connectivity.
750 | |
751 | |     Returns
752 | |     -------
753 | |     simplicial_set: sparse_matrix
754 | |         The recalculated simplicial set, now with the local connectivity
755 | |         assumption restored.
756 | |
757 | |     """
    | |_______^
758 |       simplicial_set = normalize(simplicial_set, norm="max")
759 |       if reset_local_metric:
    |
help: Insert single blank line

PLR0913 Too many arguments in function definition (7 > 5)
   --> umap/umap_.py:771:5
    |
771 | def discrete_metric_simplicial_set_intersection(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
772 |     simplicial_set,
773 |     discrete_space,
    |

D417 Missing argument description in the docstring for `discrete_metric_simplicial_set_intersection`: `metric_kws`
   --> umap/umap_.py:771:5
    |
771 | def discrete_metric_simplicial_set_intersection(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
772 |     simplicial_set,
773 |     discrete_space,
    |

D205 1 blank line required between summary line and description
   --> umap/umap_.py:780:5
    |
778 |       metric_scale=1.0,
779 |   ):
780 | /     """Combine a fuzzy simplicial set with another fuzzy simplicial set
781 | |     generated from discrete metric data using discrete distances. The target
782 | |     data is assumed to be categorical label data (a vector of labels),
783 | |     and this will update the fuzzy simplicial set to respect that label data.
784 | |
785 | |     TODO: optional category cardinality based weighting of distance
786 | |
787 | |     Parameters
788 | |     ----------
789 | |     simplicial_set: sparse matrix
790 | |         The input fuzzy simplicial set.
791 | |
792 | |     discrete_space: array of shape (n_samples)
793 | |         The categorical labels to use in the intersection.
794 | |
795 | |     unknown_dist: float (optional, default 1.0)
796 | |         The distance an unknown label (-1) is assumed to be from any point.
797 | |
798 | |     far_dist: float (optional, default 5.0)
799 | |         The distance between unmatched labels.
800 | |
801 | |     metric: str (optional, default None)
802 | |         If not None, then use this metric to determine the
803 | |         distance between values.
804 | |
805 | |     metric_scale: float (optional, default 1.0)
806 | |         If using a custom metric scale the distance values by
807 | |         this value -- this controls the weighting of the
808 | |         intersection. Larger values weight more toward target.
809 | |
810 | |     Returns
811 | |     -------
812 | |     simplicial_set: sparse matrix
813 | |         The resulting intersected fuzzy simplicial set.
814 | |
815 | |     """
    | |_______^
816 |       if metric_kws is None:
817 |           metric_kws = {}
    |
help: Insert single blank line

D103 Missing docstring in public function
   --> umap/umap_.py:853:5
    |
853 | def general_simplicial_set_intersection(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
854 |     simplicial_set1, simplicial_set2, weight=0.5, right_complement=False,
855 | ):
    |

FBT002 Boolean default positional argument in function definition
   --> umap/umap_.py:854:51
    |
853 | def general_simplicial_set_intersection(
854 |     simplicial_set1, simplicial_set2, weight=0.5, right_complement=False,
    |                                                   ^^^^^^^^^^^^^^^^
855 | ):
    |

D103 Missing docstring in public function
   --> umap/umap_.py:881:5
    |
881 | def general_simplicial_set_union(simplicial_set1, simplicial_set2):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
882 |     result = (simplicial_set1 + simplicial_set2).tocoo()
883 |     left = simplicial_set1.tocsr()
    |

D205 1 blank line required between summary line and description
   --> umap/umap_.py:902:5
    |
901 |   def make_epochs_per_sample(weights, n_epochs):
902 | /     """Given a set of weights and number of epochs generate the number of
903 | |     epochs per sample for each weight.
904 | |
905 | |     Parameters
906 | |     ----------
907 | |     weights: array of shape (n_1_simplices)
908 | |         The weights of how much we wish to sample each 1-simplex.
909 | |
910 | |     n_epochs: int
911 | |         The total number of epochs we want to train for.
912 | |
913 | |     Returns
914 | |     -------
915 | |     An array of number of epochs per sample, one for each 1-simplex.
916 | |
917 | |     """
    | |_______^
918 |       result = -1.0 * np.ones(weights.shape[0], dtype=np.float64)
919 |       n_samples = n_epochs * (weights / weights.max())
    |
help: Insert single blank line

D103 Missing docstring in public function
   --> umap/umap_.py:926:5
    |
924 | # scale coords so that the largest coordinate is max_coords, then add normal-distributed
925 | # noise with standard deviation noise
926 | def noisy_scale_coords(coords, random_state, max_coord=10.0, noise=0.0001):
    |     ^^^^^^^^^^^^^^^^^^
927 |     expansion = max_coord / np.abs(coords).max()
928 |     coords = (coords * expansion).astype(np.float32)
    |

C901 `simplicial_set_embedding` is too complex (22 > 10)
   --> umap/umap_.py:934:5
    |
934 | def simplicial_set_embedding(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
935 |     data,
936 |     graph,
    |

PLR0913 Too many arguments in function definition (22 > 5)
   --> umap/umap_.py:934:5
    |
934 | def simplicial_set_embedding(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
935 |     data,
936 |     graph,
    |

PLR0912 Too many branches (26 > 12)
   --> umap/umap_.py:934:5
    |
934 | def simplicial_set_embedding(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
935 |     data,
936 |     graph,
    |

PLR0915 Too many statements (102 > 50)
   --> umap/umap_.py:934:5
    |
934 | def simplicial_set_embedding(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
935 |     data,
936 |     graph,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/umap_.py:953:5
    |
951 |     output_metric=dist.named_distances_with_gradients["euclidean"],
952 |     output_metric_kwds=None,
953 |     euclidean_output=True,
    |     ^^^^^^^^^^^^^^^^
954 |     parallel=False,
955 |     verbose=False,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/umap_.py:954:5
    |
952 |     output_metric_kwds=None,
953 |     euclidean_output=True,
954 |     parallel=False,
    |     ^^^^^^^^
955 |     verbose=False,
956 |     tqdm_kwds=None,
    |

FBT002 Boolean default positional argument in function definition
   --> umap/umap_.py:955:5
    |
953 |     euclidean_output=True,
954 |     parallel=False,
955 |     verbose=False,
    |     ^^^^^^^
956 |     tqdm_kwds=None,
957 | ):
    |

D205 1 blank line required between summary line and description
    --> umap/umap_.py:958:5
     |
 956 |       tqdm_kwds=None,
 957 |   ):
 958 | /     """Perform a fuzzy simplicial set embedding, using a specified
 959 | |     initialisation method and then minimizing the fuzzy set cross entropy
 960 | |     between the 1-skeletons of the high and low dimensional fuzzy simplicial
 961 | |     sets.
 962 | |
 963 | |     Parameters
 964 | |     ----------
 965 | |     data: array of shape (n_samples, n_features)
 966 | |         The source data to be embedded by UMAP.
 967 | |
 968 | |     graph: sparse matrix
 969 | |         The 1-skeleton of the high dimensional fuzzy simplicial set as
 970 | |         represented by a graph for which we require a sparse matrix for the
 971 | |         (weighted) adjacency matrix.
 972 | |
 973 | |     n_components: int
 974 | |         The dimensionality of the euclidean space into which to embed the data.
 975 | |
 976 | |     initial_alpha: float
 977 | |         Initial learning rate for the SGD.
 978 | |
 979 | |     a: float
 980 | |         Parameter of differentiable approximation of right adjoint functor
 981 | |
 982 | |     b: float
 983 | |         Parameter of differentiable approximation of right adjoint functor
 984 | |
 985 | |     gamma: float
 986 | |         Weight to apply to negative samples.
 987 | |
 988 | |     negative_sample_rate: int (optional, default 5)
 989 | |         The number of negative samples to select per positive sample
 990 | |         in the optimization process. Increasing this value will result
 991 | |         in greater repulsive force being applied, greater optimization
 992 | |         cost, but slightly more accuracy.
 993 | |
 994 | |     n_epochs: int (optional, default 0), or list of int
 995 | |         The number of training epochs to be used in optimizing the
 996 | |         low dimensional embedding. Larger values result in more accurate
 997 | |         embeddings. If 0 is specified a value will be selected based on
 998 | |         the size of the input dataset (200 for large datasets, 500 for small).
 999 | |         If a list of int is specified, then the intermediate embeddings at the
1000 | |         different epochs specified in that list are returned in
1001 | |         ``aux_data["embedding_list"]``.
1002 | |
1003 | |     init: string
1004 | |         How to initialize the low dimensional embedding. Options are:
1005 | |
1006 | |             * 'spectral': use a spectral embedding of the fuzzy 1-skeleton
1007 | |             * 'random': assign initial embedding positions at random.
1008 | |             * 'pca': use the first n_components from PCA applied to the input data.
1009 | |             * A numpy array of initial embedding positions.
1010 | |
1011 | |     random_state: numpy RandomState or equivalent
1012 | |         A state capable being used as a numpy random state.
1013 | |
1014 | |     metric: string or callable
1015 | |         The metric used to measure distance in high dimensional space; used if
1016 | |         multiple connected components need to be layed out.
1017 | |
1018 | |     metric_kwds: dict
1019 | |         Key word arguments to be passed to the metric function; used if
1020 | |         multiple connected components need to be layed out.
1021 | |
1022 | |     densmap: bool
1023 | |         Whether to use the density-augmented objective function to optimize
1024 | |         the embedding according to the densMAP algorithm.
1025 | |
1026 | |     densmap_kwds: dict
1027 | |         Key word arguments to be used by the densMAP optimization.
1028 | |
1029 | |     output_dens: bool
1030 | |         Whether to output local radii in the original data and the embedding.
1031 | |
1032 | |     output_metric: function
1033 | |         Function returning the distance between two points in embedding space and
1034 | |         the gradient of the distance wrt the first argument.
1035 | |
1036 | |     output_metric_kwds: dict
1037 | |         Key word arguments to be passed to the output_metric function.
1038 | |
1039 | |     euclidean_output: bool
1040 | |         Whether to use the faster code specialised for euclidean output metrics
1041 | |
1042 | |     parallel: bool (optional, default False)
1043 | |         Whether to run the computation using numba parallel.
1044 | |         Running in parallel is non-deterministic, and is not used
1045 | |         if a random seed has been set, to ensure reproducibility.
1046 | |
1047 | |     verbose: bool (optional, default False)
1048 | |         Whether to report information on the current progress of the algorithm.
1049 | |
1050 | |     tqdm_kwds: dict
1051 | |         Key word arguments to be used by the tqdm progress bar.
1052 | |
1053 | |     Returns
1054 | |     -------
1055 | |     embedding: array of shape (n_samples, n_components)
1056 | |         The optimized of ``graph`` into an ``n_components`` dimensional
1057 | |         euclidean space.
1058 | |
1059 | |     aux_data: dict
1060 | |         Auxiliary output returned with the embedding. When densMAP extension
1061 | |         is turned on, this dictionary includes local radii in the original
1062 | |         data (``rad_orig``) and in the embedding (``rad_emb``).
1063 | |
1064 | |     """
     | |_______^
1065 |       if output_metric_kwds is None:
1066 |           output_metric_kwds = {}
     |
help: Insert single blank line

PLR2004 Magic value used in comparison, consider replacing `10000` with a constant variable
    --> umap/umap_.py:1072:47
     |
1071 |     # For smaller datasets we can use more epochs
1072 |     default_epochs = 500 if graph.shape[0] <= 10000 else 200
     |                                               ^^^^^
1073 |
1074 |     # Use more epochs for densMAP
     |

PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    --> umap/umap_.py:1084:23
     |
1082 |     n_epochs_max = max(n_epochs) if isinstance(n_epochs, list) else n_epochs
1083 |
1084 |     if n_epochs_max > 10:
     |                       ^^
1085 |         graph.data[graph.data < (graph.data.max() / float(n_epochs_max))] = 0.0
1086 |     else:
     |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    --> umap/umap_.py:1131:36
     |
1129 |     else:
1130 |         init_data = np.array(init)
1131 |         if len(init_data.shape) == 2:
     |                                    ^
1132 |             if np.unique(init_data, axis=0).shape[0] < init_data.shape[0]:
1133 |                 tree = KDTree(init_data)
     |

N806 Variable `D` in function should be lowercase
    --> umap/umap_.py:1163:13
     |
1161 |             k = tail[i]
1162 |
1163 |             D = dists[j, k] * dists[j, k]  # match sq-Euclidean used for embedding
     |             ^
1164 |             mu = graph.data[i]
     |

N806 Variable `R` in function should be lowercase
    --> umap/umap_.py:1175:13
     |
1174 |         if densmap:
1175 |             R = (ro - np.mean(ro)) / np.std(ro)
     |             ^
1176 |             densmap_kwds["mu"] = graph.data
1177 |             densmap_kwds["mu_sum"] = mu_sum
     |

FBT003 Boolean positional value in function call
    --> umap/umap_.py:1251:13
     |
1249 |             "euclidean",
1250 |             {},
1251 |             False,
     |             ^^^^^
1252 |             random_state,
1253 |             verbose=verbose,
     |

N806 Variable `D` in function should be lowercase
    --> umap/umap_.py:1283:13
     |
1281 |             k = tail[i]
1282 |
1283 |             D = emb_dists[j, k]
     |             ^
1284 |             mu = emb_graph.data[i]
     |

D205 1 blank line required between summary line and description
    --> umap/umap_.py:1301:5
     |
1299 |   @numba.njit()
1300 |   def init_transform(indices, weights, embedding):
1301 | /     """Given indices and weights and an original embeddings
1302 | |     initialize the positions of new points relative to the
1303 | |     indices and weights (of their neighbors in the source data).
1304 | |
1305 | |     Parameters
1306 | |     ----------
1307 | |     indices: array of shape (n_new_samples, n_neighbors)
1308 | |         The indices of the neighbors of each new sample
1309 | |
1310 | |     weights: array of shape (n_new_samples, n_neighbors)
1311 | |         The membership strengths of associated 1-simplices
1312 | |         for each of the new samples.
1313 | |
1314 | |     embedding: array of shape (n_samples, dim)
1315 | |         The original embedding of the source data.
1316 | |
1317 | |     Returns
1318 | |     -------
1319 | |     new_embedding: array of shape (n_new_samples, dim)
1320 | |         An initial embedding of the new sample points.
1321 | |
1322 | |     """
     | |_______^
1323 |       result = np.zeros((indices.shape[0], embedding.shape[1]), dtype=np.float32)
     |
help: Insert single blank line

D205 1 blank line required between summary line and description
    --> umap/umap_.py:1334:5
     |
1333 |   def init_graph_transform(graph, embedding):
1334 | /     """Given a bipartite graph representing the 1-simplices and strengths between the
1335 | |     new points and the original data set along with an embedding of the original points
1336 | |     initialize the positions of new points relative to the strengths (of their neighbors in the source data).
1337 | |
1338 | |     If a point is in our original data set it embeds at the original points coordinates.
1339 | |     If a point has no neighbours in our original dataset it embeds as the np.nan vector.
1340 | |     Otherwise a point is the weighted average of it's neighbours embedding locations.
1341 | |
1342 | |     Parameters
1343 | |     ----------
1344 | |     graph: csr_matrix (n_new_samples, n_samples)
1345 | |         A matrix indicating the 1-simplices and their associated strengths.  These strengths should
1346 | |         be values between zero and one and not normalized.  One indicating that the new point was identical
1347 | |         to one of our original points.
1348 | |
1349 | |     embedding: array of shape (n_samples, dim)
1350 | |         The original embedding of the source data.
1351 | |
1352 | |     Returns
1353 | |     -------
1354 | |     new_embedding: array of shape (n_new_samples, dim)
1355 | |         An initial embedding of the new sample points.
1356 | |
1357 | |     """
     | |_______^
1358 |       result = np.zeros((graph.shape[0], embedding.shape[1]), dtype=np.float32)
     |
help: Insert single blank line

D103 Missing docstring in public function
    --> umap/umap_.py:1376:5
     |
1375 | @numba.njit()
1376 | def init_update(current_init, n_original_samples, indices):
     |     ^^^^^^^^^^^
1377 |     for i in range(n_original_samples, indices.shape[0]):
1378 |         n = 0
     |

D205 1 blank line required between summary line and description
    --> umap/umap_.py:1390:5
     |
1389 |   def find_ab_params(spread, min_dist):
1390 | /     """Fit a, b params for the differentiable curve used in lower
1391 | |     dimensional fuzzy simplicial complex construction. We want the
1392 | |     smooth curve (from a pre-defined family with simple gradient) that
1393 | |     best matches an offset exponential decay.
1394 | |     """
     | |_______^
1395 |
1396 |       def curve(x, a, b):
     |
help: Insert single blank line

PLR0913 Too many arguments in function definition (39 > 5)
    --> umap/umap_.py:1662:9
     |
1660 |     """
1661 |
1662 |     def __init__(
     |         ^^^^^^^^
1663 |         self,
1664 |         n_neighbors=15,
     |

D107 Missing docstring in `__init__`
    --> umap/umap_.py:1662:9
     |
1660 |     """
1661 |
1662 |     def __init__(
     |         ^^^^^^^^
1663 |         self,
1664 |         n_neighbors=15,
     |

FBT002 Boolean default positional argument in function definition
    --> umap/umap_.py:1675:9
     |
1673 |         min_dist=0.1,
1674 |         spread=1.0,
1675 |         low_memory=True,
     |         ^^^^^^^^^^
1676 |         n_jobs=-1,
1677 |         set_op_mix_ratio=1.0,
     |

FBT002 Boolean default positional argument in function definition
    --> umap/umap_.py:1685:9
     |
1683 |         b=None,
1684 |         random_state=None,
1685 |         angular_rp_forest=False,
     |         ^^^^^^^^^^^^^^^^^
1686 |         target_n_neighbors=-1,
1687 |         target_metric="categorical",
     |

FBT002 Boolean default positional argument in function definition
    --> umap/umap_.py:1692:9
     |
1690 |         transform_seed=42,
1691 |         transform_mode="embedding",
1692 |         force_approximation_algorithm=False,
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1693 |         verbose=False,
1694 |         tqdm_kwds=None,
     |

FBT002 Boolean default positional argument in function definition
    --> umap/umap_.py:1693:9
     |
1691 |         transform_mode="embedding",
1692 |         force_approximation_algorithm=False,
1693 |         verbose=False,
     |         ^^^^^^^
1694 |         tqdm_kwds=None,
1695 |         unique=False,
     |

FBT002 Boolean default positional argument in function definition
    --> umap/umap_.py:1695:9
     |
1693 |         verbose=False,
1694 |         tqdm_kwds=None,
1695 |         unique=False,
     |         ^^^^^^
1696 |         densmap=False,
1697 |         dens_lambda=2.0,
     |

FBT002 Boolean default positional argument in function definition
    --> umap/umap_.py:1696:9
     |
1694 |         tqdm_kwds=None,
1695 |         unique=False,
1696 |         densmap=False,
     |         ^^^^^^^
1697 |         dens_lambda=2.0,
1698 |         dens_frac=0.3,
     |

FBT002 Boolean default positional argument in function definition
    --> umap/umap_.py:1700:9
     |
1698 |         dens_frac=0.3,
1699 |         dens_var_shift=0.1,
1700 |         output_dens=False,
     |         ^^^^^^^^^^^
1701 |         disconnection_distance=None,
1702 |         precomputed_knn=(None, None, None),
     |

C901 `_validate_parameters` is too complex (66 > 10)
    --> umap/umap_.py:1749:9
     |
1747 |         self.b = b
1748 |
1749 |     def _validate_parameters(self):
     |         ^^^^^^^^^^^^^^^^^^^^
1750 |         if self.set_op_mix_ratio < 0.0 or self.set_op_mix_ratio > 1.0:
1751 |             msg = "set_op_mix_ratio must be between 0.0 and 1.0"
     |

PLR0912 Too many branches (77 > 12)
    --> umap/umap_.py:1749:9
     |
1747 |         self.b = b
1748 |
1749 |     def _validate_parameters(self):
     |         ^^^^^^^^^^^^^^^^^^^^
1750 |         if self.set_op_mix_ratio < 0.0 or self.set_op_mix_ratio > 1.0:
1751 |             msg = "set_op_mix_ratio must be between 0.0 and 1.0"
     |

PLR0915 Too many statements (211 > 50)
    --> umap/umap_.py:1749:9
     |
1747 |         self.b = b
1748 |
1749 |     def _validate_parameters(self):
     |         ^^^^^^^^^^^^^^^^^^^^
1750 |         if self.set_op_mix_ratio < 0.0 or self.set_op_mix_ratio > 1.0:
1751 |             msg = "set_op_mix_ratio must be between 0.0 and 1.0"
     |

TRY004 Prefer `TypeError` exception for invalid type
    --> umap/umap_.py:1764:13
     |
1762 |         if not isinstance(self.init, str) and not isinstance(self.init, np.ndarray):
1763 |             msg = "init must be a string or ndarray"
1764 |             raise ValueError(msg)
     |             ^^^^^^^^^^^^^^^^^^^^^
1765 |         if isinstance(self.init, str) and self.init not in (
1766 |             "pca",
     |

TRY004 Prefer `TypeError` exception for invalid type
    --> umap/umap_.py:1786:13
     |
1784 |         if not isinstance(self.metric, str) and not callable(self.metric):
1785 |             msg = "metric must be string or callable"
1786 |             raise ValueError(msg)
     |             ^^^^^^^^^^^^^^^^^^^^^
1787 |         if self.negative_sample_rate < 0:
1788 |             msg = "negative sample rate must be positive"
     |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    --> umap/umap_.py:1793:31
     |
1791 |             msg = "learning_rate must be positive"
1792 |             raise ValueError(msg)
1793 |         if self.n_neighbors < 2:
     |                               ^
1794 |             msg = "n_neighbors must be greater than 1"
1795 |             raise ValueError(msg)
     |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    --> umap/umap_.py:1796:38
     |
1794 |             msg = "n_neighbors must be greater than 1"
1795 |             raise ValueError(msg)
1796 |         if self.target_n_neighbors < 2 and self.target_n_neighbors != -1:
     |                                      ^
1797 |             msg = "target_n_neighbors must be greater than 1"
1798 |             raise ValueError(msg)
     |

TRY004 Prefer `TypeError` exception for invalid type
    --> umap/umap_.py:1802:17
     |
1800 |             if isinstance(self.n_components, str):
1801 |                 msg = "n_components must be an int"
1802 |                 raise ValueError(msg)
     |                 ^^^^^^^^^^^^^^^^^^^^^
1803 |             if self.n_components % 1 != 0:
1804 |                 msg = "n_components must be a whole number"
     |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    --> umap/umap_.py:1812:17
     |
1810 |             except ValueError:
1811 |                 msg = "n_components must be an int"
1812 |                 raise ValueError(msg)
     |                 ^^^^^^^^^^^^^^^^^^^^^
1813 |         if self.n_components < 1:
1814 |             msg = "n_components must be greater than 0"
     |

PLR2004 Magic value used in comparison, consider replacing `4096` with a constant variable
    --> umap/umap_.py:2084:43
     |
2082 |                 self.knn_search_index = None
2083 |             elif (
2084 |                 self.knn_dists.shape[0] < 4096
     |                                           ^^^^
2085 |                 and not self.force_approximation_algorithm
2086 |             ):
     |

NPY002 Replace legacy `np.random.randint` call with `np.random.Generator`
    --> umap/umap_.py:2102:25
     |
2100 |             # input data so we don't risk violating any assumptions potentially
2101 |             # hard-coded in the metric (e.g., bounded; non-negative)
2102 |             x, y = data[np.random.randint(0, data.shape[0], 2)]
     |                         ^^^^^^^^^^^^^^^^^
2103 |         else:
2104 |             # if checking the manifold distance metric, simulate some data on a
     |

NPY002 Replace legacy `np.random.uniform` call with `np.random.Generator`
    --> umap/umap_.py:2106:20
     |
2104 |             # if checking the manifold distance metric, simulate some data on a
2105 |             # reasonable interval with output dimensionality
2106 |             x, y = np.random.uniform(low=-10, high=10, size=(2, self.n_components))
     |                    ^^^^^^^^^^^^^^^^^
2107 |
2108 |         if scipy.sparse.issparse(data):
     |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    --> umap/umap_.py:2113:71
     |
2111 |             metric_out = metric(x, y, **kwds)
2112 |         # True if metric returns iterable of length 2, False otherwise
2113 |         return hasattr(metric_out, "__iter__") and len(metric_out) == 2
     |                                                                       ^
2114 |
2115 |     def _populate_combined_params(self, *models):
     |

SLF001 Private member accessed: `_a`
    --> umap/umap_.py:2161:30
     |
2159 |         self.b = flattened([m.b for m in models])
2160 |
2161 |         self._a = flattened([m._a for m in models])
     |                              ^^^^
2162 |         self._b = flattened([m._b for m in models])
     |

SLF001 Private member accessed: `_b`
    --> umap/umap_.py:2162:30
     |
2161 |         self._a = flattened([m._a for m in models])
2162 |         self._b = flattened([m._b for m in models])
     |                              ^^^^
2163 |
2164 |     def __mul__(self, other):
     |

FBT003 Boolean positional value in function call
    --> umap/umap_.py:2183:65
     |
2181 |             self.graph_, other.graph_, 0.5,
2182 |         )
2183 |         result.graph_ = reset_local_connectivity(result.graph_, True)
     |                                                                 ^^^^
2184 |
2185 |         if scipy.sparse.csgraph.connected_components(result.graph_)[0] > 1:
     |

FBT003 Boolean positional value in function call
    --> umap/umap_.py:2251:65
     |
2250 |         result.graph_ = general_simplicial_set_union(self.graph_, other.graph_)
2251 |         result.graph_ = reset_local_connectivity(result.graph_, True)
     |                                                                 ^^^^
2252 |
2253 |         if scipy.sparse.csgraph.connected_components(result.graph_)[0] > 1:
     |

FBT003 Boolean positional value in function call
    --> umap/umap_.py:2321:65
     |
2319 |             self.graph_, other.graph_, weight=0.5, right_complement=True,
2320 |         )
2321 |         result.graph_ = reset_local_connectivity(result.graph_, False)
     |                                                                 ^^^^^
2322 |
2323 |         if scipy.sparse.csgraph.connected_components(result.graph_)[0] > 1:
     |

C901 `fit` is too complex (47 > 10)
    --> umap/umap_.py:2372:9
     |
2370 |         return result
2371 |
2372 |     def fit(self, X, y=None, ensure_all_finite=True, **kwargs):
     |         ^^^
2373 |         """Fit X into an embedded space.
     |

PLR0912 Too many branches (67 > 12)
    --> umap/umap_.py:2372:9
     |
2370 |         return result
2371 |
2372 |     def fit(self, X, y=None, ensure_all_finite=True, **kwargs):
     |         ^^^
2373 |         """Fit X into an embedded space.
     |

PLR0915 Too many statements (188 > 50)
    --> umap/umap_.py:2372:9
     |
2370 |         return result
2371 |
2372 |     def fit(self, X, y=None, ensure_all_finite=True, **kwargs):
     |         ^^^
2373 |         """Fit X into an embedded space.
     |

N803 Argument name `X` should be lowercase
    --> umap/umap_.py:2372:19
     |
2370 |         return result
2371 |
2372 |     def fit(self, X, y=None, ensure_all_finite=True, **kwargs):
     |                   ^
2373 |         """Fit X into an embedded space.
     |

FBT002 Boolean default positional argument in function definition
    --> umap/umap_.py:2372:30
     |
2370 |         return result
2371 |
2372 |     def fit(self, X, y=None, ensure_all_finite=True, **kwargs):
     |                              ^^^^^^^^^^^^^^^^^
2373 |         """Fit X into an embedded space.
     |

N806 Variable `X` in function should be lowercase
    --> umap/umap_.py:2402:13
     |
2400 |         """
2401 |         if self.metric in ("bit_hamming", "bit_jaccard"):
2402 |             X = check_array(
     |             ^
2403 |                 X, dtype=np.uint8, order="C", ensure_all_finite=ensure_all_finite,
2404 |             )
     |

N806 Variable `X` in function should be lowercase
    --> umap/umap_.py:2406:13
     |
2404 |             )
2405 |         else:
2406 |             X = check_array(
     |             ^
2407 |                 X,
2408 |                 dtype=np.float32,
     |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    --> umap/umap_.py:2437:41
     |
2435 |         self.knn_dists = self.precomputed_knn[1]
2436 |         # #848: allow precomputed knn to not have a search index
2437 |         if len(self.precomputed_knn) == 2:
     |                                         ^
2438 |             self.knn_search_index = None
2439 |         else:
     |

ERA001 Found commented-out code
    --> umap/umap_.py:2509:13
     |
2507 |             # symmetrical (so we can find neighbors by looking at rows in isolation,
2508 |             # rather than also having to consider that sample's column too).
2509 |             # print("Computing KNNs for sparse precomputed distances...")
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2510 |             if sparse_tril(X).getnnz() != sparse_triu(X).getnnz():
2511 |                 msg = "Sparse precomputed distance matrices should be symmetrical!"
     |
help: Remove commented-out code

FBT003 Boolean positional value in function call
    --> umap/umap_.py:2558:17
     |
2556 |                 self.set_op_mix_ratio,
2557 |                 self.local_connectivity,
2558 |                 True,
     |                 ^^^^
2559 |                 self.verbose,
2560 |                 self.densmap or self.output_dens,
     |

PLR2004 Magic value used in comparison, consider replacing `4096` with a constant variable
    --> umap/umap_.py:2575:34
     |
2573 |             )
2574 |         # Handle small cases efficiently by computing all distances
2575 |         elif X[index].shape[0] < 4096 and not self.force_approximation_algorithm:
     |                                  ^^^^
2576 |             self._small_data = True
2577 |             try:
     |

FBT003 Boolean positional value in function call
    --> umap/umap_.py:2629:17
     |
2627 |                 self.set_op_mix_ratio,
2628 |                 self.local_connectivity,
2629 |                 True,
     |                 ^^^^
2630 |                 self.verbose,
2631 |                 self.densmap or self.output_dens,
     |

FBT003 Boolean positional value in function call
    --> umap/umap_.py:2696:17
     |
2694 |                 self.set_op_mix_ratio,
2695 |                 self.local_connectivity,
2696 |                 True,
     |                 ^^^^
2697 |                 self.verbose,
2698 |                 self.densmap or self.output_dens,
     |

N806 Variable `len_X` in function should be lowercase
    --> umap/umap_.py:2716:13
     |
2714 |         # Might be worth throwing a warning...
2715 |         if y is not None:
2716 |             len_X = len(X) if not self._sparse_data else X.shape[0]
     |             ^^^^^
2717 |             if len_X != len(y):
2718 |                 msg = (
     |

ERA001 Found commented-out code
    --> umap/umap_.py:2746:17
     |
2744 |                 #     self.graph_,
2745 |                 #     y_,
2746 |                 #     metric=self.target_metric,
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2747 |                 #     metric_kws=self.target_metric_kwds,
2748 |                 #     metric_scale=scale
     |
help: Remove commented-out code

ERA001 Found commented-out code
    --> umap/umap_.py:2747:17
     |
2745 |                 #     y_,
2746 |                 #     metric=self.target_metric,
2747 |                 #     metric_kws=self.target_metric_kwds,
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2748 |                 #     metric_scale=scale
2749 |                 # )
     |
help: Remove commented-out code

ERA001 Found commented-out code
    --> umap/umap_.py:2748:17
     |
2746 |                 #     metric=self.target_metric,
2747 |                 #     metric_kws=self.target_metric_kwds,
2748 |                 #     metric_scale=scale
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^
2749 |                 # )
     |
help: Remove commented-out code

ERA001 Found commented-out code
    --> umap/umap_.py:2749:17
     |
2747 |                 #     metric_kws=self.target_metric_kwds,
2748 |                 #     metric_scale=scale
2749 |                 # )
     |                 ^^^
2750 |
2751 |                 metric_kws = dist.get_discrete_params(y_, self.target_metric)
     |
help: Remove commented-out code

PLR2004 Magic value used in comparison, consider replacing `4096` with a constant variable
    --> umap/umap_.py:2769:33
     |
2768 |                 # Handle the small case as precomputed as before
2769 |                 if y.shape[0] < 4096:
     |                                 ^^^^
2770 |                     try:
2771 |                         ydmat = pairwise_distances(
     |

RUF059 Unpacked variable `target_sigmas` is never used
    --> umap/umap_.py:2784:25
     |
2782 |                     (
2783 |                         target_graph,
2784 |                         target_sigmas,
     |                         ^^^^^^^^^^^^^
2785 |                         target_rhos,
2786 |                     ) = fuzzy_simplicial_set(
     |
help: Prefix it with an underscore or any other dummy variable pattern

RUF059 Unpacked variable `target_rhos` is never used
    --> umap/umap_.py:2785:25
     |
2783 |                         target_graph,
2784 |                         target_sigmas,
2785 |                         target_rhos,
     |                         ^^^^^^^^^^^
2786 |                     ) = fuzzy_simplicial_set(
2787 |                         ydmat,
     |
help: Prefix it with an underscore or any other dummy variable pattern

FBT003 Boolean positional value in function call
    --> umap/umap_.py:2794:25
     |
2792 |                         None,
2793 |                         None,
2794 |                         False,
     |                         ^^^^^
2795 |                         1.0,
2796 |                         1.0,
     |

FBT003 Boolean positional value in function call
    --> umap/umap_.py:2797:25
     |
2795 |                         1.0,
2796 |                         1.0,
2797 |                         False,
     |                         ^^^^^
2798 |                     )
2799 |                 else:
     |

FBT003 Boolean positional value in function call
    --> umap/umap_.py:2813:25
     |
2811 |                         None,
2812 |                         None,
2813 |                         False,
     |                         ^^^^^
2814 |                         1.0,
2815 |                         1.0,
     |

FBT003 Boolean positional value in function call
    --> umap/umap_.py:2816:25
     |
2814 |                         1.0,
2815 |                         1.0,
2816 |                         False,
     |                         ^^^^^
2817 |                     )
2818 |                 # product = self.graph_.multiply(target_graph)
     |

ERA001 Found commented-out code
    --> umap/umap_.py:2818:17
     |
2816 |                         False,
2817 |                     )
2818 |                 # product = self.graph_.multiply(target_graph)
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2819 |                 # # self.graph_ = 0.99 * product + 0.01 * (self.graph_ +
2820 |                 # #                                        target_graph -
     |
help: Remove commented-out code

ERA001 Found commented-out code
    --> umap/umap_.py:2822:17
     |
2820 |                 # #                                        target_graph -
2821 |                 # #                                        product)
2822 |                 # self.graph_ = product
     |                 ^^^^^^^^^^^^^^^^^^^^^^^
2823 |                 self.graph_ = general_simplicial_set_intersection(
2824 |                     self.graph_, target_graph, self.target_weight,
     |
help: Remove commented-out code

N803 Argument name `X` should be lowercase
    --> umap/umap_.py:2893:31
     |
2891 |         return self
2892 |
2893 |     def _fit_embed_data(self, X, n_epochs, init, random_state, **kwargs):
     |                               ^
2894 |         """A method wrapper for simplicial_set_embedding that can be
2895 |         replaced by subclasses. Arbitrary keyword arguments can be passed
     |

ARG002 Unused method argument: `kwargs`
    --> umap/umap_.py:2893:66
     |
2891 |         return self
2892 |
2893 |     def _fit_embed_data(self, X, n_epochs, init, random_state, **kwargs):
     |                                                                  ^^^^^^
2894 |         """A method wrapper for simplicial_set_embedding that can be
2895 |         replaced by subclasses. Arbitrary keyword arguments can be passed
     |

D205 1 blank line required between summary line and description
    --> umap/umap_.py:2894:9
     |
2893 |       def _fit_embed_data(self, X, n_epochs, init, random_state, **kwargs):
2894 | /         """A method wrapper for simplicial_set_embedding that can be
2895 | |         replaced by subclasses. Arbitrary keyword arguments can be passed
2896 | |         through .fit() and .fit_transform().
2897 | |         """
     | |___________^
2898 |           return simplicial_set_embedding(
2899 |               X,
     |
help: Insert single blank line

D401 First line of docstring should be in imperative mood: "A method wrapper for simplicial_set_embedding that can be"
    --> umap/umap_.py:2894:9
     |
2893 |       def _fit_embed_data(self, X, n_epochs, init, random_state, **kwargs):
2894 | /         """A method wrapper for simplicial_set_embedding that can be
2895 | |         replaced by subclasses. Arbitrary keyword arguments can be passed
2896 | |         through .fit() and .fit_transform().
2897 | |         """
     | |___________^
2898 |           return simplicial_set_embedding(
2899 |               X,
     |

D417 Missing argument description in the docstring for `fit_transform`: `**kwargs`
    --> umap/umap_.py:2923:9
     |
2921 |         )
2922 |
2923 |     def fit_transform(self, X, y=None, ensure_all_finite=True, **kwargs):
     |         ^^^^^^^^^^^^^
2924 |         """Fit X into an embedded space and return that transformed
2925 |         output.
     |

N803 Argument name `X` should be lowercase
    --> umap/umap_.py:2923:29
     |
2921 |         )
2922 |
2923 |     def fit_transform(self, X, y=None, ensure_all_finite=True, **kwargs):
     |                             ^
2924 |         """Fit X into an embedded space and return that transformed
2925 |         output.
     |

FBT002 Boolean default positional argument in function definition
    --> umap/umap_.py:2923:40
     |
2921 |         )
2922 |
2923 |     def fit_transform(self, X, y=None, ensure_all_finite=True, **kwargs):
     |                                        ^^^^^^^^^^^^^^^^^
2924 |         """Fit X into an embedded space and return that transformed
2925 |         output.
     |

D205 1 blank line required between summary line and description
    --> umap/umap_.py:2924:9
     |
2923 |       def fit_transform(self, X, y=None, ensure_all_finite=True, **kwargs):
2924 | /         """Fit X into an embedded space and return that transformed
2925 | |         output.
2926 | |
2927 | |         Parameters
2928 | |         ----------
2929 | |         X : array, shape (n_samples, n_features) or (n_samples, n_samples)
2930 | |             If the metric is 'precomputed' X must be a square distance
2931 | |             matrix. Otherwise it contains a sample per row.
2932 | |
2933 | |         y : array, shape (n_samples)
2934 | |             A target array for supervised dimension reduction. How this is
2935 | |             handled is determined by parameters UMAP was instantiated with.
2936 | |             The relevant attributes are ``target_metric`` and
2937 | |             ``target_metric_kwds``.
2938 | |
2939 | |         ensure_all_finite : Whether to raise an error on np.inf, np.nan, pd.NA in array.
2940 | |             The possibilities are: - True: Force all values of array to be finite.
2941 | |                                    - False: accepts np.inf, np.nan, pd.NA in array.
2942 | |                                    - 'allow-nan': accepts only np.nan and pd.NA values in array.
2943 | |                                      Values cannot be infinite.
2944 | |
2945 | |         **kwargs : Any additional keyword arguments are passed to _fit_embed_data.
2946 | |
2947 | |         Returns
2948 | |         -------
2949 | |         X_new : array, shape (n_samples, n_components)
2950 | |             Embedding of the training data in low-dimensional space.
2951 | |
2952 | |         or a tuple (X_new, r_orig, r_emb) if ``output_dens`` flag is set,
2953 | |         which additionally includes:
2954 | |
2955 | |         r_orig: array, shape (n_samples)
2956 | |             Local radii of data points in the original data space (log-transformed).
2957 | |
2958 | |         r_emb: array, shape (n_samples)
2959 | |             Local radii of data points in the embedding (log-transformed).
2960 | |
2961 | |         """
     | |___________^
2962 |           self.fit(X, y, ensure_all_finite, **kwargs)
2963 |           if self.transform_mode == "embedding":
     |
help: Insert single blank line

C901 `transform` is too complex (19 > 10)
    --> umap/umap_.py:2976:9
     |
2974 |         )
2975 |
2976 |     def transform(self, X, ensure_all_finite=True):
     |         ^^^^^^^^^
2977 |         """Transform X into the existing embedded space and return that
2978 |         transformed output.
     |

PLR0912 Too many branches (25 > 12)
    --> umap/umap_.py:2976:9
     |
2974 |         )
2975 |
2976 |     def transform(self, X, ensure_all_finite=True):
     |         ^^^^^^^^^
2977 |         """Transform X into the existing embedded space and return that
2978 |         transformed output.
     |

PLR0915 Too many statements (83 > 50)
    --> umap/umap_.py:2976:9
     |
2974 |         )
2975 |
2976 |     def transform(self, X, ensure_all_finite=True):
     |         ^^^^^^^^^
2977 |         """Transform X into the existing embedded space and return that
2978 |         transformed output.
     |

N803 Argument name `X` should be lowercase
    --> umap/umap_.py:2976:25
     |
2974 |         )
2975 |
2976 |     def transform(self, X, ensure_all_finite=True):
     |                         ^
2977 |         """Transform X into the existing embedded space and return that
2978 |         transformed output.
     |

FBT002 Boolean default positional argument in function definition
    --> umap/umap_.py:2976:28
     |
2974 |         )
2975 |
2976 |     def transform(self, X, ensure_all_finite=True):
     |                            ^^^^^^^^^^^^^^^^^
2977 |         """Transform X into the existing embedded space and return that
2978 |         transformed output.
     |

D205 1 blank line required between summary line and description
    --> umap/umap_.py:2977:9
     |
2976 |       def transform(self, X, ensure_all_finite=True):
2977 | /         """Transform X into the existing embedded space and return that
2978 | |         transformed output.
2979 | |
2980 | |         Parameters
2981 | |         ----------
2982 | |         X : array, shape (n_samples, n_features)
2983 | |             New data to be transformed.
2984 | |
2985 | |         ensure_all_finite : Whether to raise an error on np.inf, np.nan, pd.NA in array.
2986 | |             The possibilities are: - True: Force all values of array to be finite.
2987 | |                                    - False: accepts np.inf, np.nan, pd.NA in array.
2988 | |                                    - 'allow-nan': accepts only np.nan and pd.NA values in array.
2989 | |                                      Values cannot be infinite.
2990 | |
2991 | |         Returns
2992 | |         -------
2993 | |         X_new : array, shape (n_samples, n_components)
2994 | |             Embedding of the new data in low-dimensional space.
2995 | |
2996 | |         """
     | |___________^
2997 |           # If we fit just a single instance then error
2998 |           if self._raw_data.shape[0] == 1:
     |
help: Insert single blank line

N806 Variable `X` in function should be lowercase
    --> umap/umap_.py:3005:13
     |
3003 |         # If we just have the original input then short circuit things
3004 |         if self.metric in ("bit_hamming", "bit_jaccard"):
3005 |             X = check_array(
     |             ^
3006 |                 X, dtype=np.uint8, order="C", ensure_all_finite=ensure_all_finite,
3007 |             )
     |

N806 Variable `X` in function should be lowercase
    --> umap/umap_.py:3009:13
     |
3007 |             )
3008 |         else:
3009 |             X = check_array(
     |             ^
3010 |                 X,
3011 |                 dtype=np.float32,
     |

ERA001 Found commented-out code
    --> umap/umap_.py:3045:9
     |
3043 |             )
3044 |
3045 |         # X = check_array(X, dtype=np.float32, order="C", accept_sparse="csr")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3046 |         random_state = check_random_state(self.transform_seed)
3047 |         rng_state = random_state.randint(INT32_MIN, INT32_MAX, 3).astype(np.int64)
     |
help: Remove commented-out code

S101 Use of `assert` detected
    --> umap/umap_.py:3057:13
     |
3055 |                 "or approximate nearest neighbours in the training set.", stacklevel=2,
3056 |             )
3057 |             assert X.shape[1] == self._raw_data.shape[0]
     |             ^^^^^^
3058 |             if scipy.sparse.issparse(X):
3059 |                 indices = np.full(
     |

S101 Use of `assert` detected
    --> umap/umap_.py:3075:13
     |
3073 |                 indices = np.argsort(X, axis=1)[:, : self._n_neighbors].astype(np.int32)
3074 |                 dists = np.take_along_axis(X, indices, axis=1)
3075 |             assert np.min(indices) >= 0
     |             ^^^^^^
3076 |             assert np.min(dists) >= 0.0
3077 |         elif self._small_data:
     |

S101 Use of `assert` detected
    --> umap/umap_.py:3076:13
     |
3074 |                 dists = np.take_along_axis(X, indices, axis=1)
3075 |             assert np.min(indices) >= 0
3076 |             assert np.min(dists) >= 0.0
     |             ^^^^^^
3077 |         elif self._small_data:
3078 |             try:
     |

SLF001 Private member accessed: `_angular_trees`
    --> umap/umap_.py:3120:31
     |
3118 |             dists = submatrix(dmat_shortened, indices_sorted, self._n_neighbors)
3119 |         else:
3120 |             epsilon = 0.24 if self._knn_search_index._angular_trees else 0.12
     |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3121 |             indices, dists = self._knn_search_index.query(
3122 |                 X, self.n_neighbors, epsilon=epsilon,
     |

ERA001 Found commented-out code
    --> umap/umap_.py:3149:9
     |
3147 |         # That lets us do fancy unpacking by reshaping the csr matrix indices
3148 |         # and data. Doing so relies on the constant degree assumption!
3149 |         # csr_graph = normalize(graph.tocsr(), norm="l1")
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3150 |         # inds = csr_graph.indices.reshape(X.shape[0], self._n_neighbors)
3151 |         # weights = csr_graph.data.reshape(X.shape[0], self._n_neighbors)
     |
help: Remove commented-out code

ERA001 Found commented-out code
    --> umap/umap_.py:3150:9
     |
3148 |         # and data. Doing so relies on the constant degree assumption!
3149 |         # csr_graph = normalize(graph.tocsr(), norm="l1")
3150 |         # inds = csr_graph.indices.reshape(X.shape[0], self._n_neighbors)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3151 |         # weights = csr_graph.data.reshape(X.shape[0], self._n_neighbors)
3152 |         # embedding = init_transform(inds, weights, self.embedding_)
     |
help: Remove commented-out code

ERA001 Found commented-out code
    --> umap/umap_.py:3151:9
     |
3149 |         # csr_graph = normalize(graph.tocsr(), norm="l1")
3150 |         # inds = csr_graph.indices.reshape(X.shape[0], self._n_neighbors)
3151 |         # weights = csr_graph.data.reshape(X.shape[0], self._n_neighbors)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3152 |         # embedding = init_transform(inds, weights, self.embedding_)
3153 |         # This is less fast code than the above numba.jit'd code.
     |
help: Remove commented-out code

ERA001 Found commented-out code
    --> umap/umap_.py:3152:9
     |
3150 |         # inds = csr_graph.indices.reshape(X.shape[0], self._n_neighbors)
3151 |         # weights = csr_graph.data.reshape(X.shape[0], self._n_neighbors)
3152 |         # embedding = init_transform(inds, weights, self.embedding_)
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3153 |         # This is less fast code than the above numba.jit'd code.
3154 |         # It handles the fact that our nearest neighbour graph can now contain variable numbers of vertices.
     |
help: Remove commented-out code

PLR2004 Magic value used in comparison, consider replacing `10000` with a constant variable
    --> umap/umap_.py:3161:49
     |
3159 |         if self.n_epochs is None:
3160 |             # For smaller datasets we can use more epochs
3161 |             n_epochs = 100 if graph.shape[0] <= 10000 else 30
     |                                                 ^^^^^
3162 |         else:
3163 |             n_epochs = int(self.n_epochs // 3.0)
     |

ERA001 Found commented-out code
    --> umap/umap_.py:3173:9
     |
3171 |         tail = graph.col
3172 |
3173 |         # optimize_layout = make_optimize_layout(
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3174 |         #     self._output_distance_func,
3175 |         #     tuple(self.output_metric_kwds.values()),
     |
help: Remove commented-out code

ERA001 Found commented-out code
    --> umap/umap_.py:3175:9
     |
3173 |         # optimize_layout = make_optimize_layout(
3174 |         #     self._output_distance_func,
3175 |         #     tuple(self.output_metric_kwds.values()),
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3176 |         # )
     |
help: Remove commented-out code

ERA001 Found commented-out code
    --> umap/umap_.py:3176:9
     |
3174 |         #     self._output_distance_func,
3175 |         #     tuple(self.output_metric_kwds.values()),
3176 |         # )
     |         ^^^
3177 |
3178 |         if self.output_metric == "euclidean":
     |
help: Remove commented-out code

C901 `inverse_transform` is too complex (13 > 10)
    --> umap/umap_.py:3220:9
     |
3218 |         return embedding
3219 |
3220 |     def inverse_transform(self, X):
     |         ^^^^^^^^^^^^^^^^^
3221 |         """Transform X in the existing embedded space back into the input
3222 |         data space and return that transformed output.
     |

PLR0912 Too many branches (13 > 12)
    --> umap/umap_.py:3220:9
     |
3218 |         return embedding
3219 |
3220 |     def inverse_transform(self, X):
     |         ^^^^^^^^^^^^^^^^^
3221 |         """Transform X in the existing embedded space back into the input
3222 |         data space and return that transformed output.
     |

PLR0915 Too many statements (57 > 50)
    --> umap/umap_.py:3220:9
     |
3218 |         return embedding
3219 |
3220 |     def inverse_transform(self, X):
     |         ^^^^^^^^^^^^^^^^^
3221 |         """Transform X in the existing embedded space back into the input
3222 |         data space and return that transformed output.
     |

N803 Argument name `X` should be lowercase
    --> umap/umap_.py:3220:33
     |
3218 |         return embedding
3219 |
3220 |     def inverse_transform(self, X):
     |                                 ^
3221 |         """Transform X in the existing embedded space back into the input
3222 |         data space and return that transformed output.
     |

D205 1 blank line required between summary line and description
    --> umap/umap_.py:3221:9
     |
3220 |       def inverse_transform(self, X):
3221 | /         """Transform X in the existing embedded space back into the input
3222 | |         data space and return that transformed output.
3223 | |
3224 | |         Parameters
3225 | |         ----------
3226 | |         X : array, shape (n_samples, n_components)
3227 | |             New points to be inverse transformed.
3228 | |
3229 | |         Returns
3230 | |         -------
3231 | |         X_new : array, shape (n_samples, n_features)
3232 | |             Generated data points new data in data space.
3233 | |
3234 | |         """
     | |___________^
3235 |           if self._sparse_data:
3236 |               msg = "Inverse transform not available for sparse input."
     |
help: Insert single blank line

PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
    --> umap/umap_.py:3244:33
     |
3242 |             msg = "Inverse transform not available for densMAP."
3243 |             raise ValueError(msg)
3244 |         if self.n_components >= 8:
     |                                 ^
3245 |             warn(
3246 |                 "Inverse transform works best with low dimensional embeddings."
     |

N806 Variable `X` in function should be lowercase
    --> umap/umap_.py:3258:9
     |
3256 |             )
3257 |
3258 |         X = check_array(X, dtype=np.float32, order="C")
     |         ^
3259 |         random_state = check_random_state(self.transform_seed)
3260 |         rng_state = random_state.randint(INT32_MIN, INT32_MAX, 3).astype(np.int64)
     |

ERA001 Found commented-out code
    --> umap/umap_.py:3344:9
     |
3342 |         # That lets us do fancy unpacking by reshaping the csr matrix indices
3343 |         # and data. Doing so relies on the constant degree assumption!
3344 |         # csr_graph = graph.tocsr()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
3345 |         csr_graph = normalize(graph.tocsr(), norm="l1")
3346 |         inds = csr_graph.indices.reshape(X.shape[0], min_vertices)
     |
help: Remove commented-out code

PLR2004 Magic value used in comparison, consider replacing `10000` with a constant variable
    --> umap/umap_.py:3352:49
     |
3350 |         if self.n_epochs is None:
3351 |             # For smaller datasets we can use more epochs
3352 |             n_epochs = 100 if graph.shape[0] <= 10000 else 30
     |                                                 ^^^^^
3353 |         else:
3354 |             n_epochs = int(self.n_epochs // 3.0)
     |

ERA001 Found commented-out code
    --> umap/umap_.py:3356:9
     |
3354 |             n_epochs = int(self.n_epochs // 3.0)
3355 |
3356 |         # graph.data[graph.data < (graph.data.max() / float(n_epochs))] = 0.0
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3357 |         # graph.eliminate_zeros()
     |
help: Remove commented-out code

ERA001 Found commented-out code
    --> umap/umap_.py:3357:9
     |
3356 |         # graph.data[graph.data < (graph.data.max() / float(n_epochs))] = 0.0
3357 |         # graph.eliminate_zeros()
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^
3358 |
3359 |         epochs_per_sample = make_epochs_per_sample(graph.data, n_epochs)
     |
help: Remove commented-out code

C901 `update` is too complex (13 > 10)
    --> umap/umap_.py:3389:9
     |
3389 |     def update(self, X, ensure_all_finite=True):
     |         ^^^^^^
3390 |         if self.metric in ("bit_hamming", "bit_jaccard"):
3391 |             X = check_array(
     |

PLR0912 Too many branches (20 > 12)
    --> umap/umap_.py:3389:9
     |
3389 |     def update(self, X, ensure_all_finite=True):
     |         ^^^^^^
3390 |         if self.metric in ("bit_hamming", "bit_jaccard"):
3391 |             X = check_array(
     |

PLR0915 Too many statements (65 > 50)
    --> umap/umap_.py:3389:9
     |
3389 |     def update(self, X, ensure_all_finite=True):
     |         ^^^^^^
3390 |         if self.metric in ("bit_hamming", "bit_jaccard"):
3391 |             X = check_array(
     |

D102 Missing docstring in public method
    --> umap/umap_.py:3389:9
     |
3389 |     def update(self, X, ensure_all_finite=True):
     |         ^^^^^^
3390 |         if self.metric in ("bit_hamming", "bit_jaccard"):
3391 |             X = check_array(
     |

N803 Argument name `X` should be lowercase
    --> umap/umap_.py:3389:22
     |
3389 |     def update(self, X, ensure_all_finite=True):
     |                      ^
3390 |         if self.metric in ("bit_hamming", "bit_jaccard"):
3391 |             X = check_array(
     |

FBT002 Boolean default positional argument in function definition
    --> umap/umap_.py:3389:25
     |
3389 |     def update(self, X, ensure_all_finite=True):
     |                         ^^^^^^^^^^^^^^^^^
3390 |         if self.metric in ("bit_hamming", "bit_jaccard"):
3391 |             X = check_array(
     |

N806 Variable `X` in function should be lowercase
    --> umap/umap_.py:3391:13
     |
3389 |     def update(self, X, ensure_all_finite=True):
3390 |         if self.metric in ("bit_hamming", "bit_jaccard"):
3391 |             X = check_array(
     |             ^
3392 |                 X, dtype=np.uint8, order="C", ensure_all_finite=ensure_all_finite,
3393 |             )
     |

N806 Variable `X` in function should be lowercase
    --> umap/umap_.py:3395:13
     |
3393 |             )
3394 |         else:
3395 |             X = check_array(
     |             ^
3396 |                 X,
3397 |                 dtype=np.float32,
     |

PLR2004 Magic value used in comparison, consider replacing `4096` with a constant variable
    --> umap/umap_.py:3421:42
     |
3419 |                 self._raw_data = np.vstack([self._raw_data, X])
3420 |
3421 |             if self._raw_data.shape[0] < 4096:
     |                                          ^^^^
3422 |                 # still small data
3423 |                 try:
     |

FBT003 Boolean positional value in function call
    --> umap/umap_.py:3468:21
     |
3466 |                     self.set_op_mix_ratio,
3467 |                     self.local_connectivity,
3468 |                     True,
     |                     ^^^^
3469 |                     self.verbose,
3470 |                 )
     |

FBT003 Boolean positional value in function call
    --> umap/umap_.py:3508:21
     |
3506 |                     self.set_op_mix_ratio,
3507 |                     self.local_connectivity,
3508 |                     True,
     |                     ^^^^
3509 |                     self.verbose,
3510 |                 )
     |

SLF001 Private member accessed: `_raw_data`
    --> umap/umap_.py:3549:30
     |
3547 |             self._knn_search_index.prepare()
3548 |             self._knn_search_index.update(X)
3549 |             self._raw_data = self._knn_search_index._raw_data
     |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3550 |             (
3551 |                 self._knn_indices,
     |

FBT003 Boolean positional value in function call
    --> umap/umap_.py:3571:17
     |
3569 |                 self.set_op_mix_ratio,
3570 |                 self.local_connectivity,
3571 |                 True,
     |                 ^^^^
3572 |                 self.verbose,
3573 |             )
     |

PLC0415 `import` should be at the top-level of a file
    --> umap/umap_.py:3613:9
     |
3612 |     def __repr__(self):
3613 |         import re
     |         ^^^^^^^^^
3614 |
3615 |         from sklearn.utils._pprint import _EstimatorPrettyPrinter
     |

PLC0415 `import` should be at the top-level of a file
    --> umap/umap_.py:3615:9
     |
3613 |         import re
3614 |
3615 |         from sklearn.utils._pprint import _EstimatorPrettyPrinter
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3616 |
3617 |         pp = _EstimatorPrettyPrinter(
     |

SLF001 Private member accessed: `_changed_only`
    --> umap/umap_.py:3623:9
     |
3621 |             n_max_elements_to_show=50,
3622 |         )
3623 |         pp._changed_only = True
     |         ^^^^^^^^^^^^^^^^
3624 |         repr_ = pp.pformat(self)
3625 |         repr_ = re.sub("tqdm_kwds={.*},", "", repr_, flags=re.DOTALL)
     |

N803 Argument name `X` should be lowercase
  --> umap/utils.py:15:22
   |
14 | @numba.njit(parallel=True)
15 | def fast_knn_indices(X, n_neighbors):
   |                      ^
16 |     """A fast computation of knn indices.
   |

D401 First line of docstring should be in imperative mood: "A fast computation of knn indices."
  --> umap/utils.py:16:5
   |
14 |   @numba.njit(parallel=True)
15 |   def fast_knn_indices(X, n_neighbors):
16 | /     """A fast computation of knn indices.
17 | |
18 | |     Parameters
19 | |     ----------
20 | |     X: array of shape (n_samples, n_features)
21 | |         The input data to compute the k-neighbor indices of.
22 | |
23 | |     n_neighbors: int
24 | |         The number of nearest neighbors to compute for each sample in ``X``.
25 | |
26 | |     Returns
27 | |     -------
28 | |     knn_indices: array of shape (n_samples, n_neighbors)
29 | |         The indices on the ``n_neighbors`` closest points in the dataset.
30 | |
31 | |     """
   | |_______^
32 |       knn_indices = np.empty((X.shape[0], n_neighbors), dtype=np.int32)
33 |       for row in numba.prange(X.shape[0]):
   |

ERA001 Found commented-out code
  --> umap/utils.py:34:9
   |
32 |     knn_indices = np.empty((X.shape[0], n_neighbors), dtype=np.int32)
33 |     for row in numba.prange(X.shape[0]):
34 |         # v = np.argsort(X[row])  # Need to call argsort this way for numba
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
35 |         v = X[row].argsort(kind="quicksort")
36 |         v = v[:n_neighbors]
   |
help: Remove commented-out code

D401 First line of docstring should be in imperative mood: "A fast (pseudo)-random number generator."
  --> umap/utils.py:43:5
   |
41 |   @numba.njit("i4(i8[:])")
42 |   def tau_rand_int(state):
43 | /     """A fast (pseudo)-random number generator.
44 | |
45 | |     Parameters
46 | |     ----------
47 | |     state: array of int64, shape (3,)
48 | |         The internal state of the rng
49 | |
50 | |     Returns
51 | |     -------
52 | |     A (pseudo)-random int32 value
53 | |
54 | |     """
   | |_______^
55 |       state[0] = (((state[0] & 4294967294) << 12) & 0xFFFFFFFF) ^ (
56 |           (((state[0] << 13) & 0xFFFFFFFF) ^ state[0]) >> 19
   |

D401 First line of docstring should be in imperative mood: "A fast (pseudo)-random number generator for floats in the range [0,1]."
  --> umap/utils.py:70:5
   |
68 |   @numba.njit("f4(i8[:])")
69 |   def tau_rand(state):
70 | /     """A fast (pseudo)-random number generator for floats in the range [0,1].
71 | |
72 | |     Parameters
73 | |     ----------
74 | |     state: array of int64, shape (3,)
75 | |         The internal state of the rng
76 | |
77 | |     Returns
78 | |     -------
79 | |     A (pseudo)-random float32 in the interval [0, 1]
80 | |
81 | |     """
   | |_______^
82 |       integer = tau_rand_int(state)
83 |       return abs(float(integer) / 0x7FFFFFFF)
   |

D417 Missing argument description in the docstring for `norm`: `vec`
  --> umap/utils.py:87:5
   |
86 | @numba.njit()
87 | def norm(vec):
   |     ^^^^
88 |     """Compute the (standard l2) norm of a vector.
   |

D103 Missing docstring in public function
   --> umap/utils.py:135:5
    |
134 | # Generates a timestamp for use in logging messages when verbose=True
135 | def ts():
    |     ^^
136 |     return time.ctime(time.time())
    |

FBT002 Boolean default positional argument in function definition
   --> umap/utils.py:141:24
    |
139 | # I'm not enough of a numba ninja to numba this successfully.
140 | # np.arrays of lists, which are objects...
141 | def csr_unique(matrix, return_index=True, return_inverse=True, return_counts=True):
    |                        ^^^^^^^^^^^^
142 |     """Find the unique elements of a sparse csr matrix.
143 |     We don't explicitly construct the unique matrix leaving that to the user
    |

FBT002 Boolean default positional argument in function definition
   --> umap/utils.py:141:43
    |
139 | # I'm not enough of a numba ninja to numba this successfully.
140 | # np.arrays of lists, which are objects...
141 | def csr_unique(matrix, return_index=True, return_inverse=True, return_counts=True):
    |                                           ^^^^^^^^^^^^^^
142 |     """Find the unique elements of a sparse csr matrix.
143 |     We don't explicitly construct the unique matrix leaving that to the user
    |

FBT002 Boolean default positional argument in function definition
   --> umap/utils.py:141:64
    |
139 | # I'm not enough of a numba ninja to numba this successfully.
140 | # np.arrays of lists, which are objects...
141 | def csr_unique(matrix, return_index=True, return_inverse=True, return_counts=True):
    |                                                                ^^^^^^^^^^^^^
142 |     """Find the unique elements of a sparse csr matrix.
143 |     We don't explicitly construct the unique matrix leaving that to the user
    |

D205 1 blank line required between summary line and description
   --> umap/utils.py:142:5
    |
140 |   # np.arrays of lists, which are objects...
141 |   def csr_unique(matrix, return_index=True, return_inverse=True, return_counts=True):
142 | /     """Find the unique elements of a sparse csr matrix.
143 | |     We don't explicitly construct the unique matrix leaving that to the user
144 | |     who may not want to duplicate a massive array in memory.
145 | |     Returns the indices of the input array that give the unique values.
146 | |     Returns the indices of the unique array that reconstructs the input array.
147 | |     Returns the number of times each unique row appears in the input matrix.
148 | |
149 | |     matrix: a csr matrix
150 | |     return_index = bool, optional
151 | |         If true, return the row indices of 'matrix'
152 | |     return_inverse: bool, optional
153 | |         If true, return the indices of the unique array that can be
154 | |            used to reconstruct 'matrix'.
155 | |     return_counts = bool, optional
156 | |         If true, returns the number of times each unique item appears in 'matrix'
157 | |
158 | |     The unique matrix can computed via
159 | |     unique_matrix = matrix[index]
160 | |     and the original matrix reconstructed via
161 | |     unique_matrix[inverse]
162 | |     """
    | |_______^
163 |       lil_matrix = matrix.tolil()
164 |       rows = np.asarray(
    |
help: Insert single blank line

D205 1 blank line required between summary line and description
   --> umap/utils.py:177:5
    |
176 |   def disconnected_vertices(model):
177 | /     """Returns a boolean vector indicating which vertices are disconnected from the umap graph.
178 | |     These vertices will often be scattered across the space and make it difficult to focus on the main
179 | |     manifold.  They can either be filtered and have UMAP re-run or simply filtered from the interactive plotting tool
180 | |     via the subset_points parameter.
181 | |     Use ~disconnected_vertices(model) to only plot the connected points.
182 | |
183 | |     Parameters.
184 | |     ----------
185 | |     model: a trained UMAP model
186 | |
187 | |     Returns
188 | |     -------
189 | |     A boolean vector indicating which points are disconnected
190 | |
191 | |     """
    | |_______^
192 |       check_is_fitted(model, "graph_")
193 |       if model.unique:
    |
help: Insert single blank line

D401 First line of docstring should be in imperative mood: "Returns a boolean vector indicating which vertices are disconnected from the umap graph."
   --> umap/utils.py:177:5
    |
176 |   def disconnected_vertices(model):
177 | /     """Returns a boolean vector indicating which vertices are disconnected from the umap graph.
178 | |     These vertices will often be scattered across the space and make it difficult to focus on the main
179 | |     manifold.  They can either be filtered and have UMAP re-run or simply filtered from the interactive plotting tool
180 | |     via the subset_points parameter.
181 | |     Use ~disconnected_vertices(model) to only plot the connected points.
182 | |
183 | |     Parameters.
184 | |     ----------
185 | |     model: a trained UMAP model
186 | |
187 | |     Returns
188 | |     -------
189 | |     A boolean vector indicating which points are disconnected
190 | |
191 | |     """
    | |_______^
192 |       check_is_fitted(model, "graph_")
193 |       if model.unique:
    |

D103 Missing docstring in public function
  --> umap/validation.py:9:5
   |
 8 | @numba.njit()
 9 | def trustworthiness_vector_bulk(
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
10 |     indices_source, indices_embedded, max_k,
11 | ):  # pragma: no cover
   |

D103 Missing docstring in public function
  --> umap/validation.py:35:5
   |
35 | def make_trustworthiness_calculator(metric):  # pragma: no cover
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
36 |     @numba.njit(parallel=True)
37 |     def trustworthiness_vector_lowmem(source, indices_embedded, max_k):
   |

D103 Missing docstring in public function
  --> umap/validation.py:72:5
   |
72 | def trustworthiness_vector(
   |     ^^^^^^^^^^^^^^^^^^^^^^
73 |     source, embedding, max_k, metric="euclidean",
74 | ):  # pragma: no cover
   |

Found 2223 errors (1109 fixed, 1114 remaining).

ruff format..............................................................Failed
- hook id: ruff-format
- files were modified by this hook

warning: The top-level linter settings are deprecated in favour of their counterparts in the `lint` section. Please update the following options in `pyproject.toml`:
  - 'per-file-ignores' -> 'lint.per-file-ignores'
warning: `incorrect-blank-line-before-class` (D203) and `no-blank-line-before-class` (D211) are incompatible. Ignoring `incorrect-blank-line-before-class`.
warning: `multi-line-summary-first-line` (D212) and `multi-line-summary-second-line` (D213) are incompatible. Ignoring `multi-line-summary-second-line`.
warning: The following rule may cause conflicts when used with the formatter: `COM812`. To avoid unexpected behavior, we recommend disabling this rule, either by removing it from the `lint.select` or `lint.extend-select` configuration, or adding it to the `lint.ignore` configuration.
35 files reformatted, 10 files left unchanged

ty type checker..........................................................Failed
- hook id: ty
- exit code: 2

ty failed
  Cause: /home/georgepearse/umap/pyproject.toml is not a valid `pyproject.toml`: TOML parse error at line 104, column 1
    |
104 | python_version = "3.9"
    | ^^^^^^^^^^^^^^
unknown field `python_version`, expected one of `environment`, `src`, `rules`, `terminal`, `overrides`

  Cause: TOML parse error at line 104, column 1
    |
104 | python_version = "3.9"
    | ^^^^^^^^^^^^^^
unknown field `python_version`, expected one of `environment`, `src`, `rules`, `terminal`, `overrides`

Skylos static analysis...................................................Passed
trim trailing whitespace.................................................Failed
- hook id: trailing-whitespace
- exit code: 1
- files were modified by this hook

Fixing doc/mutual_nn_umap.rst
Fixing doc/benchmarking.rst
Fixing doc/parameters.rst
Fixing doc/embedding_space.rst
Fixing doc/performance.rst
Fixing examples/iris/iris.html
Fixing doc/images/galaxy10_subset.svg
Fixing doc/parametric_umap.rst
Fixing azure-pipelines.yml
Fixing doc/outliers.rst
Fixing doc/composing_models.rst
Fixing doc/nomic_atlas_umap_of_text_embeddings.rst
Fixing doc/images/galaxy10_2D_densmap_supervised_prediction.svg
Fixing doc/faq.rst
Fixing doc/transform.rst
Fixing doc/precomputed_k-nn.rst
Fixing doc/aligned_umap_basic_usage.rst
Fixing doc/document_embedding.rst
Fixing examples/digits/digits.html
Fixing doc/images/galaxy10_2D_densmap.svg
Fixing doc/images/galaxy10_2D_umap_supervised.svg
Fixing doc/basic_usage_bokeh_example.html
Fixing doc/plotting_interactive_example.html
Fixing doc/aligned_umap_politics_demo.rst
Fixing doc/basic_usage.rst
Fixing doc/transform_landmarked_pumap.rst
Fixing doc/images/galaxy10_2D_umap.svg
Fixing doc/clustering.rst
Fixing doc/interactive_viz.rst
Fixing doc/how_umap_works.rst
Fixing doc/images/galaxy10_2D_umap_supervised_prediction.svg
Fixing doc/images/galaxy10_2D_densmap_supervised.svg
Fixing doc/inverse_transform.rst
Fixing doc/nomic_atlas_visualizing_mnist_training_dynamics.rst
Fixing CONTRIBUTING.md
Fixing doc/supervised.rst
Fixing doc/plotting.rst

fix end of files.........................................................Failed
- hook id: end-of-file-fixer
- exit code: 1
- files were modified by this hook

Fixing paper.bib
Fixing doc/aligned_umap_plotly_plot.html
Fixing doc/performance.rst
Fixing examples/iris/iris.html
Fixing doc/parametric_umap.rst
Fixing azure-pipelines.yml
Fixing doc/nomic_atlas_umap_of_text_embeddings.rst
Fixing doc/faq.rst
Fixing doc/scientific_papers.rst
Fixing doc/precomputed_k-nn.rst
Fixing doc/document_embedding.rst
Fixing doc/sparse.rst
Fixing examples/digits/digits.html
Fixing examples/README.txt
Fixing doc/basic_usage_bokeh_example.html
Fixing .gitattributes
Fixing doc/Makefile
Fixing doc/plotting_interactive_example.html
Fixing doc/aligned_umap_politics_demo.rst
Fixing doc/release_notes.rst
Fixing .gitignore
Fixing doc/transform_landmarked_pumap.rst
Fixing .idea/umap-nan.iml
Fixing doc/clustering.rst
Fixing doc/api.rst
Fixing doc/nomic_atlas_visualizing_mnist_training_dynamics.rst

check yaml...............................................................Passed
check for added large files..............................................Passed
check python ast.........................................................Passed
check for merge conflicts................................................Passed
